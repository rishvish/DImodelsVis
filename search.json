[{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://rishvish.github.io/DImodelsVis/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"loading-necessary-libraries","dir":"Articles","previous_headings":"","what":"Loading necessary libraries","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"","code":"library(DImodels) library(DImodelsVis) library(DImodelsMulti) library(dplyr) library(ggplot2)"},{"path":[]},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"load-data","dir":"Articles","previous_headings":"Data exploration","what":"Load data","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"data (henceforward referred Belgium) comes BEF experiment conducted Belgium part wider “Agrodiversity Experiment” Kirwan et al 2014. study, thirty experimental plots established one four species (two grasses G1-G2 legumes L1-L2), representing fifteen plant communities, sown two seeding densities. Three ecosystem function responses, namely DM yield (called Sown), Weed suppression (called Weed) Nitrogen yield (called N) recorded plot single time point stored column Y. data available DImodelsMulti R package analysis dataset can found Dooley et al., 2015.","code":"head(dataBEL) #>   Plot  G1  G2  L1  L2 Density  Var VarNum       Y #> 1    1 0.7 0.1 0.1 0.1       1 Sown      1 104.156 #> 2    1 0.7 0.1 0.1 0.1       1 Weed      2 100.058 #> 3    1 0.7 0.1 0.1 0.1       1    N      3  87.996 #> 4    2 0.1 0.7 0.1 0.1       1 Sown      1  82.547 #> 5    2 0.1 0.7 0.1 0.1       1 Weed      2  89.801 #> 6    2 0.1 0.7 0.1 0.1       1    N      3  72.239"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"model-fitting","dir":"Articles","previous_headings":"","what":"Model fitting","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"fit average pairwise Diversity-Interactions model three ecosystem functions Belgium dataset using DImulti() function DImodelsMulti package. main benefit fitting single model responses allows us capture covariances ecosystem functions. model coefficients follows average interaction effect significant three ecosystem functions. Additionally, sown positively correlated two ecosystem functions Weed N negatively correlated.","code":"# Name of compositional predictors (species) species <- c(\"G1\", \"G2\", \"L1\", \"L2\") # Functional groupings of species FG <- c(\"Gr\", \"Gr\", \"Le\", \"Le\") # Colours to be used for pie-glyphs for all figures pie_cols <- get_colours(vars = species, FG = FG)  model <- DImulti(prop = species, FG = FG, y = \"Y\",                   eco_func = c(\"Var\", \"un\"),                  unit_IDs = \"Plot\", DImodel = \"AV\",                  method = \"REML\", data = dataBEL) model #> Note:  #> Method Used = REML  #> Correlation Structure Used = un #>  Average Term Model #> Theta value(s) = 1,1,1 #>  #> Generalized least squares fit by REML #>   Model: Y ~ 0 + Var:((G1_ID + G2_ID + L1_ID + L2_ID + AV))  #>       AIC       BIC    logLik  #>  560.2461  608.9134 -259.1231  #>  #>  Multivariate Correlation Structure: General #>  Formula: ~0 | Plot  #>  Parameter estimate(s): #>  Correlation:  #>   1      2      #> 2  0.738        #> 3 -0.175  0.386 #>  #>  #> Table: Fixed Effect Coefficients #>  #>                 Beta      Std. Error   t-value   p-value     Signif  #> --------------  --------  -----------  --------  ----------  ------- #> VarN:G1_ID      +49.113   4.966        9.889     3.091e-15   ***     #> VarSown:G1_ID   +67.548   4.176        16.174    3.662e-26   ***     #> VarWeed:G1_ID   +75.241   8.341        9.020     1.362e-13   ***     #> VarN:G2_ID      +33.173   4.966        6.679     3.682e-09   ***     #> VarSown:G2_ID   +49.019   4.176        11.737    1.182e-18   ***     #> VarWeed:G2_ID   +86.523   8.341        10.373    3.826e-16   ***     #> VarN:L1_ID      +93.338   4.966        18.794    4.283e-30   ***     #> VarSown:L1_ID   +76.145   4.176        18.233    2.777e-29   ***     #> VarWeed:L1_ID   +54.803   8.341        6.570     5.871e-09   ***     #> VarN:L2_ID      +72.159   4.966        14.529    1.669e-23   ***     #> VarSown:L2_ID   +50.810   4.176        12.166    1.999e-19   ***     #> VarWeed:L2_ID   +38.722   8.341        4.642     1.437e-05   ***     #> VarN:AV         +67.685   10.827       6.251     2.263e-08   ***     #> VarSown:AV      +86.495   9.104        9.500     1.674e-14   ***     #> VarWeed:AV      +83.296   18.184       4.581     1.809e-05   ***     #>  #> Signif codes: 0-0.001 '***', 0.001-0.01 '**', 0.01-0.05 '*', 0.05-0.1 '+', 0.1-1.0 ' ' #>  #> Degrees of freedom: 90 total; 75 residual #> Residual standard error: 8.271401  #>  #> Marginal variance covariance matrix #>            N   Sown    Weed #> N     68.416 42.450 -20.059 #> Sown  42.450 48.377  37.290 #> Weed -20.059 37.290 192.990 #>   Standard Deviations: 8.2714 6.9554 13.892"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"model-diagnostics","dir":"Articles","previous_headings":"","what":"Model diagnostics","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"model diagnostics function works directly DImodelsMulti model object. However, \"Pearson Residual vs Fitted\" \"Qunatile-Quantile\" plots can created models.  don’t seem strong violations model assumptions. pie-glyphs indicate mixture perform higher monocultures across board. default, ecosystem functions plotted panel, however also possible view separate panels follows:","code":"model_diagnostics(model = model, which = c(1, 2), nrow = 1) model_diagnostics(model = model, which = c(1, 2), nrow = 2) +    facet_wrap(~Var)"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"model-interpretation","dir":"Articles","previous_headings":"","what":"Model interpretation","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"visualisation functions aiding model interpretation DImodelsVis integrate smoothly statistical model objects fit using DImodelsMulti. visualisations automatically split separate panels ecosystem function (time-point) model default. However, users also option create visualisations specific ecosystem functions (time-points) desire.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"gradient-change-plot","dir":"Articles","previous_headings":"Model interpretation","what":"Gradient-change plot","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"depict average BEF relationship respect species richness three ecosystem functions.  BEF relationship observed across three ecosystem functions exhibits characteristic saturating shape, gains function diminish diversity increases.","code":"grad_data <- get_equi_comms(4, variables = c(\"G1\", \"G2\", \"L1\", \"L2\")) %>%   mutate(\"Rich.\" = Richness)  gradient_change(model = model, data = grad_data, nrow = 1)"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"conditional-ternary-plot","dir":"Articles","previous_headings":"Model interpretation","what":"Conditional ternary plot","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"create conditional ternary diagram proportion L1 fixed 0, 0.25, 0.5.  prediction DM nitrogen yield proportion L1 increases 0.5, weed suppression decreases.","code":"conditional_ternary(model = model, resolution = 1,                     tern_vars = c(\"G1\", \"G2\", \"L2\"),                     conditional = data.frame(L1 = c(0, 0.25, 0.5)),                     lower_lim = 30, upper_lim = 110, nlevels = 8,                     nrow = 3)"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"grouped-ternary-plot","dir":"Articles","previous_headings":"Model interpretation","what":"Grouped ternary plot","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"create grouped ternary plot two grasses grouped together total grasses proportion split equally G1 G2. Additionally, till now using default option showing visualisations ecosystem function. example, showcase can changed, show plots nitrogen yield weed suppression example. However, note possible visualisation package.  visualisation clearly shows trade-weed suppression nitrogen yield weed suppression maximised increasing proportion grasses nitrogen yield maximised increases proportion legumes.","code":"grouped_ternary(model = model, resolution = 1,                 FG = c(\"G\", \"G\", \"L1\", \"L2\"),                 # Split of species within each group                 values = c(0.5, 0.5, 1, 1),                 lower_lim = 30, upper_lim = 110, nlevels = 8,                 add_var = list(\"Var\" = c(\"N\", \"Weed\")),                 nrow = 2) # Arrange in two rows"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"effects-plot","dir":"Articles","previous_headings":"Model interpretation","what":"Effects plot","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"visualise effect adding L1 L2 several equi-proportional mixtures ecosystem function.  figure shows single species maximizes three ecosystem functions. example, increasing proportion L1 improves dry matter nitrogen yield leads marked reduction weed suppression.","code":"eff_data <- get_equi_comms(4, variables = c(\"G1\", \"G2\", \"L1\", \"L2\"))  visualise_effects(model = model, data = eff_data,                    var_interest = c(\"L1\", \"L2\"),                    # arrange plot in three row (one for each function)                   nrow = 3)"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"simplex-path-plot","dir":"Articles","previous_headings":"Model interpretation","what":"Simplex path plot","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"depict change predicted response move four-species centroid community towards binary two-species mixture. addition standard arguments, also show one can create multiple plots different levels non-compositional experimental treatments data (used predictors model). example, suppose used Density predictor model wished visualise performance differ across two seeding density levels, one follows:  example, density included predictor model, two panels different density levels appear identical. Nonetheless, approach applied situations non-compositional variable used predictor visualise performance, across different values. Importantly, flexibility extends visualisation within package. Furthermore, note possible visualisation package well.","code":"# The centroid community (starting point for the straight line) starts <- tribble( ~G1,  ~G2,  ~L1,  ~L2,                   0.25, 0.25, 0.25, 0.25) # The six binary mixtures (ending points for the straight lines) ends <- tribble(~G1,    ~G2,  ~L1,  ~L2,                   0.5,  0.5,    0,    0,                   0.5,    0,  0.5,    0,                   0.5,    0,    0,  0.5,                     0,  0.5,  0.5,    0,                     0,  0.5,    0,  0.5,                     0,    0,  0.5,  0.5)  # Create the visualisation simplex_path(model = model,              starts = starts, ends = ends,              # Manually specify to create plot for Weed and N              add_var = list(\"Density\" = factor(c(- 1, 1))),                nrow = 3, ncol = 2)"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-DImodelsMulti-models.html","id":"prediction-contributions-plot","dir":"Articles","previous_headings":"Model interpretation","what":"Prediction contributions plot","title":"Using DImodelsVis with regression models fit using the `DImodelsMulti` R package","text":"Currently, prediction contributions plot work directly DImulti object. However, functionality soon added. time , prediction contributions plot can created DImulti model. steps followed: 1. Create data.frame containing species communities wish visualise prediction contributions column containing names ecosystem functions wish generate predictions (add_add_var() function helps ). Ensure data also contains additional predictors model nitrogen treatment, seeding density, etc. 2. Prepare data needed prediction contributions plot using prediction_contributions_data() function. important steps create manual grouping coefficients using coeff_groups parameter ensuring identical coefficients repeated across functions assigned group thus share single colour plot. example, G1 identity effect (G1_ID) average interaction effect (AV) across three ecosystem functions grouped single term. grouping can done either coefficient indices names mandatory group coefficients. user can decide grouping best suits example. 3. Pass prepared data prediction_contributions_plot() function visualise prediction contributions.  best performing monoculture differs across three ecosystem function. However, four species centroid mixture containing 25% species performs comparably -performs best monoculture ecosystem function.","code":"pred_data <- get_equi_comms(4, richness_lvl = c(1, 2, 4),                             variables = c(\"G1\", \"G2\", \"L1\", \"L2\")) %>%   mutate(labels = c(\"G1_mono\", \"G1_mono\", \"G1_mono\", \"L2_mono\",                     \"G1-G2\", \"G1-L1\", \"G1-L2\", \"G2-L1\", \"G2-L2\", \"L1-L2\",                     \"Centroid\")) %>%    # Repeat each community across the three ecosystem functions   add_add_var(add_var = list(\"Var\" = c(\"N\", \"Sown\", \"Weed\"))) %>%    mutate(G1_ID = G1, G2_ID = G2, L1_ID = L1, L2_ID = L2,          AV = DI_data_E_AV(prop = 1:4, data = .)$AV,          \"Rich.\" = Richness)  prediction_contributions_data(data = pred_data, model = model,                                bar_labs = \"labels\",                               # Important to group the coefficients                               groups = list(\"G1\" = 1:3, \"G2\" = 4:6,                                             \"L1\" = 7:9, \"L2\" = 10:12,                                             \"AV\" = 13:15)) %>%    prediction_contributions_plot(colours = c(pie_cols, \"steelblue3\"),                                 nrow = 3) +   facet_grid(~ Rich., scale = \"free_x\", space = \"free_x\") +   theme(axis.text.x = element_text(angle = 45, hjust = 1.1, vjust = 1.1))"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"load-libraries","dir":"Articles","previous_headings":"","what":"Load libraries","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"following libraries used data processing generating visualisations.","code":"library(DImodels)     # For loading the dataset library(DImodelsVis)  # For creating visualisations library(dplyr)        # For data manipulation library(ggplot2)      # For modifying visualisations library(PieGlyph)     # Adding Pie-glyphs on figures"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"use sim4 data (henceforth referred sim4) DImodels R package. sim4 data simulated represent patterns commonly observed BEF studies. proportions six species (labelled p1 p6) manipulated create 33 communities, containing one six species. Additionally, treatment covariate representing three nitrogen fertilisation levels (50, 150, 250) kg/ha/yr also added every community replicated treatment level. species categorised functional groups based ecological roles: p1 p2 classified grasses, p3 p4 legumes, p5 p6 herbs. response variable interest annual aboveground dry-matter yield (tonnes/ha). first rows data printed .","code":"data(\"sim4\") head(sim4, 8) #>   richness treatment p1 p2 p3 p4 p5 p6 response #> 1        1        50  1  0  0  0  0  0   26.325 #> 2        1        50  1  0  0  0  0  0   29.083 #> 3        1        50  1  0  0  0  0  0   27.581 #> 4        1        50  0  1  0  0  0  0   17.391 #> 5        1        50  0  1  0  0  0  0   15.678 #> 6        1        50  0  1  0  0  0  0   14.283 #> 7        1        50  0  0  1  0  0  0   16.317 #> 8        1        50  0  0  1  0  0  0   19.553"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"model-fitting","dir":"Articles","previous_headings":"","what":"Model fitting","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"relabel species columns data two grasses G1 G2, legumes L1 L2, herbs H1 H2. Furthermore also add within functional group interaction terms data.","code":"model_data <- sim4 %>%    # Rename species columns   rename(G1 = p1, G2 = p2, L1 = p3,           L2 = p4, H1 = p5, H2 = p6) %>%    # Total functional group proportion   mutate(G = G1 + G2,          L = L1 + L2,          H = H1 + H2) %>%    # Add additional interaction columns to data   mutate(wfg_G = G1*G2, wfg_L = L1*L2, wfg_H = H1*H2,          bfg_GL = (G1 + G2) * (L1 + L2),          bfg_GH = (G1 + G2) * (H1 + H2),          bfg_LH = (L1 + L2) * (H1 + H2)) %>%    # Add dummy variables for treatment   mutate(treatment50 = ifelse(treatment == 50, 1, 0),          treatment150 = ifelse(treatment == 150, 1, 0),          treatment250 = ifelse(treatment == 250, 1, 0)) %>%    # Rearrange columns   select(-response, everything(), response)   head(model_data, 8) #>   richness treatment G1 G2 L1 L2 H1 H2 G L H wfg_G wfg_L wfg_H bfg_GL bfg_GH #> 1        1        50  1  0  0  0  0  0 1 0 0     0     0     0      0      0 #> 2        1        50  1  0  0  0  0  0 1 0 0     0     0     0      0      0 #> 3        1        50  1  0  0  0  0  0 1 0 0     0     0     0      0      0 #> 4        1        50  0  1  0  0  0  0 1 0 0     0     0     0      0      0 #> 5        1        50  0  1  0  0  0  0 1 0 0     0     0     0      0      0 #> 6        1        50  0  1  0  0  0  0 1 0 0     0     0     0      0      0 #> 7        1        50  0  0  1  0  0  0 0 1 0     0     0     0      0      0 #> 8        1        50  0  0  1  0  0  0 0 1 0     0     0     0      0      0 #>   bfg_LH treatment50 treatment150 treatment250 response #> 1      0           1            0            0   26.325 #> 2      0           1            0            0   29.083 #> 3      0           1            0            0   27.581 #> 4      0           1            0            0   17.391 #> 5      0           1            0            0   15.678 #> 6      0           1            0            0   14.283 #> 7      0           1            0            0   16.317 #> 8      0           1            0            0   19.553"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"fitting-the-model","dir":"Articles","previous_headings":"","what":"Fitting the model","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"regression model fit model_data using glm() function model equation shown : y=βG1pG1+βG2pG2+βL1pL1+βL2pL2+βH1pH1+βH2pH2+ωGLpGpL+ωGHpGpH+ωLHpLpH+ωGpG1pG2+ωLpL1pL2+ωHpH1pH2+α150A150+α250A250+ϵ \\begin{align}  y &= \\beta_{G1} p_{G1} + \\beta_{G2} p_{G2} + \\beta_{L1} p_{L1} + \\beta_{L2} p_{L2} + \\beta_{H1} p_{H1} + \\beta_{H2} p_{H2} + \\nonumber \\\\ &\\quad \\quad \\omega_{GL} p_{G} p_{L} + \\omega_{GH} p_{G} p_{H} + \\omega_{LH} p_{L} p_{H} + \\nonumber \\\\ & \\quad \\quad \\omega_{G} p_{G1} p_{G2} + \\omega_{L} p_{L1} p_{L2} + \\omega_{H} p_{H1} p_{H2} + \\nonumber \\\\ & \\quad \\quad \\alpha_{150} A_{150} + \\alpha_{250} A_{250} + \\epsilon \\end{align} yy response (annual biomass yield), pG1p_{G1}, pG2p_{G2}, pL1p_{L1}, pL2p_{L2}pH1p_{H1}, pH2p_{H2} sown proportions βG1\\beta_{G1}, βG2\\beta_{G2}, βL1\\beta_{L1}, βL2\\beta_{L2}, βH1\\beta_{H1}, βH2\\beta_{H2} identity effects six species G1, G2, L1, L2, H1, H2 respectively.functional group proportions grasses, legumes, herbs represented pGp_{G} (pG=pG1+pG2p_{G} = p_{G1} + p_{G2}), pLp_{L} (pL=pL1+pL2p_{L} = p_{L1} + p_{L2}), pHp_{H} (pH=pH1+pH2p_{H} = p_{H1} + p_{H2}), respectively. functional group interactions captured ωGL\\omega_{GL}, ωGH\\omega_{GH}, ωLH\\omega_{LH} ωG\\omega_{G}, ωL\\omega_{L}, ωH\\omega_{H} capturing within-functional group interaction grasses, legumes, herbs, respectively. additional effects fertiliser treatment captured α150\\alpha_{150} α250\\alpha_{250} A150A_{150} A250A_{250} dummy variables specific level fertiliser treatment. Finally, error term ϵ\\epsilon assumed normal mean 00 variance σ2\\sigma^2. R code fitting model using glm() along model output presented . model coefficients follows. Note: intercept dropped model due compositional nature predictors model. proceed model create visualisations interpreting results.","code":"cust_model <- glm(response ~ 0 + G1 + G2 + L1 + L2 + H1 + H2 +                            bfg_GL + bfg_GH + bfg_LH +                            wfg_G + wfg_L + wfg_H +                            treatment150 + treatment250,               data = model_data) summary(cust_model) #>  #> Call: #> glm(formula = response ~ 0 + G1 + G2 + L1 + L2 + H1 + H2 + bfg_GL +  #>     bfg_GH + bfg_LH + wfg_G + wfg_L + wfg_H + treatment150 +  #>     treatment250, data = model_data) #>  #> Coefficients: #>              Estimate Std. Error t value Pr(>|t|)     #> G1            26.9878     0.7698  35.057  < 2e-16 *** #> G2            16.9599     0.7698  22.031  < 2e-16 *** #> L1            19.3803     0.7698  25.175  < 2e-16 *** #> L2            21.1189     0.7698  27.434  < 2e-16 *** #> H1            10.4473     0.7698  13.571  < 2e-16 *** #> H2            12.5173     0.7698  16.260  < 2e-16 *** #> bfg_GL        16.1743     2.5691   6.296 4.57e-09 *** #> bfg_GH        21.1347     2.5691   8.227 1.96e-13 *** #> bfg_LH        26.0550     2.5691  10.142  < 2e-16 *** #> wfg_G         40.8789     5.5387   7.381 1.82e-11 *** #> wfg_L         15.6723     5.5387   2.830  0.00542 **  #> wfg_H         16.2103     5.5387   2.927  0.00406 **  #> treatment150   3.2985     0.4880   6.759 4.51e-10 *** #> treatment250   5.8536     0.4880  11.995  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for gaussian family taken to be 5.596318) #>  #>     Null deviance: 93567.57  on 141  degrees of freedom #> Residual deviance:   710.73  on 127  degrees of freedom #> AIC: 658.21 #>  #> Number of Fisher Scoring iterations: 2"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"visualisations","dir":"Articles","previous_headings":"","what":"Visualisations","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"model object stored cust_model used creating visualisations shown section. follow “Modular plotting” workflow shown right side Figure 3 main manuscript data needed visualisation created first modified per needs passed respective plotting function create visualisation. first define common set variables used across board ease use","code":"# Names of the compositional predictors (i.e., species) in the model species <- c(\"G1\", \"G2\", \"L1\", \"L2\", \"H1\", \"H2\")  # Functional groupings of the species FG <- c(\"G\", \"G\", \"L\", \"L\", \"H\", \"H\")  # Colours to be used for the six compostional variables (species) in plots var_cols <- get_colours(vars = species, FG = FG)"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"model-diagnostics-plot","dir":"Articles","previous_headings":"Visualisations","what":"Model diagnostics plot","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"Let’s first examine model diagnostics plots fitted model ensure severe problems model assumptions. data needed creating diagnostics plot prepared using model_diagnostics_data() function. primary difference (functions) compared using “Direct plotting” functions (workflow left site Figure 3 main manuscript) names compositional predictors specified prop parameter. model_diagnostics_data() function returns original data fitted model additional columns containing diagnostic information observation. returned data looks follows. data-preparation functions also add additional attributes prepared data accessed plotting functions creating visualisations. case, primary attribute added data names compositional predictors key \"prop\" can accessed follows. prepared data-frame can updated user desires add additional columns modify existing ones passed model_diagnostics_plot() function creating visualisation follows.   might desirable reduce -plotting showing extreme observations pie-glyphs rendering remaining points. only_extremes conjunction npoints argument can used.  “Residual vs Fitted” plot figure indicates residuals centered around y = 0 line relatively constant variance across board. “QQ-Plot” indicates normality assumption doesn’t seem violated. observations highlighted pie-glyphs primarily containing 'H2' indicates model may capturing information 'H2' well might investigate . figure can also customised needed. example, suppose user wishes overlay “Residual vs Fitted” plot pie-glyphs observations receiving 250 kg nitrogen treatment. can achieved following code output shown :","code":"diag_data <- model_diagnostics_data(   model = cust_model,  # Regression model object   prop = species)      # Names of the compositional predictors head(diag_data, 8) #>   response G1 G2 L1 L2 H1 H2 bfg_GL bfg_GH bfg_LH wfg_G wfg_L wfg_H #> 1   26.325  1  0  0  0  0  0      0      0      0     0     0     0 #> 2   29.083  1  0  0  0  0  0      0      0      0     0     0     0 #> 3   27.581  1  0  0  0  0  0      0      0      0     0     0     0 #> 4   17.391  0  1  0  0  0  0      0      0      0     0     0     0 #> 5   15.678  0  1  0  0  0  0      0      0      0     0     0     0 #> 6   14.283  0  1  0  0  0  0      0      0      0     0     0     0 #> 7   16.317  0  0  1  0  0  0      0      0      0     0     0     0 #> 8   19.553  0  0  1  0  0  0      0      0      0     0     0     0 #>   treatment150 treatment250      .hat   .sigma      .cooksd  .fitted     .resid #> 1            0            0 0.1058936 2.374202 7.426182e-04 26.98775 -0.6627540 #> 2            0            0 0.1058936 2.366805 7.422170e-03 26.98775  2.0952460 #> 3            0            0 0.1058936 2.374365 5.950185e-04 26.98775  0.5932460 #> 4            0            0 0.1058936 2.374675 3.142566e-04 16.95987  0.4311335 #> 5            0            0 0.1058936 2.371950 2.778091e-03 16.95987 -1.2818665 #> 6            0            0 0.1058936 2.361594 1.211475e-02 16.95987 -2.6768665 #> 7            0            0 0.1058936 2.357422 1.586474e-02 19.38028 -3.0632750 #> 8            0            0 0.1058936 2.374967 5.043954e-05 19.38028  0.1727250 #>     .stdresid Obs Label        .qq weights #> 1 -0.29628289   1     1 -0.4016478       1 #> 2  0.93667566   2     2  1.0564117       1 #> 3  0.26520947   3     3  0.3633920       1 #> 4  0.19273739   4     4  0.2699041       1 #> 5 -0.57305593   5     5 -0.5614833       1 #> 6 -1.19668798   6     6 -1.2655513       1 #> 7 -1.36943116   7     7 -1.5523965       1 #> 8  0.07721636   8     8  0.1606864       1 attr(diag_data, \"prop\") #> [1] \"G1\" \"G2\" \"L1\" \"L2\" \"H1\" \"H2\" model_diagnostics_plot(     data = diag_data, # Output data-frame returned by model_diagnostics_data()     which = c(1, 2),  # Only print first 2 plots to save space     pie_colours = var_cols # Colours for the pie-slices   ) #> ✔ Created all plots. model_diagnostics_plot(     data = diag_data,      which = c(1, 2),       pie_colours = var_cols,     only_extremes = TRUE, # Show only extreme points as pie-glyphs     npoints = 5) # Show the five most extreme points as pie-glyphs (default is 3) #> ✔ Created all plots. # Extract data for containing observations recieving 250 N treatment data_250 <- diag_data %>%    filter(treatment250 == 1)  # We first create the diagnostic plot diag_plot <- model_diagnostics_plot(     data = diag_data,      which = c(1),   # Only show residual vs fitted plot     pie_colours = var_cols,     only_extremes = TRUE, # Show only extreme points as pie-glyphs     npoints = 0, # Show the no extreme points as pie-glyphs   ) #> ✔ Created all plots.  # Now we can use traditional ggplot machinery to modify the plot diag_plot +    # Manually add pie-glyphs using the subsetted data from above   geom_pie_glyph(data = data_250, slices = species, colour = \"black\")"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"prediction-contributions","dir":"Articles","previous_headings":"Visualisations","what":"Prediction contributions","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"prediction_contributions_data() function can called create template data needed visualising contributions various terms model predicted response. first create subset data predictions contributions visualised. example visualise six monocultures, 50-50 mixtures two grasses, legumes herb along six-species centroid mixture receiving 250kg nitrogen treatment. communities can subsetted data follows data containing specific commmunities interest can passed prediction_contributions_data() function create template necessary visualising contributions. Note: predictors variables model present data function throw error. prepared data now contains additional columns (.Contributions .Value) describe contributions model term response community. predicted response (.Pred) along uncertainty (95% default) around also present (.Upper .Lower). Finally, additional information grouping labelling community (.Community .x_labs). Note: data passed function nn rows model pp coefficients, resultant data n*pn*p rows. model fit R, reason user doesn’t access fitted model object, also possible obtain data using model coefficients. Suppose access following coefficients. data generated follows. specify additional argument coeff_cols gives names columns corresponding coefficients. Note: using model coefficients generating data, uncertainty information around prediction won’t available default. However, information can obtained well user passes variance-covariance matrix coefficients vcov argument. Using prepared data, prediction-contributions plot can generated using prediction_contributions_plot() function. default, data argument needed, however, often helps manually specify colours contribution via 'colours' argument make plot informative.  figure shows G1 monoculture performs best among monocultures comparable performance six-species centroid mixture. Additionally, within grass interaction (“wfg_G”) stronger within legume (“wfg_L”) within herb (“wfg_H”) interactions. However, FG interactions (“bfg_*“) contribute towards predicted response compared within FG interactions. situations many predictors model, also possible group similar terms total contribution shown using single segment bar using groups argument prediction_contributions_data() function. output visualisation grouped FG interaction terms shown . Notice .Contributions column now combined within FG interactions opposed individual functional group level.  Finally, output visualisation can also customised additional annotations desired. example, user wishes overlay reference line plot comparisons purposes separate bars species richness, can using follows. output visualisation aesthetic changes shown ","code":"subset_data <- model_data %>%    # Filter only those observations recieving 250 N treatment   filter(treatment250 == 1) %>%    distinct(G1, G2, L1, L2, H1, H2, .keep_all = TRUE) %>%    # Filter specific communities   filter(     # Six monocultures     (G1 == 1 | G2 == 1 | L1 == 1 | L2 == 1 | H1 == 1 | H2 == 1) |      # Two species mixtures     ((G1 == 0.5 & G2 == 0.5) | (L1 == 0.5 & L2 == 0.5) | (H1 == 0.5 & H2 == 0.5)) |     # Six species centroid     (near(G1, 0.16667, tol = 0.01)))    head(subset_data) #>   richness treatment G1 G2 L1 L2 H1 H2 G L H wfg_G wfg_L wfg_H bfg_GL bfg_GH #> 1        1       250  1  0  0  0  0  0 1 0 0     0     0     0      0      0 #> 2        1       250  0  1  0  0  0  0 1 0 0     0     0     0      0      0 #> 3        1       250  0  0  1  0  0  0 0 1 0     0     0     0      0      0 #> 4        1       250  0  0  0  1  0  0 0 1 0     0     0     0      0      0 #> 5        1       250  0  0  0  0  1  0 0 0 1     0     0     0      0      0 #> 6        1       250  0  0  0  0  0  1 0 0 1     0     0     0      0      0 #>   bfg_LH treatment50 treatment150 treatment250 response #> 1      0           0            0            1   32.538 #> 2      0           0            0            1   23.644 #> 3      0           0            0            1   25.242 #> 4      0           0            0            1   24.641 #> 5      0           0            0            1   16.019 #> 6      0           0            0            1   15.449 pred_cont_data <- prediction_contributions_data(     model = cust_model, # Model used for making predicitons      data = subset_data,  # Data containing the observation for which to make prediction     # X-axis labels to be used for the bars     bar_labs = c(\"G1\", \"G2\", \"L1\", \"L2\", \"H1\", \"H2\", \"G-G\", \"L-L\", \"H-H\", \"Cent.\")   )  #> ✔ Finished data preparation. head(pred_cont_data) #> # A tibble: 6 × 14 #>   .x_labs .Community  richness treatment     G     L     H treatment50 response #>   <chr>   <fct>          <int>     <dbl> <dbl> <dbl> <dbl>       <dbl>    <dbl> #> 1 G1      Community 1        1       250     1     0     0           0     32.5 #> 2 G1      Community 1        1       250     1     0     0           0     32.5 #> 3 G1      Community 1        1       250     1     0     0           0     32.5 #> 4 G1      Community 1        1       250     1     0     0           0     32.5 #> 5 G1      Community 1        1       250     1     0     0           0     32.5 #> 6 G1      Community 1        1       250     1     0     0           0     32.5 #> # ℹ 5 more variables: .Pred <dbl>, .Lower <dbl>, .Upper <dbl>, #> #   .Contributions <chr>, .Value <dbl> (mod_coeffs <- coef(cust_model)) #>           G1           G2           L1           L2           H1           H2  #>    26.987754    16.959867    19.380275    21.118863    10.447271    12.517346  #>       bfg_GL       bfg_GH       bfg_LH        wfg_G        wfg_L        wfg_H  #>    16.174287    21.134709    26.054987    40.878915    15.672343    16.210285  #> treatment150 treatment250  #>     3.298532     5.853617 pred_cont_data <- prediction_contributions_data(     coefficients = mod_coeffs, # Model coeffecients      coeff_cols = names(mod_coeffs), # Column names corresponding to the coefficients     data = subset_data,  # Data containing the observation for which to make prediction     # X-axis labels to be used for the bars     bar_labs = c(\"G1\", \"G2\", \"L1\", \"L2\", \"H1\", \"H2\", \"G-G\", \"L-L\", \"H-H\", \"Cent.\")   )  #> ✔ Finished data preparation. head(pred_cont_data) #> # A tibble: 6 × 14 #>   .x_labs .Community  richness treatment     G     L     H treatment50 response #>   <chr>   <fct>          <int>     <dbl> <dbl> <dbl> <dbl>       <dbl>    <dbl> #> 1 G1      Community 1        1       250     1     0     0           0     32.5 #> 2 G1      Community 1        1       250     1     0     0           0     32.5 #> 3 G1      Community 1        1       250     1     0     0           0     32.5 #> 4 G1      Community 1        1       250     1     0     0           0     32.5 #> 5 G1      Community 1        1       250     1     0     0           0     32.5 #> 6 G1      Community 1        1       250     1     0     0           0     32.5 #> # ℹ 5 more variables: .Pred <dbl>, .Lower <dbl>, .Upper <dbl>, #> #   .Contributions <chr>, .Value <dbl> prediction_contributions_plot(   data = pred_cont_data, # Output data from prediction_contributions_data()   colours = c(# Colours for the six species contributions               var_cols,                # Colours for between FG interactions               get_shades(\"#DDCC77\", shades = 3)[[1]],                # Colours for within FG interactions               get_shades(\"#D55E00\", shades = 3)[[1]],               # Colours for nitrogen treatment               get_shades(\"#505050\", shades = 2)[[1]])) #> ✔ Created plot. pred_cont_data_grouped <- prediction_contributions_data(     model = cust_model,      data = subset_data,     # We group the three between and within FG interactions into single terms     groups = list(\"Between FG ints.\" = c(\"bfg_GL\", \"bfg_GH\", \"bfg_LH\"),                   \"Within FG ints.\" = c(\"wfg_G\", \"wfg_L\", \"wfg_H\")),     # X-axis labels to be used for the bars     bar_labs = c(\"G1\", \"G2\", \"L1\", \"L2\", \"H1\", \"H2\", \"G-G\", \"L-L\", \"H-H\", \"Cent.\")   )  #> ✔ Finished data preparation. # Notice the .Contributions column head(pred_cont_data_grouped, 10) #> # A tibble: 10 × 20 #>    .x_labs .Community  richness treatment     G     L     H wfg_G wfg_L wfg_H #>    <chr>   <fct>          <int>     <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #>  1 G1      Community 1        1       250     1     0     0     0     0     0 #>  2 G1      Community 1        1       250     1     0     0     0     0     0 #>  3 G1      Community 1        1       250     1     0     0     0     0     0 #>  4 G1      Community 1        1       250     1     0     0     0     0     0 #>  5 G1      Community 1        1       250     1     0     0     0     0     0 #>  6 G1      Community 1        1       250     1     0     0     0     0     0 #>  7 G1      Community 1        1       250     1     0     0     0     0     0 #>  8 G1      Community 1        1       250     1     0     0     0     0     0 #>  9 G1      Community 1        1       250     1     0     0     0     0     0 #> 10 G1      Community 1        1       250     1     0     0     0     0     0 #> # ℹ 10 more variables: bfg_GL <dbl>, bfg_GH <dbl>, bfg_LH <dbl>, #> #   treatment50 <dbl>, response <dbl>, .Pred <dbl>, .Lower <dbl>, .Upper <dbl>, #> #   .Contributions <chr>, .Value <dbl> grouped_cont_plot <- prediction_contributions_plot(   data = pred_cont_data_grouped, # Output data from prediction_contributions_data()   colours = c(# Colours for the six species contributions               var_cols,                # Colours for nitrogen treatment               get_shades(\"#505050\", shades = 2)[[1]],               # Colours for between FG interactions               \"#DDCC77\",                # Colours for within FG interactions               \"#0072B2\")) #> ✔ Created plot. grouped_cont_plot grouped_cont_plot +   # Add dashed reference line   geom_hline(yintercept = 25, linewidth = 1,               colour = \"black\", linetype = \"dashed\") +    facet_grid(~richness, labeller = label_both,              space = \"free_x\", scale = \"free_x\")"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"conditional-ternary-diagrams","dir":"Articles","previous_headings":"Visualisations","what":"Conditional ternary diagrams","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"conditional_ternary_data() creates function creates template data.frame can passed conditional_ternary_plot() creating conditional ternary diagrams. simple models, calling conditional_ternary_data() also add predicted response across ternary surface. However, complex models additional non-compositional predictors, default function try make predictions reasonable values non-compositional predictors (base level categorical median value continuous) won’t always desirable. users option generate template data frame without predictions setting prediction = FALSE. template can modified include additional variables required predictions passed appropriate plotting function visualisation. following code shows example creating template fix G2 L2 specific values allow G1, L1 H1 vary 0 G2+L2G2 + L2. Note: Since H2 specified , assumed zero. template necessary columns along additional attributes needed creating conditional ternary diagrams. necessary additional columns needed making predictions can added using dplyr pipeline base R. Note: specific transformation made columns raw data model fitting, transformation also added template ensure predictions accurate. create datasets making two ternaries, one communities 150 kg nitrogen treatment 250 kg nitrogen treatment. - within- functional group interaction terms also added data. Predicting response communities 150 kg nitrogen treatment Predicting response communities 150 kg nitrogen treatment necessary columns needed making predictions, can added either using base R predict() function add_prediction() function DImodelsVis. examples shown . Additionally, also show example generate predictions using model coefficients variance-covariance matrix instead model object. Note: using base R predict() function, please ensure predictions stored column called “.Pred” column visualisation function accepts predictions . datasets predictions can passed conditional_ternary_plot() function create conditional ternary diagrams. output visualisation 150 kg 250 kg nitrogen treatment shown . ensure contours across two plots comparable add upper lower limits across two using lower_lim upper_lim arguments.   contours appear structure across two treatment levels, predicted yields higher communities receiving 250 kg N/ha/annum. Within given level treatment, predicted yield maximised increasing proportion G1.","code":"cond_tern_template <- conditional_ternary_data(   prop = species, # Names of the compositional predictors   tern_vars = c(\"G1\", \"L1\", \"H1\"), # Names for the three predictors to show in the ternary   # The values at which to fix the remaining predictors   # Any compositional predictors not specified here (e.g. H2) would be assumed to be 0    conditional = data.frame(\"G2\" = c(0.2, 0.1),                             \"L2\" = c(0.1, 0.3)),   # Do not add predictions   prediction = FALSE) #> ✔ Finished data preparation.  head(cond_tern_template) #>   G1        L1          H1          .x .y  G2  L2 H2    .Sp   .Value #> 1  0 0.7000000 0.000000000 0.000000000  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 2  0 0.6988314 0.001168614 0.001669449  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 3  0 0.6976628 0.002337229 0.003338898  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 4  0 0.6964942 0.003505843 0.005008347  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 5  0 0.6953255 0.004674457 0.006677796  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 6  0 0.6941569 0.005843072 0.008347245  0 0.2 0.1  0 G2, L2 0.2, 0.1 #>               .Facet #> 1 G2 = 0.2; L2 = 0.1 #> 2 G2 = 0.2; L2 = 0.1 #> 3 G2 = 0.2; L2 = 0.1 #> 4 G2 = 0.2; L2 = 0.1 #> 5 G2 = 0.2; L2 = 0.1 #> 6 G2 = 0.2; L2 = 0.1 attributes(cond_tern_template)[-2] #> $names #>  [1] \"G1\"     \"L1\"     \"H1\"     \".x\"     \".y\"     \"G2\"     \"L2\"     \"H2\"     #>  [9] \".Sp\"    \".Value\" \".Facet\" #>  #> $class #> [1] \"data.frame\" #>  #> $prop #> [1] \"G1\" \"G2\" \"L1\" \"L2\" \"H1\" \"H2\" #>  #> $tern_vars #> [1] \"G1\" \"L1\" \"H1\" #>  #> $x_proj #> [1] \".x\" #>  #> $y_proj #> [1] \".y\" cond_tern_template150 <- cond_tern_template %>%    # Add values for the interaction columns to data   mutate(wfg_G = G1*G2, wfg_L = L1*L2, wfg_H = H1*H2,          bfg_GL = (G1 + G2) * (L1 + L2),          bfg_GH = (G1 + G2) * (H1 + H2),          bfg_LH = (L1 + L2) * (H1 + H2)) %>%   # We first want ternary for treatment150   mutate(treatment150 = 1, treatment250 = 0)  head(cond_tern_template150) #>   G1        L1          H1          .x .y  G2  L2 H2    .Sp   .Value #> 1  0 0.7000000 0.000000000 0.000000000  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 2  0 0.6988314 0.001168614 0.001669449  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 3  0 0.6976628 0.002337229 0.003338898  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 4  0 0.6964942 0.003505843 0.005008347  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 5  0 0.6953255 0.004674457 0.006677796  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 6  0 0.6941569 0.005843072 0.008347245  0 0.2 0.1  0 G2, L2 0.2, 0.1 #>               .Facet wfg_G      wfg_L wfg_H    bfg_GL       bfg_GH       bfg_LH #> 1 G2 = 0.2; L2 = 0.1     0 0.07000000     0 0.1600000 0.0000000000 0.0000000000 #> 2 G2 = 0.2; L2 = 0.1     0 0.06988314     0 0.1597663 0.0002337229 0.0009335258 #> 3 G2 = 0.2; L2 = 0.1     0 0.06976628     0 0.1595326 0.0004674457 0.0018643203 #> 4 G2 = 0.2; L2 = 0.1     0 0.06964942     0 0.1592988 0.0007011686 0.0027923835 #> 5 G2 = 0.2; L2 = 0.1     0 0.06953255     0 0.1590651 0.0009348915 0.0037177154 #> 6 G2 = 0.2; L2 = 0.1     0 0.06941569     0 0.1588314 0.0011686144 0.0046403159 #>   treatment150 treatment250 #> 1            1            0 #> 2            1            0 #> 3            1            0 #> 4            1            0 #> 5            1            0 #> 6            1            0 cond_tern_template250 <- cond_tern_template %>%    # Add additional interaction columns to data   mutate(wfg_G = G1*G2, wfg_L = L1*L2, wfg_H = H1*H2,          bfg_GL = (G1 + G2) * (L1 + L2),          bfg_GH = (G1 + G2) * (H1 + H2),          bfg_LH = (L1 + L2) * (H1 + H2)) %>%   # This will create ternary for treatment250   mutate(treatment150 = 0, treatment250 = 1)  head(cond_tern_template250) #>   G1        L1          H1          .x .y  G2  L2 H2    .Sp   .Value #> 1  0 0.7000000 0.000000000 0.000000000  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 2  0 0.6988314 0.001168614 0.001669449  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 3  0 0.6976628 0.002337229 0.003338898  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 4  0 0.6964942 0.003505843 0.005008347  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 5  0 0.6953255 0.004674457 0.006677796  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 6  0 0.6941569 0.005843072 0.008347245  0 0.2 0.1  0 G2, L2 0.2, 0.1 #>               .Facet wfg_G      wfg_L wfg_H    bfg_GL       bfg_GH       bfg_LH #> 1 G2 = 0.2; L2 = 0.1     0 0.07000000     0 0.1600000 0.0000000000 0.0000000000 #> 2 G2 = 0.2; L2 = 0.1     0 0.06988314     0 0.1597663 0.0002337229 0.0009335258 #> 3 G2 = 0.2; L2 = 0.1     0 0.06976628     0 0.1595326 0.0004674457 0.0018643203 #> 4 G2 = 0.2; L2 = 0.1     0 0.06964942     0 0.1592988 0.0007011686 0.0027923835 #> 5 G2 = 0.2; L2 = 0.1     0 0.06953255     0 0.1590651 0.0009348915 0.0037177154 #> 6 G2 = 0.2; L2 = 0.1     0 0.06941569     0 0.1588314 0.0011686144 0.0046403159 #>   treatment150 treatment250 #> 1            0            1 #> 2            0            1 #> 3            0            1 #> 4            0            1 #> 5            0            1 #> 6            0            1 # Add predictions using helper function from DImodelsVis cond_tern_template150 <- cond_tern_template150 %>%    add_prediction(model = cust_model)  # Add predictions using model coefficients mod_coeffs <- coefficients(cust_model) # Coefficients vcov_mat <- vcov(cust_model)           # vcov matrix of coefficients  cond_tern_template150 <- cond_tern_template150 %>%    add_prediction(coefficients = mod_coeffs,                  vcov = vcov_mat)  # Add predictions using base R predict function cond_tern_template250$.Pred <- predict(cust_model,                                        newdata = cond_tern_template250)  head(cond_tern_template150) #>   G1        L1          H1          .x .y  G2  L2 H2    .Sp   .Value #> 1  0 0.7000000 0.000000000 0.000000000  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 2  0 0.6988314 0.001168614 0.001669449  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 3  0 0.6976628 0.002337229 0.003338898  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 4  0 0.6964942 0.003505843 0.005008347  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 5  0 0.6953255 0.004674457 0.006677796  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 6  0 0.6941569 0.005843072 0.008347245  0 0.2 0.1  0 G2, L2 0.2, 0.1 #>               .Facet wfg_G      wfg_L wfg_H    bfg_GL       bfg_GH       bfg_LH #> 1 G2 = 0.2; L2 = 0.1     0 0.07000000     0 0.1600000 0.0000000000 0.0000000000 #> 2 G2 = 0.2; L2 = 0.1     0 0.06988314     0 0.1597663 0.0002337229 0.0009335258 #> 3 G2 = 0.2; L2 = 0.1     0 0.06976628     0 0.1595326 0.0004674457 0.0018643203 #> 4 G2 = 0.2; L2 = 0.1     0 0.06964942     0 0.1592988 0.0007011686 0.0027923835 #> 5 G2 = 0.2; L2 = 0.1     0 0.06953255     0 0.1590651 0.0009348915 0.0037177154 #> 6 G2 = 0.2; L2 = 0.1     0 0.06941569     0 0.1588314 0.0011686144 0.0046403159 #>   treatment150 treatment250    .Pred #> 1            1            0 26.05353 #> 2            1            0 26.06675 #> 3            1            0 26.07989 #> 4            1            0 26.09296 #> 5            1            0 26.10595 #> 6            1            0 26.11888 head(cond_tern_template250) #>   G1        L1          H1          .x .y  G2  L2 H2    .Sp   .Value #> 1  0 0.7000000 0.000000000 0.000000000  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 2  0 0.6988314 0.001168614 0.001669449  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 3  0 0.6976628 0.002337229 0.003338898  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 4  0 0.6964942 0.003505843 0.005008347  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 5  0 0.6953255 0.004674457 0.006677796  0 0.2 0.1  0 G2, L2 0.2, 0.1 #> 6  0 0.6941569 0.005843072 0.008347245  0 0.2 0.1  0 G2, L2 0.2, 0.1 #>               .Facet wfg_G      wfg_L wfg_H    bfg_GL       bfg_GH       bfg_LH #> 1 G2 = 0.2; L2 = 0.1     0 0.07000000     0 0.1600000 0.0000000000 0.0000000000 #> 2 G2 = 0.2; L2 = 0.1     0 0.06988314     0 0.1597663 0.0002337229 0.0009335258 #> 3 G2 = 0.2; L2 = 0.1     0 0.06976628     0 0.1595326 0.0004674457 0.0018643203 #> 4 G2 = 0.2; L2 = 0.1     0 0.06964942     0 0.1592988 0.0007011686 0.0027923835 #> 5 G2 = 0.2; L2 = 0.1     0 0.06953255     0 0.1590651 0.0009348915 0.0037177154 #> 6 G2 = 0.2; L2 = 0.1     0 0.06941569     0 0.1588314 0.0011686144 0.0046403159 #>   treatment150 treatment250    .Pred #> 1            0            1 28.60862 #> 2            0            1 28.62183 #> 3            0            1 28.63497 #> 4            0            1 28.64804 #> 5            0            1 28.66104 #> 6            0            1 28.67397 lwr_lim <- floor(min(cond_tern_template150$.Pred, cond_tern_template250$.Pred)) upr_lim <- ceiling(max(cond_tern_template150$.Pred, cond_tern_template250$.Pred)) conditional_ternary_plot(cond_tern_template150,                          contour_text = FALSE,                          lower_lim = lwr_lim,                          upper_lim = upr_lim) #> ✔ Created plot. conditional_ternary_plot(cond_tern_template250,                          contour_text = FALSE,                          lower_lim = lwr_lim,                          upper_lim = upr_lim) #> ✔ Created plot."},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"grouped-ternary-diagrams","dir":"Articles","previous_headings":"Visualisations","what":"Grouped ternary diagrams","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"grouped_ternary_data() creates function creates template data.frame can passed grouped_ternary_plot() creating grouped ternary diagrams. functionality function similar data-preparation plotting functions conditional ternary diagrams. example, first call grouped_ternary_data() function create template data.frame grouped ternary diagram add predictions later. Additionally, use add_var argument specify want fix treatment 50 250 kg/annum. values can still added later data example conditional ternary section. However, benefit adding using add_var function adds special column data notify plotting function show ternaries separate panels within plot allows us avoid create separate plots two treatment levels. Note: add_var argument available data-preparation functions package.} .add_str_ID column data notifies plotting function wish separate ternaries unique value column. Optionally, can edit values column get informative labels. can now add interaction columns needed making predictions generate predictions using previously highlighted methods. prepared data predictions added can passed grouped_ternary_plot() function generate visualisation. Additionally, also show plot object can updated include best-performing community ternary using geom_point() function ggplot2.  contours appear structure across two treatment levels, predicted yields higher communities receiving 250 kg N/annum. Within given level treatment, predicted yield maximised increasing proportion grasses (G). best performing community treatment level contains 100% grasses functional group. Since FG proportion split equally component species example, best performing community contains 50% G1 G2.","code":"group_tern_data <- grouped_ternary_data(   prediction = FALSE,                         # Do not make predictions now   prop = species,                             # Compositional predictors   FG = FG,                                    # Functional grouping   # Relative split within each FG. Equal split in this example   values = c(0.5, 0.5, 0.5, 0.5, 0.5, 0.5),       # Values for additional non-compsitional predictors   add_var = list(treatment150 = c(0, 0),                        treatment250 = c(0, 1)) ) #> ✔ Finished data preparation. head(group_tern_data) #>   G         L           H          .x .y G1 G2        L1        L2           H1 #> 1 0 1.0000000 0.000000000 0.000000000  0  0  0 0.5000000 0.5000000 0.0000000000 #> 2 0 0.9983306 0.001669449 0.001669449  0  0  0 0.4991653 0.4991653 0.0008347245 #> 3 0 0.9966611 0.003338898 0.003338898  0  0  0 0.4983306 0.4983306 0.0016694491 #> 4 0 0.9949917 0.005008347 0.005008347  0  0  0 0.4974958 0.4974958 0.0025041736 #> 5 0 0.9933222 0.006677796 0.006677796  0  0  0 0.4966611 0.4966611 0.0033388982 #> 6 0 0.9916528 0.008347245 0.008347245  0  0  0 0.4958264 0.4958264 0.0041736227 #>             H2 treatment150 treatment250                        .add_str_ID #> 1 0.0000000000            0            0 treatment150: 0; \\ttreatment250: 0 #> 2 0.0008347245            0            0 treatment150: 0; \\ttreatment250: 0 #> 3 0.0016694491            0            0 treatment150: 0; \\ttreatment250: 0 #> 4 0.0025041736            0            0 treatment150: 0; \\ttreatment250: 0 #> 5 0.0033388982            0            0 treatment150: 0; \\ttreatment250: 0 #> 6 0.0041736227            0            0 treatment150: 0; \\ttreatment250: 0 group_tern_data <- group_tern_data %>%    mutate(.add_str_ID = ifelse(.add_str_ID == \"treatment150: 0; \\ttreatment250: 0\",                               \"Treatment: 50\", \"Treatment: 250\")) # Add interaction columns and the prediction group_tern_data <- group_tern_data %>%    # Add additional interaction columns to data   mutate(wfg_G = G1*G2, wfg_L = L1*L2, wfg_H = H1*H2,          bfg_GL = (G1 + G2) * (L1 + L2),          bfg_GH = (G1 + G2) * (H1 + H2),          bfg_LH = (L1 + L2) * (H1 + H2)) %>%   # Add predictions   add_prediction(model = cust_model)  # Create visualisation group_tern_plot <- grouped_ternary_plot(   data = group_tern_data,   lower_lim = 15,   upper_lim = 40,   nlevels = 5) #> ✔ Created all plots.  # Update plot to highlight the best-performing community in each ternary group_tern_plot +   # Add point highlighting the best performing community in each ternary   geom_point(data = function(x) x %>% filter(.Pred == max(.Pred)),              colour = \"#505050\", shape = 18, size = 4.5) +   # Reduce size of legend so they fit   theme(legend.key.width = unit(0.07, \"npc\"))"},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"simplex-path-plot","dir":"Articles","previous_headings":"Visualisations","what":"Simplex path plot","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"example, simplex-path plots useful visualise effect increasing functional group proportion predicted yield. visualise change predicted yield six-species centroid mixture binary mixtures containing two species functional group. prepare data visualisation using simplex_path_data() function. , first template without predictions prepared predictions added manually adding additional columns needed predictions. Let’s now add interaction terms convert treatments dummy variables. data expanded include following columns * .InterpConst: interpolation constant start end points (0 1). * .Group: identifier creating effects curve. * .Pred: predicted response community. * .Lower: lower interval (α=0.05\\alpha = 0.05 level) predicted response. * .Upper: upper interval (α=0.05\\alpha = 0.05 level) predicted response. Note: mentioned earlier, columns added data model-fitting also added template generated data-preparation functions ensure get accurate predictions. One also add columns directly starts ends data.frames well. However, recommended two reasons. First, using add_var argument notify corresponding plotting function show plots separate panels values specified . Secondly, data-preparation functions might always calculate interaction terms properly added generating template.} prepared data can passed simplex_path_plot() function create visualisation. also demonstrate certain plot aesthetics can modified using arguments simplex_path_plot() function well labs() function ggplot2.  predicted yield every community higher 250 treatment level compared 150 level. level treatment, compared centroid community predicted yield increases sown proportion grasses increases decreases sown proportion legumes herbs increases.","code":"starts <- tribble(~G1, ~G2, ~L1, ~L2, ~H1, ~H2,                   1/6, 1/6, 1/6, 1/6, 1/6, 1/6) ends <- tribble(~G1, ~G2, ~L1, ~L2, ~H1, ~H2,                 1/2, 1/2,   0,   0,   0,  0,                   0,   0, 1/2, 1/2,   0,  0,                   0,   0,   0,   0, 1/2, 1/2)  path_data <- simplex_path_data(   starts = starts,               # Starting compositions   ends = ends,                   # Ending compositions   prop = species,                # Names of compositional predictors   prediction = FALSE,            # Don't make predictions now   # We will visualise the paths at 150 and 250 level of treatment   add_var = list(treatment = c(\"150\", \"250\")) ) #> ✔ Finished data preparation. path_data <- path_data %>%    # Add additional interaction columns to data   mutate(wfg_G = G1*G2, wfg_L = L1*L2, wfg_H = H1*H2,          bfg_GL = (G1 + G2) * (L1 + L2),          bfg_GH = (G1 + G2) * (H1 + H2),          bfg_LH = (L1 + L2) * (H1 + H2)) %>%    # Add dummy variables for treatment   mutate(treatment50 = ifelse(treatment == 50, 1, 0),          treatment150 = ifelse(treatment == 150, 1, 0),          treatment250 = ifelse(treatment == 250, 1, 0)) %>%    # Add predictions and uncertainty around it   add_prediction(model = cust_model, interval = \"confidence\")  head(path_data) #>          G1        G2        L1        L2        H1        H2 .InterpConst #> 1 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667         0.00 #> 2 0.1700000 0.1700000 0.1650000 0.1650000 0.1650000 0.1650000         0.01 #> 3 0.1733333 0.1733333 0.1633333 0.1633333 0.1633333 0.1633333         0.02 #> 4 0.1766667 0.1766667 0.1616667 0.1616667 0.1616667 0.1616667         0.03 #> 5 0.1800000 0.1800000 0.1600000 0.1600000 0.1600000 0.1600000         0.04 #> 6 0.1833333 0.1833333 0.1583333 0.1583333 0.1583333 0.1583333         0.05 #>   .Group treatment    .add_str_ID      wfg_G      wfg_L      wfg_H    bfg_GL #> 1      1       150 treatment: 150 0.02777778 0.02777778 0.02777778 0.1111111 #> 2      1       150 treatment: 150 0.02890000 0.02722500 0.02722500 0.1122000 #> 3      1       150 treatment: 150 0.03004444 0.02667778 0.02667778 0.1132444 #> 4      1       150 treatment: 150 0.03121111 0.02613611 0.02613611 0.1142444 #> 5      1       150 treatment: 150 0.03240000 0.02560000 0.02560000 0.1152000 #> 6      1       150 treatment: 150 0.03361111 0.02506944 0.02506944 0.1161111 #>      bfg_GH    bfg_LH treatment50 treatment150 treatment250    .Pred   .Lower #> 1 0.1111111 0.1111111           0            1            0 30.26202 29.35551 #> 2 0.1122000 0.1089000           0            1            0 30.31401 29.40732 #> 3 0.1132444 0.1067111           0            1            0 30.36600 29.45878 #> 4 0.1142444 0.1045444           0            1            0 30.41800 29.50990 #> 5 0.1152000 0.1024000           0            1            0 30.47000 29.56069 #> 6 0.1161111 0.1002778           0            1            0 30.52201 29.61114 #>     .Upper #> 1 31.16854 #> 2 31.22070 #> 3 31.27322 #> 4 31.32609 #> 5 31.37932 #> 6 31.43289 simplex_path_plot(   data = path_data,       # Data   pie_colours = var_cols, # Colours for the pie-glyphs   pie_radius = 0.35,      # Radius of pie-glyphs   se = TRUE,              # Show confidence band around predictions   # Show pie-glyphs at 0%, 25%, 50%, 75% and 100% along each path   pie_positions = c(0, 0.25, 0.5, 0.75, 1),    nrow = 1, ncol = 2 # Arrange all plots in a 1 row and 2 columns ) +   labs(y = \"Predicted yield\", fill = \"Species\") +   ylim(min(path_data$.Lower), max(path_data$.Upper)) #> ✔ Created all plots. #> Scale for y is already present. #> Adding another scale for y, which will replace the existing scale. #> Scale for y is already present. #> Adding another scale for y, which will replace the existing scale."},{"path":"https://rishvish.github.io/DImodelsVis/articles/DImodelsVis-with-complex-models.html","id":"effect-plots","dir":"Articles","previous_headings":"Visualisations","what":"Effect plots","title":"Using DImodelsVis with regression models not fit using the DImodels package","text":"generating effects plot, just like previous examples, first prepare data visualisation using visualise_effects_data() function. use subset-data used earlier prediction_contributions_data() function included six monocultures, 50-50 mixtures two grasses, legumes herb along six-species centroid mixture receiving 250kg nitrogen treatment. Let’s add interaction terms generate predictions. data expanded include following columns .Sp: variable interest ’s proportion changed. .Proportion: proportion variable interest community. .Group: identifier creating effects curve. .Effect: string describing whether proportion variable interest increased decreased. .Pred: predicted response community. .Lower: lower interval (% confidence level = 0.95 level) predicted response. .Upper: upper interval (% confidence level = 0.95 level) predicted response. prepared data predicted yields can passed visualise_effects_plot() generate effects plot compositional predictor.  average effect increasing proportion species follows quadratic curve (solid black line). average effect increasing sown proportion G1 stronger compared species. species similar performance sown proportion increased. Moreover, increasing sown proportion species besides G1 50% results sharp decline predicted yield.","code":"effects_data <- visualise_effects_data(   data = subset_data,            # Data containing the communities to use for plot   prop = species,                # Names of compositional predictors   var_interest = species,        # Generate effects plot for all species   prediction = FALSE             # Don't make predictions now ) #> ✔ Finished data preparation. effects_data <- effects_data %>%    # Add additional interaction columns to data   mutate(wfg_G = G1*G2, wfg_L = L1*L2, wfg_H = H1*H2,          bfg_GL = (G1 + G2) * (L1 + L2),          bfg_GH = (G1 + G2) * (H1 + H2),          bfg_LH = (L1 + L2) * (H1 + H2)) %>%    # Add predictions   add_prediction(model = cust_model) head(effects_data) #>     G1   G2 L1 L2 H1 H2 richness treatment G L H  wfg_G wfg_L wfg_H bfg_GL #> 1 0.00 1.00  0  0  0  0        1       250 1 0 0 0.0000     0     0      0 #> 2 0.01 0.99  0  0  0  0        1       250 1 0 0 0.0099     0     0      0 #> 3 0.02 0.98  0  0  0  0        1       250 1 0 0 0.0196     0     0      0 #> 4 0.03 0.97  0  0  0  0        1       250 1 0 0 0.0291     0     0      0 #> 5 0.04 0.96  0  0  0  0        1       250 1 0 0 0.0384     0     0      0 #> 6 0.05 0.95  0  0  0  0        1       250 1 0 0 0.0475     0     0      0 #>   bfg_GH bfg_LH treatment50 treatment150 treatment250 response .Sp .Proportion #> 1      0      0           0            0            1   23.644  G1        0.00 #> 2      0      0           0            0            1   23.644  G1        0.01 #> 3      0      0           0            0            1   23.644  G1        0.02 #> 4      0      0           0            0            1   23.644  G1        0.03 #> 5      0      0           0            0            1   23.644  G1        0.04 #> 6      0      0           0            0            1   23.644  G1        0.05 #>   .Group  .Effect    .Pred #> 1      1 increase 22.81348 #> 2      1 increase 23.31846 #> 3      1 increase 23.81527 #> 4      1 increase 24.30390 #> 5      1 increase 24.78435 #> 6      1 increase 25.25663 visualise_effects_plot(   data = effects_data,    # Data   pie_colours = var_cols, # Colours for the pie-glyphs   pie_radius = 0.35       # Radius of pie-glyphs ) +   labs(y = \"Predicted yield\", fill = \"Species\") #> ✔ Created plot."},{"path":"https://rishvish.github.io/DImodelsVis/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rishabh Vishwakarma. Author, maintainer. Caroline Brophy. Author. Laura Byrne. Author. Catherine Hurley. Author.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vishwakarma R, Brophy C, Byrne L, Hurley C (2025). DImodelsVis: Visualising Interpreting Statistical Models Fit Compositional Data. R package version 1.0.2, https://rishvish.github.io/DImodelsVis/.","code":"@Manual{,   title = {DImodelsVis: Visualising and Interpreting Statistical Models Fit to Compositional Data},   author = {Rishabh Vishwakarma and Caroline Brophy and Laura Byrne and Catherine Hurley},   year = {2025},   note = {R package version 1.0.2},   url = {https://rishvish.github.io/DImodelsVis/}, }"},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"dimodelsvis-","dir":"","previous_headings":"","what":"Visualising and Interpreting Statistical Models Fit to Compositional Data","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"Statistical models fit compositional data often difficult interpret due sum one constraint data variables. DImodelsVis provides novel visualisations tools aid interpretation models predictor space compositional nature. visualisations package created using ggplot2 plotting framework can extended like every ggplot object.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"can install released version DImodelsVis CRAN running: can install development version DImodelsVis GitHub :","code":"install.packages(\"DImodelsVis\") # install.packages(\"devtools\") devtools::install_github(\"rishvish/DImodelsVis\")"},{"path":[]},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"introduction-to-diversity-interactions-di-models","dir":"","previous_headings":"Details","what":"Introduction to Diversity-Interactions (DI) models:","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"sometimes interest model compositional data response, times predictors response compositional, rather response . Diversity-Interactions (DI) models (Kirwan et al., 2009, Connolly et al., 2013, Moral et al., 2023) regression based modelling technique analysing interpreting data biodiversity experiments explore effects species diversity different outputs (called ecosystem functions) produced ecosystem. Traditional techniques analysing diversity experiments quantify species diversity terms species richness (.e., number species present community). DI method builds top richness approach taking relative abundances species within community account, thus predictors model compositional nature. DI approach can differentiate among different species identities well communities set species different relative proportions, thereby enabling us better capture relationship diversity ecosystem functions within ecosystem. DImodels DImodelsMulti R packages available aid user fitting models. DImodelsVis (DI models Visualisation) package complimentary package visualising interpreting results models. However, package versatile can used standard statistical model object R predictor space compositional nature.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"package-map","dir":"","previous_headings":"Details","what":"Package Map","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"Package workflow functions package can categorised functions visualising model selection validation functions aid model interpretation. list important visualisation functions present package along short description.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"model-selection-and-validation","dir":"","previous_headings":"Details > Package Map","what":"Model selection and validation","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"model_diagnostics: Create diagnostics plots statistical model additional ability overlay points pie-glyphs showing proportions compositional predictor variables. model_selection: Show visual comparison selection criteria different models. Can also show split information criteria deviance penalty components visualise parsimonious model preferable complex one.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"model-interpretation","dir":"","previous_headings":"Details > Package Map","what":"Model interpretation","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"prediction_contributions: predicted response observations visualised stacked bar-chart showing contributions term regression model. gradient_change: predicted response specific observations shown using pie-glyphs along average change predicted response richness evenness diversity gradients. conditional_ternary: Assuming n compositional variables, fix n-3 variables specific values visualise change predicted response across remaining three variables contour plot ternary diagram. visualise_effects: Visualise effect increasing decreasing predictor variable (set compositional predictor variables) predicted response whilst keeping ratio n-1 compositional predictor variables constant. simplex_path: Visualise change predicted response along straight line two points simplex space.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"other-utility-functions","dir":"","previous_headings":"Details > Package Map","what":"Other utility functions","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"add_prediction: utility function add prediction associated uncertainty data using statistical model object raw model coefficients. get_equi_comms: Utility function create possible combinations equi-proportional communities given level richness set n compositional variables. custom_filter: handy wrapper around dplyr filter() function enabling user filter rows satisfy specific conditions compositional data like equi-proportional communities, communities given value richness without make changes data adding additional columns. prop_to_tern_proj tern_to_prop_proj: Helper functions converting 3-d compositional data 2-d projection. ternary_data ternary_plot: Visualise change predicted response across set three compositional predictor variables contour map within ternary diagram.","code":""},{"path":[]},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"load-libraries","dir":"","previous_headings":"Examples","what":"Load libraries","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"","code":"library(DImodels) library(DImodelsVis)"},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"load-data","dir":"","previous_headings":"Examples","what":"Load data","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"dataset originates grassland biodiversity experiment conducted Switzerland part “Agrodiversity Experiment” Kirwan et al 2014. study, 68 grassland plots consisting 1 4 species established across gradient species diversity. proportions four species varied across plots: plots 100% single species (called monoculture species), 2- 4-species mixtures varying proportions (e.g., (0.5, 0.5, 0, 0) (0.7, 0.1, 0.1, 0.1)). Nitrogen fertilizer (50 150 kg/ha/yr) seeding density (low high) treatments also manipulated across plots. total annual yield per plot recorded first year establishment. data available DImodels R package. analysis dataset can found Kirwan et al., 2009. example consider plots received 150 kg nitrogen treatment. four species proportions form compositional predictors annual yield continuous response.","code":"data(Switzerland) my_data <- Switzerland[Switzerland$nitrogen == 150, ] head(my_data) #>   plot nitrogen density   p1   p2   p3   p4    yield #> 1    1      150    high 0.70 0.10 0.10 0.10 13.51823 #> 2    2      150    high 0.10 0.70 0.10 0.10 13.16549 #> 3    3      150    high 0.10 0.10 0.70 0.10 19.95682 #> 4    4      150    high 0.10 0.10 0.10 0.70 17.93976 #> 5    5      150    high 0.25 0.25 0.25 0.25 13.74719 #> 6    6      150    high 0.40 0.40 0.10 0.10 15.11899"},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"fit-model-with-compositional-data","dir":"","previous_headings":"Examples","what":"Fit model with compositional data","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"fit different models different interaction structures described Moral et al., 2023.","code":"mod_ID <- DI(y = \"yield\", prop = 4:7,               DImodel = \"ID\", data = my_data) #> Fitted model: Species identity 'ID' DImodel mod_AV <- DI(y = \"yield\", prop = 4:7,              DImodel = \"AV\", data = my_data) #> Fitted model: Average interactions 'AV' DImodel mod_FG <- DI(y = \"yield\", prop = 4:7,              DImodel = \"FG\", data = my_data,              FG = c(\"G\", \"G\", \"H\", \"H\")) #> Fitted model: Functional group effects 'FG' DImodel mod_ADD <- DI(y = \"yield\", prop = 4:7,              DImodel = \"ADD\", data = my_data) #> Fitted model: Additive species contributions to interactions 'ADD' DImodel mod_FULL <- DI(y = \"yield\", prop = 4:7,              DImodel = \"FULL\", data = my_data) #> Fitted model: Separate pairwise interactions 'FULL' DImodel"},{"path":[]},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"visualising-model-selection","dir":"","previous_headings":"Examples > Model selection and validation","what":"Visualising model selection","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"can visualise model selection passing models list model_selection function visualising best performing metric across different information criteria. Run ?model_selection see associated vignette information customising plot.  model mod_FG (labelled “FG”) best model lowest value information criteria. proceed model. coefficients follows","code":"mods = list(\"ID\" = mod_ID, \"AV\" = mod_AV, \"FG\" = mod_FG,              \"ADD\" = mod_ADD, \"FULL\" = mod_FULL) model_selection(models = mods, metric = c(\"AIC\", \"AICc\", \"BIC\", \"BICc\")) summary(mod_FG) #>  #> Call: #> glm(formula = fmla, family = family, data = data) #>  #> Coefficients: #>            Estimate Std. Error t value Pr(>|t|)     #> p1_ID        8.5406     0.7627  11.198 2.50e-14 *** #> p2_ID        8.7926     0.7627  11.528 9.70e-15 *** #> p3_ID       16.0825     0.7627  21.086  < 2e-16 *** #> p4_ID       11.9263     0.7627  15.637  < 2e-16 *** #> FG_bfg_G_H  17.3817     2.1713   8.005 4.66e-10 *** #> FG_wfg_G     7.6604     4.4234   1.732   0.0905 .   #> FG_wfg_H     1.0119     4.4234   0.229   0.8201     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for gaussian family taken to be 2.370592) #>  #>     Null deviance: 10290.75  on 50  degrees of freedom #> Residual deviance:   101.94  on 43  degrees of freedom #> AIC: 193.51 #>  #> Number of Fisher Scoring iterations: 2"},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"model-diagnostics","dir":"","previous_headings":"Examples > Model selection and validation","what":"Model diagnostics","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"choosing model can create diagnostics plot points replaced pie-glyphs showing proportions compositional variables. Run ?model_diagnostics see associated vignette information customising plot.  Replacing points pie-glyphs help us quickly identify problematic observations model. example, can see diagnostics plots look fine assumptions seem violated. However, can quickly spot monocultures (communities 1 species) certain communities 2 species high leverage values compared communities data.","code":"model_diagnostics(model = mod_FG) #> ✔ Created all plots."},{"path":[]},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"predictor-contributions-to-predicted-response","dir":"","previous_headings":"Examples > Model interpretation","what":"Predictor contributions to predicted response","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"visualise predicted response specific observations stacked bar-chart showing contribution (predictor coefficient * predictor value) term model.  coloured bars show contributions different terms model. contribution defined product coefficient value predictor variable. Thus, contribution term zero ’s value observation zero regardless ’s coefficient value (e.g. prediction bars monocultures right graph). plot aid understanding certain observations higher predictions. example, can see higher predictions primarily driven p3_ID p4_ID terms hence p1 p2 monocultures low predictions terms value zero . Similarly, can also see mixtures dominated p3 perform best. Run ?prediction_contributions see associated vignette information creating customising plot.","code":"prediction_contributions(model = mod_FG,                           data = my_data[c(1:5, 12:15),]) #> ✔ Finished data preparation. #> ✔ Created plot."},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"average-change-in-respone-over-diversity-gradient","dir":"","previous_headings":"Examples > Model interpretation","what":"Average change in respone over diversity gradient","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"Next show scatterplot predicted response across equi-proportional mixtures level richness (number species community). points replaced pie-glyphs show proportions different species dashed black line shows average change response richness gradient.  shows average predicted response increases richness increases saturating rate. Run ?gradient_change see associated vignette information creating customising plot.","code":"# Create data including all equi-proportional communities at  # each level of richness plot_data <- get_equi_comms(nvars = 4, variables = paste0(\"p\", 1:4)) # Show the average change over richness gradient_change(mod_FG, data = plot_data) #> ✔ Finished data preparation #> ✔ Created plot."},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"conditional-ternary-diagrams","dir":"","previous_headings":"Examples > Model interpretation","what":"Conditional ternary diagrams","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"Ternary diagrams great tool visualising change continuous response, however can created examples three compositional variables. three compositional variables create conditional ternary diagrams fix n-3 compositional variables specific values visualise change predicted response across remaining three variables contour plot ternary diagram. example, since four species can condition one species (say p2) specific values 0.2, 0.5, 0.8 see response affected change proportions three species whilst ensuring sum four species proportions 1.  figure shows predicted response decreases increase proportion p2 maximised increase proportion p3. Run ?conditional_ternary see associated vignette information creating customising plot.","code":"conditional_ternary(model = mod_FG,                      tern_vars = c(\"p1\", \"p3\", \"p4\"),                     conditional = data.frame(\"p2\" = c(0.2, 0.5, 0.8))) #> Preparing data ■■■■■■■■■■■■■■■■■■■■■             67% | ETA:  1s                                                                ✔ Finished data preparation. #> ✔ Created plot."},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"effects-plots-for-models-with-compositional-predictors","dir":"","previous_headings":"Examples > Model interpretation","what":"Effects plots for models with compositional predictors","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"Effects plots great visualising average effect predictor model. However, predictors compositional nature, standard effects plots useful sum 1 constraint. visualise_effects function creates effects plot compositional predictors model ensuring sum one constraint respected increase decrease proportion particular variable. example specify communities using data argument see change predicted response increase proportions species p2 p3in community whilst keeping ratio species constant.  grey lines show effect (predicted response) increasing species interest within particular community solid black line shows average effect increasing proportion species predicted response. can seen communities increasing p2 results decrease predicted response increasing p3 positive effect predicted response. Run ?visualise_effects see associated vignette information creating customising plot.","code":"visualise_effects(model = mod_FG, data = my_data[1:15, ],                   var_interest = c(\"p2\", \"p3\")) #> ✔ Finished data preparation. #> ✔ Created plot."},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"simplex-path","dir":"","previous_headings":"Examples > Model interpretation","what":"Simplex path","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"concept used visualise_effects can extended look change predicted response move straight line two points within simplex space. interpolation constant (shown X-axis) number 0 1 identifying points along straight line start end points. can even traverse path comprising multiple points within simplex see change predicted response. example show change response move centroid mixture monoculture four species.  can see moving centroid community p1, p2, p4 decreases predicted response, moving towards monoculture p3 increases response. Run ?simplex_path see associated vignette information creating customising plot.","code":"simplex_path(model = mod_FG,               starts = my_data[5, ],              ends = my_data[12:15, ]) #> ✔ Finished data preparation. #> ✔ Created plot."},{"path":[]},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"useful-links","dir":"","previous_headings":"See Also","what":"Useful links:","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"DI models website: https://dimodels.com Package website: https://rishvish.github.io/DImodelsVis/ Github repo: https://github.com/rishvish/DImodelsVis Report bugs: https://github.com/rishvish/DImodelsVis/issues","code":""},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"package-family","dir":"","previous_headings":"See Also","what":"Package family:","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"DImodels DImodelsMulti PieGlyph","code":""},{"path":"https://rishvish.github.io/DImodelsVis/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Visualising and Interpreting Statistical Models Fit to Compositional Data","text":"Connolly J, T Bell, T Bolger, C Brophy, T Carnus, JA Finn, L Kirwan, F Isbell, J Levine, Lüscher, V Picasso, C Roscher, MT Sebastia, M Suter Weigelt (2013) improved model predict effects changing biodiversity levels ecosystem function. Journal Ecology, 101, 344-355. Moral, R.., Vishwakarma, R., Connolly, J., Byrne, L., Hurley, C., Finn, J.. Brophy, C., 2023. Going beyond richness: Modelling BEF relationship using species identity, evenness, richness species interactions via DImodels R package. Methods Ecology Evolution, 14(9), pp.2250-2258 Kirwan L., Connolly J., Finn J.., Brophy C., Lüscher ., Nyfeler D. Sebastia M.T. 2009. Diversity-interaction modelling - estimating contributions species identities interactions ecosystem function. Ecology, 90, 2032-2038. Kirwan, L., Connolly, J., Brophy, C., Baadshaug, O.H., Belanger, G., Black, ., Carnus, T., Collins, R.P., Čop, J., Delgado, . De Vliegher, ., 2014. Agrodiversity Experiment: three years data multisite study intensively managed grasslands.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/DImodelsVis-package.html","id":null,"dir":"Reference","previous_headings":"","what":"DImodelsVis: Model interpretation and visualisation for compositional data — DImodelsVis-package","title":"DImodelsVis: Model interpretation and visualisation for compositional data — DImodelsVis-package","text":"Statistical models fit compositional data often difficult interpret due sum one constraint data variables. DImodelsVis provides novel visualisations tools aid interpretation models predictor space compositional nature. visualisations package created using ggplot2 plotting framework can extended like every ggplot object.","code":""},{"path":[]},{"path":"https://rishvish.github.io/DImodelsVis/reference/DImodelsVis-package.html","id":"introduction-to-diversity-interactions-di-models-","dir":"Reference","previous_headings":"","what":"Introduction to Diversity-Interactions (DI) models:","title":"DImodelsVis: Model interpretation and visualisation for compositional data — DImodelsVis-package","text":"sometimes interest model compositional data response, times predictors response compositional, rather response . Diversity-Interactions (DI) models (Kirwan et al., 2009; Connolly et al., 2013; Moral et al., 2023;) regression based modelling technique analysing interpreting data biodiversity experiments explore effects species diversity different outputs (called ecosystem functions) produced ecosystem. Traditional techniques analysing diversity experiments quantify species diversity terms species richness (.e., number species present community). DI method builds top richness approach taking relative abundances species within community account, thus predictors model compositional nature. DI approach can differentiate among different species identities well communities set species different relative proportions, thereby enabling us better capture relationship diversity ecosystem functions within ecosystem. DImodels DImodelsMulti R packages available aid user fitting models. DImodelsVis (DI models Visualisation) package complimentary package visualising interpreting results models. However, package versatile can used standard statistical model object R predictor space compositional nature.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/DImodelsVis-package.html","id":"package-map-","dir":"Reference","previous_headings":"","what":"Package Map:","title":"DImodelsVis: Model interpretation and visualisation for compositional data — DImodelsVis-package","text":"functions package can categorised functions visualising model selection validation functions aid model interpretation. list important visualisation functions present package along short description. Model selection validation model_diagnostics: Create diagnostics plots statistical model additional ability overlay points pie-glyphs showing proportions compositional predictor variables. model_selection: Show visual comparison selection criteria different models. Can also show split information criteria deviance penalty components visualise parsimonious model preferable complex one. Model interpretation prediction_contributions: predicted response observations visualised stacked bar-chart showing contributions term regression model. gradient_change: predicted response specific observations shown using pie-glyphs along average change predicted response richness evenness diversity gradients. conditional_ternary: Assuming n compositional variables, fix n-3 compositional variables specific values visualise change predicted response across remaining three variables contour plot ternary diagram. visualise_effects: Visualise effect increasing decreasing predictor variable (set compositional predictor variables) predicted response whilst keeping ratio n-1 compositional predictor variables constant. simplex_path: Visualise change predicted response along straight line two points simplex space. functions aiding model interpretation corresponding *_data function prepare underlying data *_plot function accepts data creates plot. split data-preparation plotting functions results lot flexibility user. also enables users create visualisations statistical model object R. utility functions add_prediction: utility function add prediction associated uncertainty data using statistical model object raw model coefficients. get_equi_comms: Utility function create possible combinations equi-proportional communities given level richness set n compositional variables. custom_filter: handy wrapper around dplyr filter() function enabling user filter rows satisfy specific conditions compositional data like equi-proportional communities, communities given value richness without make changes data adding additional columns. prop_to_tern_proj tern_to_prop_proj: Helper functions converting 3-d compositional data 2-d projection. ternary_data ternary_plot: Visualise change predicted response across set three compositional predictor variables contour map within ternary diagram.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/DImodelsVis-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"DImodelsVis: Model interpretation and visualisation for compositional data — DImodelsVis-package","text":"Connolly J, T Bell, T Bolger, C Brophy, T Carnus, JA Finn, L Kirwan, F Isbell, J Levine, Lüscher, V Picasso, C Roscher, MT Sebastia, M Suter Weigelt (2013) improved model predict effects changing biodiversity levels ecosystem function. Journal Ecology, 101, 344-355. Moral, R.., Vishwakarma, R., Connolly, J., Byrne, L., Hurley, C., Finn, J.. Brophy, C., 2023. Going beyond richness: Modelling BEF relationship using species identity, evenness, richness species interactions via DImodels R package. Methods Ecology Evolution, 14(9), pp.2250-2258. Kirwan L, J Connolly, JA Finn, C Brophy, Lüscher, D Nyfeler MT Sebastia (2009) Diversity-interaction modelling - estimating contributions species identities interactions ecosystem function. Ecology, 90, 2032-2038.","code":""},{"path":[]},{"path":"https://rishvish.github.io/DImodelsVis/reference/DImodelsVis-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"DImodelsVis: Model interpretation and visualisation for compositional data — DImodelsVis-package","text":"Maintainter: Rishabh Vishwakarma vishwakr@tcd.ie (ORCID) Authors: Caroline Brophy Laura Byrne Catherine Hurley","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/DImodelsVis-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DImodelsVis: Model interpretation and visualisation for compositional data — DImodelsVis-package","text":"","code":"## Load libraries library(DImodels) library(DImodelsVis)  ## Load data data(sim2) sim2 <- sim2[sim2$block == 1, ]  ## Fit model with compositional data mod <- DI(y = \"response\", prop = 3:6,           DImodel = \"AV\", data = sim2) #> Fitted model: Average interactions 'AV' DImodel  ## Model diagnostics plots but points are replaced by ## pie-glyphs showing the proportions of the compositional variables ## See `?model_diagnostics` for more information # \\donttest{ model_diagnostics(model = mod, which = c(1, 2)) #> ✔ Created all plots.  # }  ## Visualise the predicted response variable as contributions ## (predictor coefficient * predictor value) from the individual ## terms in the model ## See `?prediction_contributions` for more information prediction_contributions(model = mod) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Visualise the change in average response over a diversity gradient ## This plot shows the change in the response over a diversity gradient ## We use richness (number of non-zero variables in a given observation) ## as our gradient in this example. The black line shows the average response ## at each level of richness while the position of the pie-glyphs show variations ## about this average whilst also showing the relative abundances of each ## variable in the composition. ## See `?gradient_change` for more information plot_data <- get_equi_comms(nvars = 4, variables = c(\"p1\", \"p2\", \"p3\", \"p4\")) gradient_change(model = mod, data = plot_data) #> ✔ Finished data preparation #> ✔ Created plot.   ## Visualise effects of increasing or decreasing a variable ## within a set of compositional variables ## This plot shows the effect of increasing the proportion of p1 ## in several different initial compositions of the variables ## p1, p2, p3, and p4. Each curve shows the effect of increasing ## the proportion of p1 whilst keeping the relative proportions of ## the other three variables unchanged ## See `?visualise_effects` for more information visualise_effects(model = mod,                   data = sim2[1:11, ],                   var_interest = \"p1\") #> ✔ Finished data preparation. #> ✔ Created plot.   ## Visualise the change in the predicted response along a straight line ## between two points in the simplex space. ## We visualise the change in the response as we from the centroid mixture to ## each of the monocultures ## See `?simplex_path` for more information simplex_path(model = mod,              starts = sim2[5,],              ends = sim2[12:15,]) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Visualise slices of the n-dimensional simplex as ternary diagrams. ## 2-d slices of the n-dimensional simplex are created by conditioning ## certain compositional variables at a specific values `p` while the ## remaining variables are allowed to vary within the range `0` to `1-p`. ## In this example variable p1 is conditioned to have values `0`, `0.2`, and `0.5` ## One ternary diagram is created for each case where p2, p3, and p4 are ## allowed to vary from `0` upto `1`, `0.8`, and `0.5`, respectively. ## This is equivalent to taking multiple slices of the n-dimensional simplex ## and viewing multiple slices would enable us to get a picture the change ## in the response across the n-dimensional simplex. ## For example the response is maximised where p1 is 0.2 ## See `?conditional_ternary` for more information # \\donttest{ conditional_ternary(model = mod, tern_vars = c(\"p2\", \"p3\", \"p4\"),                     conditional = data.frame(\"p1\" = c(0, 0.2, 0.5)),                     contour_text = FALSE,                     resolution = 1) #> ✔ Finished data preparation. #> ✔ Created plot.  # }"},{"path":"https://rishvish.github.io/DImodelsVis/reference/Simplex_projection.html","id":null,"dir":"Reference","previous_headings":"","what":"Project 3-d compositional data onto x-y plane and vice versa — prop_to_tern_proj","title":"Project 3-d compositional data onto x-y plane and vice versa — prop_to_tern_proj","text":"Points 3-d simplex space coordinates (x, y ,z) x + y + z = 1 projected 2-d plane reside . function can used convert 3-d compositional data 2-d overlayed plots output ternary_plot, conditional_ternary_plot grouped_ternary_plot.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/Simplex_projection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project 3-d compositional data onto x-y plane and vice versa — prop_to_tern_proj","text":"","code":"prop_to_tern_proj(data, prop, x = \".x\", y = \".y\")  tern_to_prop_proj(data, x, y, prop = c(\"p1\", \"p2\", \"p3\"))"},{"path":"https://rishvish.github.io/DImodelsVis/reference/Simplex_projection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project 3-d compositional data onto x-y plane and vice versa — prop_to_tern_proj","text":"data data-frame containing x-y coordinates points. prop character vector specifying columns names variable containing projected compositions. Default \"p1\", \"p2\", \"p3\". x character string specifying name column containing x component x-y projection simplex. y character string specifying name column containing y component x-y projection simplex.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/Simplex_projection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project 3-d compositional data onto x-y plane and vice versa — prop_to_tern_proj","text":"data-frame following two columns appended (transforming x-y projection) .x (value specified \"x\") x component x-y projection simplex point. .y (value specified \"y\") y component x-y projection simplex point. data-frame following three columns appended (transforming compositional projection) p1 (first value specified \"prop\") first component 3-d simplex point. p2 (second value specified \"prop\") second component 3-d simplex point. p3 (third value specified \"prop\") third component 3-d simplex point.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/Simplex_projection.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project 3-d compositional data onto x-y plane and vice versa — prop_to_tern_proj","text":"","code":"## Convert proportions to x-y co-ordinates library(DImodels) data(sim0) sim0 <- sim0[1:16, ]  prop_to_tern_proj(data = sim0, prop = c(\"p1\", \"p2\", \"p3\")) #>           p1        p2        p3   .x        .y community richness response #> 1  1.0000000 0.0000000 0.0000000 0.50 0.8660254         1        1   24.855 #> 2  0.0000000 1.0000000 0.0000000 0.00 0.0000000         2        1   19.049 #> 3  0.0000000 0.0000000 1.0000000 1.00 0.0000000         3        1   16.292 #> 4  0.8000000 0.2000000 0.0000000 0.40 0.6928203         4        2   31.529 #> 5  0.2000000 0.8000000 0.0000000 0.10 0.1732051         5        2   25.102 #> 6  0.8000000 0.0000000 0.2000000 0.60 0.6928203         6        2   24.615 #> 7  0.2000000 0.0000000 0.8000000 0.90 0.1732051         7        2   18.654 #> 8  0.0000000 0.8000000 0.2000000 0.20 0.0000000         8        2   24.697 #> 9  0.0000000 0.2000000 0.8000000 0.80 0.0000000         9        2   25.017 #> 10 0.5000000 0.5000000 0.0000000 0.25 0.4330127        10        2   32.743 #> 11 0.5000000 0.0000000 0.5000000 0.75 0.4330127        11        2   25.320 #> 12 0.0000000 0.5000000 0.5000000 0.50 0.0000000        12        2   30.214 #> 13 0.6000000 0.2000000 0.2000000 0.50 0.5196152        13        3   30.511 #> 14 0.2000000 0.6000000 0.2000000 0.30 0.1732051        14        3   31.005 #> 15 0.2000000 0.2000000 0.6000000 0.70 0.1732051        15        3   28.964 #> 16 0.3333333 0.3333333 0.3333333 0.50 0.2886751        16        3   32.091  # Change names of the x and y projections prop_to_tern_proj(data = sim0, prop = c(\"p1\", \"p2\", \"p3\"),                   x = \"x-proj\", y = \"y-proj\") #>           p1        p2        p3 x-proj    y-proj community richness response #> 1  1.0000000 0.0000000 0.0000000   0.50 0.8660254         1        1   24.855 #> 2  0.0000000 1.0000000 0.0000000   0.00 0.0000000         2        1   19.049 #> 3  0.0000000 0.0000000 1.0000000   1.00 0.0000000         3        1   16.292 #> 4  0.8000000 0.2000000 0.0000000   0.40 0.6928203         4        2   31.529 #> 5  0.2000000 0.8000000 0.0000000   0.10 0.1732051         5        2   25.102 #> 6  0.8000000 0.0000000 0.2000000   0.60 0.6928203         6        2   24.615 #> 7  0.2000000 0.0000000 0.8000000   0.90 0.1732051         7        2   18.654 #> 8  0.0000000 0.8000000 0.2000000   0.20 0.0000000         8        2   24.697 #> 9  0.0000000 0.2000000 0.8000000   0.80 0.0000000         9        2   25.017 #> 10 0.5000000 0.5000000 0.0000000   0.25 0.4330127        10        2   32.743 #> 11 0.5000000 0.0000000 0.5000000   0.75 0.4330127        11        2   25.320 #> 12 0.0000000 0.5000000 0.5000000   0.50 0.0000000        12        2   30.214 #> 13 0.6000000 0.2000000 0.2000000   0.50 0.5196152        13        3   30.511 #> 14 0.2000000 0.6000000 0.2000000   0.30 0.1732051        14        3   31.005 #> 15 0.2000000 0.2000000 0.6000000   0.70 0.1732051        15        3   28.964 #> 16 0.3333333 0.3333333 0.3333333   0.50 0.2886751        16        3   32.091 ## Convert x-y co-ordinates to proportions library(DImodels) data(sim0) sim0 <- sim0[1:16, ]  proj_data <- prop_to_tern_proj(data = sim0, prop = c(\"p1\", \"p2\", \"p3\"))  tern_to_prop_proj(data = proj_data, x = \".x\", y = \".y\") #>      .x        .y        p1        p2        p3 community richness response #> 1  0.50 0.8660254 1.0000000 0.0000000 0.0000000         1        1   24.855 #> 2  0.00 0.0000000 0.0000000 1.0000000 0.0000000         2        1   19.049 #> 3  1.00 0.0000000 0.0000000 0.0000000 1.0000000         3        1   16.292 #> 4  0.40 0.6928203 0.8000000 0.2000000 0.0000000         4        2   31.529 #> 5  0.10 0.1732051 0.2000000 0.8000000 0.0000000         5        2   25.102 #> 6  0.60 0.6928203 0.8000000 0.0000000 0.2000000         6        2   24.615 #> 7  0.90 0.1732051 0.2000000 0.0000000 0.8000000         7        2   18.654 #> 8  0.20 0.0000000 0.0000000 0.8000000 0.2000000         8        2   24.697 #> 9  0.80 0.0000000 0.0000000 0.2000000 0.8000000         9        2   25.017 #> 10 0.25 0.4330127 0.5000000 0.5000000 0.0000000        10        2   32.743 #> 11 0.75 0.4330127 0.5000000 0.0000000 0.5000000        11        2   25.320 #> 12 0.50 0.0000000 0.0000000 0.5000000 0.5000000        12        2   30.214 #> 13 0.50 0.5196152 0.6000000 0.2000000 0.2000000        13        3   30.511 #> 14 0.30 0.1732051 0.2000000 0.6000000 0.2000000        14        3   31.005 #> 15 0.70 0.1732051 0.2000000 0.2000000 0.6000000        15        3   28.964 #> 16 0.50 0.2886751 0.3333333 0.3333333 0.3333333        16        3   32.091  # Change prop names tern_to_prop_proj(data = proj_data, x = \".x\", y = \".y\",                   prop = c(\"prop1\", \"prop2\", \"prop3\")) #>      .x        .y     prop1     prop2     prop3        p1        p2        p3 #> 1  0.50 0.8660254 1.0000000 0.0000000 0.0000000 1.0000000 0.0000000 0.0000000 #> 2  0.00 0.0000000 0.0000000 1.0000000 0.0000000 0.0000000 1.0000000 0.0000000 #> 3  1.00 0.0000000 0.0000000 0.0000000 1.0000000 0.0000000 0.0000000 1.0000000 #> 4  0.40 0.6928203 0.8000000 0.2000000 0.0000000 0.8000000 0.2000000 0.0000000 #> 5  0.10 0.1732051 0.2000000 0.8000000 0.0000000 0.2000000 0.8000000 0.0000000 #> 6  0.60 0.6928203 0.8000000 0.0000000 0.2000000 0.8000000 0.0000000 0.2000000 #> 7  0.90 0.1732051 0.2000000 0.0000000 0.8000000 0.2000000 0.0000000 0.8000000 #> 8  0.20 0.0000000 0.0000000 0.8000000 0.2000000 0.0000000 0.8000000 0.2000000 #> 9  0.80 0.0000000 0.0000000 0.2000000 0.8000000 0.0000000 0.2000000 0.8000000 #> 10 0.25 0.4330127 0.5000000 0.5000000 0.0000000 0.5000000 0.5000000 0.0000000 #> 11 0.75 0.4330127 0.5000000 0.0000000 0.5000000 0.5000000 0.0000000 0.5000000 #> 12 0.50 0.0000000 0.0000000 0.5000000 0.5000000 0.0000000 0.5000000 0.5000000 #> 13 0.50 0.5196152 0.6000000 0.2000000 0.2000000 0.6000000 0.2000000 0.2000000 #> 14 0.30 0.1732051 0.2000000 0.6000000 0.2000000 0.2000000 0.6000000 0.2000000 #> 15 0.70 0.1732051 0.2000000 0.2000000 0.6000000 0.2000000 0.2000000 0.6000000 #> 16 0.50 0.2886751 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 #>    community richness response #> 1          1        1   24.855 #> 2          2        1   19.049 #> 3          3        1   16.292 #> 4          4        2   31.529 #> 5          5        2   25.102 #> 6          6        2   24.615 #> 7          7        2   18.654 #> 8          8        2   24.697 #> 9          9        2   25.017 #> 10        10        2   32.743 #> 11        11        2   25.320 #> 12        12        2   30.214 #> 13        13        3   30.511 #> 14        14        3   31.005 #> 15        15        3   28.964 #> 16        16        3   32.091"},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_ID_terms.html","id":null,"dir":"Reference","previous_headings":"","what":"Add identity effect groups used in a Diversity-Interactions (DI) model to new data — add_ID_terms","title":"Add identity effect groups used in a Diversity-Interactions (DI) model to new data — add_ID_terms","text":"Utility function accepts fitted Diversity-Interactions (DI) model object along data frame adds appropriate species identity effect groupings data making predictions.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_ID_terms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add identity effect groups used in a Diversity-Interactions (DI) model to new data — add_ID_terms","text":"","code":"add_ID_terms(data, model)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_ID_terms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add identity effect groups used in a Diversity-Interactions (DI) model to new data — add_ID_terms","text":"data data-frame species proportions sum 1 create identity effect groupings. model Diversity Interactions model object fit using DI() autoDI() functions DImodels DImulti() DImodelsMulti R packages.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_ID_terms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add identity effect groups used in a Diversity-Interactions (DI) model to new data — add_ID_terms","text":"data-frame additional columns appended end contain grouped species proportions.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_ID_terms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add identity effect groups used in a Diversity-Interactions (DI) model to new data — add_ID_terms","text":"","code":"library(DImodels) data(sim1)  # Fit DI models with different ID effect groupings mod1 <- DI(y = \"response\", prop = 3:6,            data = sim1, DImodel = \"AV\") # No ID grouping #> Fitted model: Average interactions 'AV' DImodel mod2 <- DI(y = \"response\", prop = 3:6,            data = sim1, DImodel = \"AV\",            ID = c(\"ID1\", \"ID1\", \"ID2\", \"ID2\")) #> Fitted model: Average interactions 'AV' DImodel mod3 <- DI(y = \"response\", prop = 3:6,            data = sim1, DImodel = \"AV\",            ID = c(\"ID1\", \"ID1\", \"ID1\", \"ID1\")) #> Fitted model: Average interactions 'AV' DImodel  # Create new data for adding interaction terms newdata <- sim1[sim1$block == 1, 3:6] print(head(newdata)) #>      p1   p2   p3   p4 #> 1  0.70 0.10 0.10 0.10 #> 5  0.10 0.70 0.10 0.10 #> 9  0.10 0.10 0.70 0.10 #> 13 0.10 0.10 0.10 0.70 #> 17 0.25 0.25 0.25 0.25 #> 21 0.40 0.40 0.10 0.10  add_ID_terms(data = newdata, model = mod1) #>      p1   p2   p3   p4 p1_ID p2_ID p3_ID p4_ID #> 1  0.70 0.10 0.10 0.10  0.70  0.10  0.10  0.10 #> 5  0.10 0.70 0.10 0.10  0.10  0.70  0.10  0.10 #> 9  0.10 0.10 0.70 0.10  0.10  0.10  0.70  0.10 #> 13 0.10 0.10 0.10 0.70  0.10  0.10  0.10  0.70 #> 17 0.25 0.25 0.25 0.25  0.25  0.25  0.25  0.25 #> 21 0.40 0.40 0.10 0.10  0.40  0.40  0.10  0.10 #> 25 0.40 0.10 0.40 0.10  0.40  0.10  0.40  0.10 #> 29 0.40 0.10 0.10 0.40  0.40  0.10  0.10  0.40 #> 33 0.10 0.40 0.40 0.10  0.10  0.40  0.40  0.10 #> 37 0.10 0.40 0.10 0.40  0.10  0.40  0.10  0.40 #> 41 0.10 0.10 0.40 0.40  0.10  0.10  0.40  0.40 #> 45 1.00 0.00 0.00 0.00  1.00  0.00  0.00  0.00 #> 49 0.00 1.00 0.00 0.00  0.00  1.00  0.00  0.00 #> 53 0.00 0.00 1.00 0.00  0.00  0.00  1.00  0.00 #> 57 0.00 0.00 0.00 1.00  0.00  0.00  0.00  1.00 add_ID_terms(data = newdata, model = mod2) #>      p1   p2   p3   p4 ID1 ID2 #> 1  0.70 0.10 0.10 0.10 0.8 0.2 #> 5  0.10 0.70 0.10 0.10 0.8 0.2 #> 9  0.10 0.10 0.70 0.10 0.2 0.8 #> 13 0.10 0.10 0.10 0.70 0.2 0.8 #> 17 0.25 0.25 0.25 0.25 0.5 0.5 #> 21 0.40 0.40 0.10 0.10 0.8 0.2 #> 25 0.40 0.10 0.40 0.10 0.5 0.5 #> 29 0.40 0.10 0.10 0.40 0.5 0.5 #> 33 0.10 0.40 0.40 0.10 0.5 0.5 #> 37 0.10 0.40 0.10 0.40 0.5 0.5 #> 41 0.10 0.10 0.40 0.40 0.2 0.8 #> 45 1.00 0.00 0.00 0.00 1.0 0.0 #> 49 0.00 1.00 0.00 0.00 1.0 0.0 #> 53 0.00 0.00 1.00 0.00 0.0 1.0 #> 57 0.00 0.00 0.00 1.00 0.0 1.0 add_ID_terms(data = newdata, model = mod3) #>      p1   p2   p3   p4 ID1 #> 1  0.70 0.10 0.10 0.10   1 #> 5  0.10 0.70 0.10 0.10   1 #> 9  0.10 0.10 0.70 0.10   1 #> 13 0.10 0.10 0.10 0.70   1 #> 17 0.25 0.25 0.25 0.25   1 #> 21 0.40 0.40 0.10 0.10   1 #> 25 0.40 0.10 0.40 0.10   1 #> 29 0.40 0.10 0.10 0.40   1 #> 33 0.10 0.40 0.40 0.10   1 #> 37 0.10 0.40 0.10 0.40   1 #> 41 0.10 0.10 0.40 0.40   1 #> 45 1.00 0.00 0.00 0.00   1 #> 49 0.00 1.00 0.00 0.00   1 #> 53 0.00 0.00 1.00 0.00   1 #> 57 0.00 0.00 0.00 1.00   1"},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_add_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Add additional variables to the data — add_add_var","title":"Add additional variables to the data — add_add_var","text":"Utility function incorporating additional variables data. row data replicated new columns added variable specified `add_var` values corresponding cartesian product.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_add_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add additional variables to the data — add_add_var","text":"","code":"add_add_var(data, add_var = NULL)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_add_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add additional variables to the data — add_add_var","text":"data data frame containing data add additional variables. add_var named list data-frame specifying names corresponding values new variable add data. list specified, row data replicated unique combination values specified variables (.e., cartesian product) `add_var`, specifying data-frame replicate row data row add_var (.e., merge two data-frames).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_add_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add additional variables to the data — add_add_var","text":"data-frame additional columns specified `add_var`         following additional column. .add_str_ID unique identifier describing element                       cartesian product variables specified `add_var`.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_add_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add additional variables to the data — add_add_var","text":"","code":"test_data <- data.frame(diag(1, 3)) print(test_data) #>   X1 X2 X3 #> 1  1  0  0 #> 2  0  1  0 #> 3  0  0  1  ## Adding a single variable add_add_var(data = test_data,             add_var = list(\"Var1\" = c(10, 20))) #>   X1 X2 X3 Var1 .add_str_ID #> 1  1  0  0   10    Var1: 10 #> 2  0  1  0   10    Var1: 10 #> 3  0  0  1   10    Var1: 10 #> 4  1  0  0   20    Var1: 20 #> 5  0  1  0   20    Var1: 20 #> 6  0  0  1   20    Var1: 20  ## Specifying multiple variables as a list will add values for ##  each unique combination add_add_var(data = test_data,             add_var = list(\"Var1\" = c(10, 20),                            \"Var2\" = c(30, 40))) #>    X1 X2 X3 Var1 Var2          .add_str_ID #> 1   1  0  0   10   30 Var1: 10; \\tVar2: 30 #> 2   0  1  0   10   30 Var1: 10; \\tVar2: 30 #> 3   0  0  1   10   30 Var1: 10; \\tVar2: 30 #> 4   1  0  0   20   30 Var1: 20; \\tVar2: 30 #> 5   0  1  0   20   30 Var1: 20; \\tVar2: 30 #> 6   0  0  1   20   30 Var1: 20; \\tVar2: 30 #> 7   1  0  0   10   40 Var1: 10; \\tVar2: 40 #> 8   0  1  0   10   40 Var1: 10; \\tVar2: 40 #> 9   0  0  1   10   40 Var1: 10; \\tVar2: 40 #> 10  1  0  0   20   40 Var1: 20; \\tVar2: 40 #> 11  0  1  0   20   40 Var1: 20; \\tVar2: 40 #> 12  0  0  1   20   40 Var1: 20; \\tVar2: 40  ## Specifying add_var as a data.frame would simply merge the two data-frames add_add_var(data = test_data,             add_var = data.frame(\"Var1\" = c(10, 20),                                  \"Var2\" = c(30, 40))) #>   X1 X2 X3 Var1 Var2          .add_str_ID #> 1  1  0  0   10   30 Var1: 10; \\tVar2: 30 #> 2  0  1  0   10   30 Var1: 10; \\tVar2: 30 #> 3  0  0  1   10   30 Var1: 10; \\tVar2: 30 #> 4  1  0  0   20   40 Var1: 20; \\tVar2: 40 #> 5  0  1  0   20   40 Var1: 20; \\tVar2: 40 #> 6  0  0  1   20   40 Var1: 20; \\tVar2: 40  ## If the list specified in `add_var` is not named, then the additional ## variables will be automatically named Var1, Var2, Var3, etc. add_add_var(data = test_data,             add_var = list(c(1, 2), c(3, 4))) #>    X1 X2 X3 Var1 Var2        .add_str_ID #> 1   1  0  0    1    3 Var1: 1; \\tVar2: 3 #> 2   0  1  0    1    3 Var1: 1; \\tVar2: 3 #> 3   0  0  1    1    3 Var1: 1; \\tVar2: 3 #> 4   1  0  0    2    3 Var1: 2; \\tVar2: 3 #> 5   0  1  0    2    3 Var1: 2; \\tVar2: 3 #> 6   0  0  1    2    3 Var1: 2; \\tVar2: 3 #> 7   1  0  0    1    4 Var1: 1; \\tVar2: 4 #> 8   0  1  0    1    4 Var1: 1; \\tVar2: 4 #> 9   0  0  1    1    4 Var1: 1; \\tVar2: 4 #> 10  1  0  0    2    4 Var1: 2; \\tVar2: 4 #> 11  0  1  0    2    4 Var1: 2; \\tVar2: 4 #> 12  0  0  1    2    4 Var1: 2; \\tVar2: 4"},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_interaction_terms.html","id":null,"dir":"Reference","previous_headings":"","what":"Add interaction terms used in a Diversity-Interactions (DI) model to new data — add_interaction_terms","title":"Add interaction terms used in a Diversity-Interactions (DI) model to new data — add_interaction_terms","text":"Utility function accepts fitted Diversity-Interactions (DI) model object along data frame adds necessary interaction structures data making predictions using model object specified `model`.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_interaction_terms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add interaction terms used in a Diversity-Interactions (DI) model to new data — add_interaction_terms","text":"","code":"add_interaction_terms(data, model)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_interaction_terms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add interaction terms used in a Diversity-Interactions (DI) model to new data — add_interaction_terms","text":"data data-frame species proportions sum 1 create appropriate interaction structures. model Diversity Interactions model object fit using DI() autoDI() functions DImodels DImulti() DImodelsMulti R packages.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_interaction_terms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add interaction terms used in a Diversity-Interactions (DI) model to new data — add_interaction_terms","text":"original data-frame additional columns appended end describing interactions terms present model object.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_interaction_terms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add interaction terms used in a Diversity-Interactions (DI) model to new data — add_interaction_terms","text":"","code":"library(DImodels) data(sim1)  # Fit different DI models mod1 <- DI(y = \"response\", prop = 3:6, data = sim1, DImodel = \"AV\") #> Fitted model: Average interactions 'AV' DImodel mod2 <- DI(y = \"response\", prop = 3:6, data = sim1, DImodel = \"FULL\") #> Fitted model: Separate pairwise interactions 'FULL' DImodel mod3 <- DI(y = \"response\", prop = 3:6, data = sim1, DImodel = \"ADD\") #> Fitted model: Additive species contributions to interactions 'ADD' DImodel mod4 <- DI(y = \"response\", prop = 3:6, data = sim1,            FG = c(\"G\", \"G\", \"H\", \"H\"), DImodel = \"FG\") #> Fitted model: Functional group effects 'FG' DImodel  # Create new data for adding interaction terms newdata <- sim1[sim1$block == 1, 3:6] print(head(newdata)) #>      p1   p2   p3   p4 #> 1  0.70 0.10 0.10 0.10 #> 5  0.10 0.70 0.10 0.10 #> 9  0.10 0.10 0.70 0.10 #> 13 0.10 0.10 0.10 0.70 #> 17 0.25 0.25 0.25 0.25 #> 21 0.40 0.40 0.10 0.10  add_interaction_terms(data = newdata, model = mod1) #>      p1   p2   p3   p4    AV #> 1  0.70 0.10 0.10 0.10 0.240 #> 5  0.10 0.70 0.10 0.10 0.240 #> 9  0.10 0.10 0.70 0.10 0.240 #> 13 0.10 0.10 0.10 0.70 0.240 #> 17 0.25 0.25 0.25 0.25 0.375 #> 21 0.40 0.40 0.10 0.10 0.330 #> 25 0.40 0.10 0.40 0.10 0.330 #> 29 0.40 0.10 0.10 0.40 0.330 #> 33 0.10 0.40 0.40 0.10 0.330 #> 37 0.10 0.40 0.10 0.40 0.330 #> 41 0.10 0.10 0.40 0.40 0.330 #> 45 1.00 0.00 0.00 0.00 0.000 #> 49 0.00 1.00 0.00 0.00 0.000 #> 53 0.00 0.00 1.00 0.00 0.000 #> 57 0.00 0.00 0.00 1.00 0.000 add_interaction_terms(data = newdata, model = mod2) #>      p1   p2   p3   p4  p1:p2  p1:p3  p1:p4  p2:p3  p2:p4  p3:p4 #> 1  0.70 0.10 0.10 0.10 0.0700 0.0700 0.0700 0.0100 0.0100 0.0100 #> 5  0.10 0.70 0.10 0.10 0.0700 0.0100 0.0100 0.0700 0.0700 0.0100 #> 9  0.10 0.10 0.70 0.10 0.0100 0.0700 0.0100 0.0700 0.0100 0.0700 #> 13 0.10 0.10 0.10 0.70 0.0100 0.0100 0.0700 0.0100 0.0700 0.0700 #> 17 0.25 0.25 0.25 0.25 0.0625 0.0625 0.0625 0.0625 0.0625 0.0625 #> 21 0.40 0.40 0.10 0.10 0.1600 0.0400 0.0400 0.0400 0.0400 0.0100 #> 25 0.40 0.10 0.40 0.10 0.0400 0.1600 0.0400 0.0400 0.0100 0.0400 #> 29 0.40 0.10 0.10 0.40 0.0400 0.0400 0.1600 0.0100 0.0400 0.0400 #> 33 0.10 0.40 0.40 0.10 0.0400 0.0400 0.0100 0.1600 0.0400 0.0400 #> 37 0.10 0.40 0.10 0.40 0.0400 0.0100 0.0400 0.0400 0.1600 0.0400 #> 41 0.10 0.10 0.40 0.40 0.0100 0.0400 0.0400 0.0400 0.0400 0.1600 #> 45 1.00 0.00 0.00 0.00 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 #> 49 0.00 1.00 0.00 0.00 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 #> 53 0.00 0.00 1.00 0.00 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 #> 57 0.00 0.00 0.00 1.00 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 add_interaction_terms(data = newdata, model = mod3) #>      p1   p2   p3   p4 p1_add p2_add p3_add p4_add #> 1  0.70 0.10 0.10 0.10 0.2100 0.0900 0.0900 0.0900 #> 5  0.10 0.70 0.10 0.10 0.0900 0.2100 0.0900 0.0900 #> 9  0.10 0.10 0.70 0.10 0.0900 0.0900 0.2100 0.0900 #> 13 0.10 0.10 0.10 0.70 0.0900 0.0900 0.0900 0.2100 #> 17 0.25 0.25 0.25 0.25 0.1875 0.1875 0.1875 0.1875 #> 21 0.40 0.40 0.10 0.10 0.2400 0.2400 0.0900 0.0900 #> 25 0.40 0.10 0.40 0.10 0.2400 0.0900 0.2400 0.0900 #> 29 0.40 0.10 0.10 0.40 0.2400 0.0900 0.0900 0.2400 #> 33 0.10 0.40 0.40 0.10 0.0900 0.2400 0.2400 0.0900 #> 37 0.10 0.40 0.10 0.40 0.0900 0.2400 0.0900 0.2400 #> 41 0.10 0.10 0.40 0.40 0.0900 0.0900 0.2400 0.2400 #> 45 1.00 0.00 0.00 0.00 0.0000 0.0000 0.0000 0.0000 #> 49 0.00 1.00 0.00 0.00 0.0000 0.0000 0.0000 0.0000 #> 53 0.00 0.00 1.00 0.00 0.0000 0.0000 0.0000 0.0000 #> 57 0.00 0.00 0.00 1.00 0.0000 0.0000 0.0000 0.0000 add_interaction_terms(data = newdata, model = mod4) #>      p1   p2   p3   p4 FG_.bfg_G_H FG_.wfg_G FG_.wfg_H #> 1  0.70 0.10 0.10 0.10      0.1600    0.0700    0.0100 #> 5  0.10 0.70 0.10 0.10      0.1600    0.0700    0.0100 #> 9  0.10 0.10 0.70 0.10      0.1600    0.0100    0.0700 #> 13 0.10 0.10 0.10 0.70      0.1600    0.0100    0.0700 #> 17 0.25 0.25 0.25 0.25      0.2500    0.0625    0.0625 #> 21 0.40 0.40 0.10 0.10      0.1600    0.1600    0.0100 #> 25 0.40 0.10 0.40 0.10      0.2500    0.0400    0.0400 #> 29 0.40 0.10 0.10 0.40      0.2500    0.0400    0.0400 #> 33 0.10 0.40 0.40 0.10      0.2500    0.0400    0.0400 #> 37 0.10 0.40 0.10 0.40      0.2500    0.0400    0.0400 #> 41 0.10 0.10 0.40 0.40      0.1600    0.0100    0.1600 #> 45 1.00 0.00 0.00 0.00      0.0000    0.0000    0.0000 #> 49 0.00 1.00 0.00 0.00      0.0000    0.0000    0.0000 #> 53 0.00 0.00 1.00 0.00      0.0000    0.0000    0.0000 #> 57 0.00 0.00 0.00 1.00      0.0000    0.0000    0.0000"},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Add predictions and confidence interval to data using either a model object or model coefficients. — add_prediction","title":"Add predictions and confidence interval to data using either a model object or model coefficients. — add_prediction","text":"function accepts data.frame either model object coefficients adds columns containing predictions associated uncertainty data. model object specified, function uses get_predicted() insight package hood generate predictions.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add predictions and confidence interval to data using either a model object or model coefficients. — add_prediction","text":"","code":"add_prediction(   data,   model = NULL,   coefficients = NULL,   coeff_cols = NULL,   vcov = NULL,   interval = c(\"none\", \"confidence\", \"prediction\"),   conf.level = 0.95 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add predictions and confidence interval to data using either a model object or model coefficients. — add_prediction","text":"data data-frame containing appropriate values terms model. model regression model object used make predictions observations `data`. override `coefficients` specified. coefficients regression model available (fit R), regression coefficients model fit language can used calculate predictions. However, user ensure appropriate one--one positional mapping data columns coefficient values. , also provide variance-covariance matrix coefficients `vcov` parameter want associated CI prediction possible calculate confidence/prediction intervals using method. coeff_cols `coefficients` specified one--one positional mapping data-columns coefficient vector present. character string numeric index can specified reorder data columns match corresponding coefficient value respective data column. See \"Use model coefficients prediction\" section examples. vcov regression coefficients specified, variance-covariance matrix coefficients can specified calculate associated confidence interval around prediction. Failure result confidence intervals returned. Ensure `coefficients` `vcov` positional mapping data. interval Type interval calculate: \"none\" (default) interval calculated. \"confidence\" Calculate confidence interval. \"prediction\" Calculate prediction interval. conf.level confidence level calculating confidence/prediction intervals. Default 0.95.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_prediction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add predictions and confidence interval to data using either a model object or model coefficients. — add_prediction","text":"data-frame following additional columns .Pred predicted response observation. .Lower lower limit confidence/prediction interval                  observation (\".Pred\" using                  `coefficients` `vcov` specified). .Upper lower limit confidence/prediction interval                  observation (\".Pred\" using                  `coefficients` `vcov` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/add_prediction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add predictions and confidence interval to data using either a model object or model coefficients. — add_prediction","text":"","code":"library(DImodels) data(sim1)  # Fit a model mod <- lm(response ~ 0 + p1 + p2 + p3 + p4 + p1:p2 + p3:p4, data = sim1)  # Create new data for adding predictions newdata <- head(sim1[sim1$block == 1,]) print(newdata) #>    community block   p1   p2   p3   p4 response #> 1          1     1 0.70 0.10 0.10 0.10   10.815 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 #> 9          3     1 0.10 0.10 0.70 0.10   11.135 #> 13         4     1 0.10 0.10 0.10 0.70    9.916 #> 17         5     1 0.25 0.25 0.25 0.25   11.374 #> 21         6     1 0.40 0.40 0.10 0.10   12.492  # Add predictions to data add_prediction(data = newdata, model = mod) #>    community block   p1   p2   p3   p4 response     .Pred #> 1          1     1 0.70 0.10 0.10 0.10   10.815 10.466907 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 10.253858 #> 9          3     1 0.10 0.10 0.70 0.10   11.135  9.615319 #> 13         4     1 0.10 0.10 0.10 0.70    9.916  8.584323 #> 17         5     1 0.25 0.25 0.25 0.25   11.374  9.795128 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 10.601405  # Adding predictions to data with confidence interval add_prediction(data = newdata, model = mod, interval = \"confidence\") #>    community block   p1   p2   p3   p4 response     .Pred   .Lower    .Upper #> 1          1     1 0.70 0.10 0.10 0.10   10.815 10.466907 9.798148 11.135666 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 10.253858 9.585100 10.922617 #> 9          3     1 0.10 0.10 0.70 0.10   11.135  9.615319 8.946561 10.284078 #> 13         4     1 0.10 0.10 0.10 0.70    9.916  8.584323 7.915564  9.253081 #> 17         5     1 0.25 0.25 0.25 0.25   11.374  9.795128 9.328378 10.261878 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 10.601405 9.531207 11.671603  # Calculate prediction intervals instead add_prediction(data = newdata, model = mod, interval = \"prediction\") #>    community block   p1   p2   p3   p4 response     .Pred   .Lower   .Upper #> 1          1     1 0.70 0.10 0.10 0.10   10.815 10.466907 7.769709 13.16410 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 10.253858 7.556661 12.95106 #> 9          3     1 0.10 0.10 0.70 0.10   11.135  9.615319 6.918122 12.31252 #> 13         4     1 0.10 0.10 0.10 0.70    9.916  8.584323 5.887125 11.28152 #> 17         5     1 0.25 0.25 0.25 0.25   11.374  9.795128 7.140794 12.44946 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 10.601405 7.777762 13.42505  # Default is a 95% interval, change to 99% add_prediction(data = newdata, model = mod, interval = \"prediction\",                conf.level = 0.99) #>    community block   p1   p2   p3   p4 response     .Pred   .Lower   .Upper #> 1          1     1 0.70 0.10 0.10 0.10   10.815 10.466907 6.874932 14.05888 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 10.253858 6.661883 13.84583 #> 9          3     1 0.10 0.10 0.70 0.10   11.135  9.615319 6.023344 13.20729 #> 13         4     1 0.10 0.10 0.10 0.70    9.916  8.584323 4.992347 12.17630 #> 17         5     1 0.25 0.25 0.25 0.25   11.374  9.795128 6.260235 13.33002 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 10.601405 6.841037 14.36177  #################################################################### ##### Use model coefficients for prediction coeffs <- mod$coefficients  # Would now have to add columns corresponding to each coefficient in the # data and ensure there is an appropriate mapping between data columns and # the coefficients. newdata$`p1:p2` = newdata$p1 * newdata$p2 newdata$`p3:p4` = newdata$p3 * newdata$p4  # If the coefficients are named then the function will try to # perform matching between data columns and the coefficients # Notice that confidence intervals are not produced if we don't # specify a variance covariance matrix add_prediction(data = newdata, coefficients = coeffs) #>    community block   p1   p2   p3   p4 response  p1:p2  p3:p4     .Pred #> 1          1     1 0.70 0.10 0.10 0.10   10.815 0.0700 0.0100 10.466907 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 0.0700 0.0100 10.253858 #> 9          3     1 0.10 0.10 0.70 0.10   11.135 0.0100 0.0700  9.615319 #> 13         4     1 0.10 0.10 0.10 0.70    9.916 0.0100 0.0700  8.584323 #> 17         5     1 0.25 0.25 0.25 0.25   11.374 0.0625 0.0625  9.795128 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 0.1600 0.0100 10.601405  # However, if the coefficients are not named # The user would have to manually specify the subset # of data columns arranged according to the coefficients coeffs <- unname(coeffs)  subset_data <- newdata[, c(3:6, 8,9)] subset_data # Notice now we have the exact columns in data as in coefficients #>      p1   p2   p3   p4  p1:p2  p3:p4 #> 1  0.70 0.10 0.10 0.10 0.0700 0.0100 #> 5  0.10 0.70 0.10 0.10 0.0700 0.0100 #> 9  0.10 0.10 0.70 0.10 0.0100 0.0700 #> 13 0.10 0.10 0.10 0.70 0.0100 0.0700 #> 17 0.25 0.25 0.25 0.25 0.0625 0.0625 #> 21 0.40 0.40 0.10 0.10 0.1600 0.0100 add_prediction(data = subset_data, coefficients = coeffs) #>      p1   p2   p3   p4  p1:p2  p3:p4     .Pred #> 1  0.70 0.10 0.10 0.10 0.0700 0.0100 10.466907 #> 5  0.10 0.70 0.10 0.10 0.0700 0.0100 10.253858 #> 9  0.10 0.10 0.70 0.10 0.0100 0.0700  9.615319 #> 13 0.10 0.10 0.10 0.70 0.0100 0.0700  8.584323 #> 17 0.25 0.25 0.25 0.25 0.0625 0.0625  9.795128 #> 21 0.40 0.40 0.10 0.10 0.1600 0.0100 10.601405  # Or specify a selection (either by name or index) in coeff_cols add_prediction(data = newdata, coefficients = coeffs,                coeff_cols = c(\"p1\", \"p2\", \"p3\", \"p4\", \"p1:p2\", \"p3:p4\")) #>    community block   p1   p2   p3   p4 response  p1:p2  p3:p4     .Pred #> 1          1     1 0.70 0.10 0.10 0.10   10.815 0.0700 0.0100 10.466907 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 0.0700 0.0100 10.253858 #> 9          3     1 0.10 0.10 0.70 0.10   11.135 0.0100 0.0700  9.615319 #> 13         4     1 0.10 0.10 0.10 0.70    9.916 0.0100 0.0700  8.584323 #> 17         5     1 0.25 0.25 0.25 0.25   11.374 0.0625 0.0625  9.795128 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 0.1600 0.0100 10.601405  add_prediction(data = newdata, coefficients = coeffs,                coeff_cols = c(3, 4, 5, 6, 8, 9)) #>    community block   p1   p2   p3   p4 response  p1:p2  p3:p4     .Pred #> 1          1     1 0.70 0.10 0.10 0.10   10.815 0.0700 0.0100 10.466907 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 0.0700 0.0100 10.253858 #> 9          3     1 0.10 0.10 0.70 0.10   11.135 0.0100 0.0700  9.615319 #> 13         4     1 0.10 0.10 0.10 0.70    9.916 0.0100 0.0700  8.584323 #> 17         5     1 0.25 0.25 0.25 0.25   11.374 0.0625 0.0625  9.795128 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 0.1600 0.0100 10.601405  # Adding confidence intervals when using model coefficients coeffs <- mod$coefficients # We need to provide a variance-covariance matrix to calculate the CI # when using `coefficients` argument. The following warning will be given add_prediction(data = newdata, coefficients = coeffs,                interval = \"confidence\") #> Warning: `vcov` was not specified so uncertainty intervals cannot be calculated. #> ℹ The \".Upper\" and \".Lower\" columns will contain the same value as the \".Pred\" #>   column. #>    community block   p1   p2   p3   p4 response  p1:p2  p3:p4     .Pred #> 1          1     1 0.70 0.10 0.10 0.10   10.815 0.0700 0.0100 10.466907 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 0.0700 0.0100 10.253858 #> 9          3     1 0.10 0.10 0.70 0.10   11.135 0.0100 0.0700  9.615319 #> 13         4     1 0.10 0.10 0.10 0.70    9.916 0.0100 0.0700  8.584323 #> 17         5     1 0.25 0.25 0.25 0.25   11.374 0.0625 0.0625  9.795128 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 0.1600 0.0100 10.601405 #>       .Lower    .Upper #> 1  10.466907 10.466907 #> 5  10.253858 10.253858 #> 9   9.615319  9.615319 #> 13  8.584323  8.584323 #> 17  9.795128  9.795128 #> 21 10.601405 10.601405  vcov_mat <- vcov(mod) add_prediction(data = newdata, coefficients = coeffs,                interval = \"confidence\", vcov = vcov_mat) #>    community block   p1   p2   p3   p4 response  p1:p2  p3:p4     .Pred #> 1          1     1 0.70 0.10 0.10 0.10   10.815 0.0700 0.0100 10.466907 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 0.0700 0.0100 10.253858 #> 9          3     1 0.10 0.10 0.70 0.10   11.135 0.0100 0.0700  9.615319 #> 13         4     1 0.10 0.10 0.10 0.70    9.916 0.0100 0.0700  8.584323 #> 17         5     1 0.25 0.25 0.25 0.25   11.374 0.0625 0.0625  9.795128 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 0.1600 0.0100 10.601405 #>      .Lower    .Upper #> 1  9.813131 11.120684 #> 5  9.600082 10.907635 #> 9  8.961543 10.269096 #> 13 7.930546  9.238099 #> 17 9.338835 10.251422 #> 21 9.555182 11.647627  # Currently both confidence and prediction intervals will be the same when # using this method add_prediction(data = newdata, coefficients = coeffs,                interval = \"prediction\", vcov = vcov_mat) #>    community block   p1   p2   p3   p4 response  p1:p2  p3:p4     .Pred #> 1          1     1 0.70 0.10 0.10 0.10   10.815 0.0700 0.0100 10.466907 #> 5          2     1 0.10 0.70 0.10 0.10    6.724 0.0700 0.0100 10.253858 #> 9          3     1 0.10 0.10 0.70 0.10   11.135 0.0100 0.0700  9.615319 #> 13         4     1 0.10 0.10 0.10 0.70    9.916 0.0100 0.0700  8.584323 #> 17         5     1 0.25 0.25 0.25 0.25   11.374 0.0625 0.0625  9.795128 #> 21         6     1 0.40 0.40 0.10 0.10   12.492 0.1600 0.0100 10.601405 #>      .Lower    .Upper #> 1  9.813131 11.120684 #> 5  9.600082 10.907635 #> 9  8.961543 10.269096 #> 13 7.930546  9.238099 #> 17 9.338835 10.251422 #> 21 9.555182 11.647627"},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional ternary diagrams — conditional_ternary","title":"Conditional ternary diagrams — conditional_ternary","text":"fix \\(n-3\\) variables constant value \\(p_1, p_2, p_3, ... p_{n-3}\\) \\(P = p_1 + p_2 + p_3 + ... p_{n - 3}\\) \\(0 \\le P \\le 1\\) vary proportion remaining three variables \\(0\\) \\(1-P\\) visualise change predicted response contour map within ternary diagram. equivalent taking multiple 2-d slices high dimensional simplex space. Taking multiple 2-d slices across multiple variables allow create approximation response varies across n-dimensional simplex. wrapper function specifically statistical models fit using DI() function DImodels R package implicitly call conditional_ternary_data followed conditional_ternary_plot. model object fit using DImodels, consider calling functions manually.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional ternary diagrams — conditional_ternary","text":"","code":"conditional_ternary(   model,   FG = NULL,   values = NULL,   tern_vars = NULL,   conditional = NULL,   add_var = list(),   resolution = 3,   plot = TRUE,   nlevels = 7,   colours = NULL,   lower_lim = NULL,   upper_lim = NULL,   contour_text = FALSE,   show_axis_labels = TRUE,   show_axis_guides = FALSE,   axis_label_size = 4,   vertex_label_size = 5,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional ternary diagrams — conditional_ternary","text":"model Diversity Interactions model object fit using DI() function DImodels package. FG character vector specifying grouping variables specified `prop`. Specifying parameter call grouped_ternary_data function internally. See grouped_ternary grouped_ternary_data information. values numeric vector specifying proportional split variables within group. default split group proportion equally variable group. tern_vars character vector giving names three variables shown ternary diagram. conditional data-frame describing names compositional variables respective values slice simplex space. format , example, follows: data.frame(\"p1\" = c(0, 0.5), \"p2\" = c(0.2, 0.1))  One figure created row `conditional` respective values specified variables. compositional variables specified `conditional` assumed 0. add_var list data-frame specifying values additional variables model proportions (.e. part simplex design). useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data. resolution number 1 10 describing resolution resultant graph. high value result higher definition figure cost computationally expensive. plot boolean variable indicating whether create plot return prepared data instead. default TRUE creates plot FALSE return prepared data plotting. useful user wants modify data first create plot. nlevels number levels show contour map. colours character vector function specifying colours contour map points. number colours `nlevels` (`show = \"contours\"`).  default colours scheme terrain.colors() continuous variables extended version Okabe-Ito colour scale categorical variables. lower_lim number set custom lower limit contour (`show = \"contours\"`). default minimum prediction. upper_lim number set custom upper limit contour (`show = \"contours\"`). default maximum prediction. contour_text boolean value indicating whether include labels contour lines showing values (`show = \"contours\"`). default FALSE. show_axis_labels boolean value indicating whether show axis labels along edges ternary. default TRUE. show_axis_guides boolean value indicating whether show axis guides within interior ternary. default FALSE. axis_label_size numeric value adjust size axis labels ternary plot. default size 4. vertex_label_size numeric value adjust size vertex labels ternary plot. default size 5. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional ternary diagrams — conditional_ternary","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional ternary diagrams — conditional_ternary","text":"","code":"library(DImodels) library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union data(sim2) m1 <- DI(y = \"response\", data = sim2, prop = 3:6, DImodel = \"FULL\") #> Fitted model: Separate pairwise interactions 'FULL' DImodel  #' ## Create data for slicing ## We only condition on the variable \"p3\" conditional_ternary(model = m1, tern_vars = c(\"p1\", \"p2\", \"p4\"),                     conditional = data.frame(\"p3\" = c(0, 0.2, 0.5)),                     resolution = 1) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Slices for experiments for over 4 variables data(sim4) m2 <- DI(y = \"response\", prop = paste0(\"p\", 1:6),          DImodel = \"AV\", data = sim4) %>%          suppressWarnings() #> Fitted model: Average interactions 'AV' DImodel  ## Conditioning on multiple variables cond <- data.frame(p4 = c(0, 0.2), p3 = c(0.5, 0.1), p6 = c(0, 0.3)) conditional_ternary(model = m2, conditional = cond,                     tern_vars = c(\"p1\", \"p2\", \"p5\"), resolution = 1) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Create separate plots for additional variables not a part of the simplex m3 <- DI(y = \"response\", prop = paste0(\"p\", 1:6),          DImodel = \"AV\", data = sim4, treat = \"treatment\") %>%          suppressWarnings() #> Fitted model: Average interactions 'AV' DImodel  ## Create plot and arrange it using nrow and ncol # \\donttest{ conditional_ternary(model = m3, conditional = cond[1, ],                     tern_vars = c(\"p1\", \"p2\", \"p5\"),                     resolution = 1,                     add_var = list(\"treatment\" = c(50, 150)),                     nrow = 2, ncol = 1) #> ✔ Finished data preparation. #> ✔ Created all plots.  # }  ## Specify `plot = FALSE` to not create the plot but return the prepared data head(conditional_ternary(model = m3, conditional = cond[1, ],                          resolution = 1, plot = FALSE,                          tern_vars = c(\"p1\", \"p2\", \"p5\"),                          add_var = list(\"treatment\" = c(50, 150)))) #> ✔ Finished data preparation. #>   p1        p2          p5          .x .y p4  p3 p6 treatment   .add_str_ID #> 1  0 0.5000000 0.000000000 0.000000000  0  0 0.5  0        50 treatment: 50 #> 2  0 0.4974874 0.002512563 0.005025126  0  0 0.5  0        50 treatment: 50 #> 3  0 0.4949749 0.005025126 0.010050251  0  0 0.5  0        50 treatment: 50 #> 4  0 0.4924623 0.007537688 0.015075377  0  0 0.5  0        50 treatment: 50 #> 5  0 0.4899497 0.010050251 0.020100503  0  0 0.5  0        50 treatment: 50 #> 6  0 0.4874372 0.012562814 0.025125628  0  0 0.5  0        50 treatment: 50 #>          .Sp    .Value                   .Facet    .Pred #> 1 p4, p3, p6 0, 0.5, 0 p4 = 0; p3 = 0.5; p6 = 0 23.64637 #> 2 p4, p3, p6 0, 0.5, 0 p4 = 0; p3 = 0.5; p6 = 0 23.65679 #> 3 p4, p3, p6 0, 0.5, 0 p4 = 0; p3 = 0.5; p6 = 0 23.66693 #> 4 p4, p3, p6 0, 0.5, 0 p4 = 0; p3 = 0.5; p6 = 0 23.67680 #> 5 p4, p3, p6 0, 0.5, 0 p4 = 0; p3 = 0.5; p6 = 0 23.68639 #> 6 p4, p3, p6 0, 0.5, 0 p4 = 0; p3 = 0.5; p6 = 0 23.69572"},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional ternary diagrams — conditional_ternary_data","title":"Conditional ternary diagrams — conditional_ternary_data","text":"helper function preparing underlying data creating conditional ternary diagrams, fix \\(n-3\\) variables constant value \\(p_1, p_2, p_3, ..., p_{n-3}\\) \\(P = p_1 + p_2 + p_3 + ... p_{n - 3}\\) \\(0 \\le P \\le 1\\) vary proportion remaining three variables \\(0\\) \\(1-P\\) visualise change predicted response contour map within ternary diagram. output function can passed conditional_ternary_plot function plot results. Viewing multiple 2-d slices across multiple variables allow create approximation response varies across n-dimensional simplex.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional ternary diagrams — conditional_ternary_data","text":"","code":"conditional_ternary_data(   prop,   FG = NULL,   values = NULL,   tern_vars = NULL,   conditional = NULL,   add_var = list(),   resolution = 3,   prediction = TRUE,   ... )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional ternary diagrams — conditional_ternary_data","text":"prop character vector indicating model coefficients corresponding variable proportions. variables compositional nature (.e., proportions sum 1). FG character vector specifying grouping variables specified `prop`. Specifying parameter call grouped_ternary_data function internally. See grouped_ternary grouped_ternary_data information. values numeric vector specifying proportional split variables within group. default split group proportion equally variable group. tern_vars character vector giving names three variables shown ternary diagram. conditional data-frame describing names compositional variables respective values slice simplex space. format , example, follows: data.frame(\"p1\" = c(0, 0.5), \"p2\" = c(0.2, 0.1))  One figure created row `conditional` respective values specified variables. compositional variables specified `conditional` assumed 0. add_var list data-frame specifying values additional variables model proportions (.e. part simplex design). useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data. resolution number 1 10 describing resolution resultant graph. high value result higher definition figure cost computationally expensive. prediction logical value indicating whether pass final data `add_prediction` function append predictions data. Default value TRUE, often desirable make additional changes data making predictions, user can set FALSE manually call `add_prediction` function. ... Arguments passed add_prediction model regression model object used make predictions observations `data`. override `coefficients` specified. coefficients regression model available (fit R), regression coefficients model fit language can used calculate predictions. However, user ensure appropriate one--one positional mapping data columns coefficient values. , also provide variance-covariance matrix coefficients `vcov` parameter want associated CI prediction possible calculate confidence/prediction intervals using method. vcov regression coefficients specified, variance-covariance matrix coefficients can specified calculate associated confidence interval around prediction. Failure result confidence intervals returned. Ensure `coefficients` `vcov` positional mapping data. coeff_cols `coefficients` specified one--one positional mapping data-columns coefficient vector present. character string numeric index can specified reorder data columns match corresponding coefficient value respective data column. See \"Use model coefficients prediction\" section examples. conf.level confidence level calculating confidence/prediction intervals. Default 0.95. interval Type interval calculate: \"none\" (default) interval calculated. \"confidence\" Calculate confidence interval. \"prediction\" Calculate prediction interval.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional ternary diagrams — conditional_ternary_data","text":"data-frame containing compositional columns names specified         `prop` parameter along additional columns specified         `add_var` parameter. first five columns data contain         three variables (specified `tern_vars`) shown ternary along         2-d projection modified. following         additional columns also present data. .x x-projection points within ternary. .y y-projection points within ternary. .add_str_ID identifier column grouping cartesian product                       additional columns specified `add_var`                       parameter (`add_var` specified). .Sp identifier column specifying variable(s) along               high dimensional simplex sliced. .Value value(s) (0 1) along direction variable(s)                  `.Sp` high dimensional simplex sliced. .Facet identifier column formed combining `.Sp` `.value`                  group observations within specific slice                  high dimensional simplex. .Pred predicted response observation                 (`prediction` TRUE). .Lower lower limit prediction/confidence interval                  observation. .Upper upper limit prediction/confidence interval                  observation.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional ternary diagrams — conditional_ternary_data","text":"","code":"library(DImodels)  ## Load data data(sim4)  ## Fit model mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4 + p5 + p6)^2, data = sim4)  ## Create data ## Any species not specified in `tern_vars` or conditional will be assumed ## to be 0, for example p5 and p6 here. head(conditional_ternary_data(prop = c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"),                               tern_vars = c(\"p1\", \"p2\", \"p3\"),                               conditional = data.frame(\"p4\" = c(0, 0.2, 0.5)),                               model = mod,                               resolution = 1)) #> ✔ Finished data preparation. #>   p1        p2          p3          .x .y p4 p5 p6 .Sp .Value .Facet    .Pred #> 1  0 1.0000000 0.000000000 0.000000000  0  0  0  0  p4      0 p4 = 0 19.82837 #> 2  0 0.9949749 0.005025126 0.005025126  0  0  0  0  p4      0 p4 = 0 19.88595 #> 3  0 0.9899497 0.010050251 0.010050251  0  0  0  0  p4      0 p4 = 0 19.94305 #> 4  0 0.9849246 0.015075377 0.015075377  0  0  0  0  p4      0 p4 = 0 19.99966 #> 5  0 0.9798995 0.020100503 0.020100503  0  0  0  0  p4      0 p4 = 0 20.05579 #> 6  0 0.9748744 0.025125628 0.025125628  0  0  0  0  p4      0 p4 = 0 20.11143  ## Can also condition on multiple species cond <- data.frame(p4 = c(0, 0.2), p5 = c(0.5, 0.1), p6 = c(0, 0.3)) cond #>    p4  p5  p6 #> 1 0.0 0.5 0.0 #> 2 0.2 0.1 0.3 head(conditional_ternary_data(prop = c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"),                               tern_vars = c(\"p1\", \"p2\", \"p3\"),                               conditional = cond,                               model = mod,                               resolution = 1)) #> ✔ Finished data preparation. #>   p1        p2          p3          .x .y p4  p5 p6        .Sp    .Value #> 1  0 0.5000000 0.000000000 0.000000000  0  0 0.5  0 p4, p5, p6 0, 0.5, 0 #> 2  0 0.4974874 0.002512563 0.005025126  0  0 0.5  0 p4, p5, p6 0, 0.5, 0 #> 3  0 0.4949749 0.005025126 0.010050251  0  0 0.5  0 p4, p5, p6 0, 0.5, 0 #> 4  0 0.4924623 0.007537688 0.015075377  0  0 0.5  0 p4, p5, p6 0, 0.5, 0 #> 5  0 0.4899497 0.010050251 0.020100503  0  0 0.5  0 p4, p5, p6 0, 0.5, 0 #> 6  0 0.4874372 0.012562814 0.025125628  0  0 0.5  0 p4, p5, p6 0, 0.5, 0 #>                     .Facet    .Pred #> 1 p4 = 0; p5 = 0.5; p6 = 0 21.46473 #> 2 p4 = 0; p5 = 0.5; p6 = 0 21.50009 #> 3 p4 = 0; p5 = 0.5; p6 = 0 21.53533 #> 4 p4 = 0; p5 = 0.5; p6 = 0 21.57045 #> 5 p4 = 0; p5 = 0.5; p6 = 0 21.60544 #> 6 p4 = 0; p5 = 0.5; p6 = 0 21.64031  ## Fit model mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4 + p5 + p6)^2 + treatment,            data = sim4)  ## Can also add any additional variables independent of the simplex ## Notice the additional `.add_str_ID` column head(conditional_ternary_data(prop = c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"),                               tern_vars = c(\"p1\", \"p2\", \"p3\"),                               conditional = data.frame(\"p4\" = c(0, 0.2, 0.5)),                               add_var = list(\"treatment\" = c(50, 150)),                               model = mod,                               resolution = 1)) #> ✔ Finished data preparation. #>   p1        p2          p3          .x .y p4 treatment   .add_str_ID p5 p6 .Sp #> 1  0 1.0000000 0.000000000 0.000000000  0  0        50 treatment: 50  0  0  p4 #> 2  0 0.9949749 0.005025126 0.005025126  0  0        50 treatment: 50  0  0  p4 #> 3  0 0.9899497 0.010050251 0.010050251  0  0        50 treatment: 50  0  0  p4 #> 4  0 0.9849246 0.015075377 0.015075377  0  0        50 treatment: 50  0  0  p4 #> 5  0 0.9798995 0.020100503 0.020100503  0  0        50 treatment: 50  0  0  p4 #> 6  0 0.9748744 0.025125628 0.025125628  0  0        50 treatment: 50  0  0  p4 #>   .Value .Facet    .Pred #> 1      0 p4 = 0 16.90156 #> 2      0 p4 = 0 16.95914 #> 3      0 p4 = 0 17.01624 #> 4      0 p4 = 0 17.07285 #> 5      0 p4 = 0 17.12898 #> 6      0 p4 = 0 17.18462  ## It could be desirable to take the output of this function and add ## additional variables to the data before making predictions ## Use `prediction = FALSE` to get data without any predictions cond_data <- conditional_ternary_data(prop = c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"),                                       tern_vars = c(\"p1\", \"p2\", \"p3\"),                                       conditional = data.frame(\"p4\" = c(0, 0.2, 0.5)),                                       prediction = FALSE,                                       resolution = 1) #> ✔ Finished data preparation. ## The data can then be modified and the `add_prediction` function can be ## called manually using either the model object or model coefficients cond_data$treatment <- 50 head(add_prediction(data = cond_data, model = mod)) #>   p1        p2          p3          .x .y p4 p5 p6 .Sp .Value .Facet treatment #> 1  0 1.0000000 0.000000000 0.000000000  0  0  0  0  p4      0 p4 = 0        50 #> 2  0 0.9949749 0.005025126 0.005025126  0  0  0  0  p4      0 p4 = 0        50 #> 3  0 0.9899497 0.010050251 0.010050251  0  0  0  0  p4      0 p4 = 0        50 #> 4  0 0.9849246 0.015075377 0.015075377  0  0  0  0  p4      0 p4 = 0        50 #> 5  0 0.9798995 0.020100503 0.020100503  0  0  0  0  p4      0 p4 = 0        50 #> 6  0 0.9748744 0.025125628 0.025125628  0  0  0  0  p4      0 p4 = 0        50 #>      .Pred #> 1 16.90156 #> 2 16.95914 #> 3 17.01624 #> 4 17.07285 #> 5 17.12898 #> 6 17.18462"},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional ternary diagrams — conditional_ternary_plot","title":"Conditional ternary diagrams — conditional_ternary_plot","text":"helper function plotting conditional ternary diagrams. output `conditional_ternary_data` passed visualise n-dimensional simplex space 2-d slices showing change response across three variables, variables conditioned fixed values.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional ternary diagrams — conditional_ternary_plot","text":"","code":"conditional_ternary_plot(   data,   col_var = \".Pred\",   nlevels = 7,   colours = NULL,   lower_lim = NULL,   upper_lim = NULL,   tern_labels = colnames(data)[1:3],   contour_text = FALSE,   show_axis_labels = TRUE,   show_axis_guides = FALSE,   points_size = 2,   axis_label_size = 4,   vertex_label_size = 5,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional ternary diagrams — conditional_ternary_plot","text":"data data-frame output `conditional_ternary_data` function. col_var column name containing variable used colouring contours points. default \".Pred\". nlevels number levels show contour map. colours character vector function specifying colours contour map points. number colours `nlevels` (`show = \"contours\"`).  default colours scheme terrain.colors() continuous variables extended version Okabe-Ito colour scale categorical variables. lower_lim number set custom lower limit contour (`show = \"contours\"`). default minimum prediction. upper_lim number set custom upper limit contour (`show = \"contours\"`). default maximum prediction. tern_labels character vector containing labels vertices ternary. default column names first three columns data, first column corresponding top vertex, second column corresponding left vertex third column corresponding right vertex ternary. contour_text boolean value indicating whether include labels contour lines showing values (`show = \"contours\"`). default FALSE. show_axis_labels boolean value indicating whether show axis labels along edges ternary. default TRUE. show_axis_guides boolean value indicating whether show axis guides within interior ternary. default FALSE. points_size showing points, numeric value specifying size points. axis_label_size numeric value adjust size axis labels ternary plot. default size 4. vertex_label_size numeric value adjust size vertex labels ternary plot. default size 5. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional ternary diagrams — conditional_ternary_plot","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/conditional_ternary_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional ternary diagrams — conditional_ternary_plot","text":"","code":"library(DImodels)  ## Load data data(sim4)  ## Fit model mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4 + p5 + p6)^2, data = sim4)  ## Create data for slicing ## We only condition on the variable \"p3\" plot_data <- conditional_ternary_data(prop = c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"),                                       tern_vars = c(\"p1\", \"p2\", \"p4\"),                                       conditional = data.frame(\"p3\" = c(0, 0.2, 0.5)),                                       model = mod,                                       resolution = 1) #> ✔ Finished data preparation.  ## Create plot conditional_ternary_plot(data = plot_data) #> ✔ Created plot.   ## Condition on multiple variables cond <- data.frame(p4 = c(0, 0.2), p5 = c(0.5, 0.1), p6 = c(0, 0.3)) cond #>    p4  p5  p6 #> 1 0.0 0.5 0.0 #> 2 0.2 0.1 0.3 plot_data <- conditional_ternary_data(prop = c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"),                                       tern_vars = c(\"p1\", \"p2\", \"p3\"),                                       conditional = cond,                                       model = mod,                                       resolution = 1) #> ✔ Finished data preparation. ## Create plot conditional_ternary_plot(data = plot_data) #> ✔ Created plot.   ## Create multiple plots for additional variables using `add_var` ## Fit model # \\donttest{ mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4 + p5 + p6)^2 + treatment,            data = sim4)  ## Notice the additional `.add_str_ID` column plot_data <- conditional_ternary_data(prop = c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"),                                       tern_vars = c(\"p1\", \"p2\", \"p3\"),                                       conditional = data.frame(\"p4\" = c(0, 0.2, 0.5)),                                       add_var = list(\"treatment\" = c(50, 150)),                                       model = mod,                                       resolution = 1) #> ✔ Finished data preparation. ## Create plot ## Use nrow to align plots conditional_ternary_plot(data = plot_data, nrow = 2) #> ✔ Created all plots.  # }"},{"path":"https://rishvish.github.io/DImodelsVis/reference/copy_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Copy attributes from one object to another — copy_attributes","title":"Copy attributes from one object to another — copy_attributes","text":"function copies additional attributes `source` `target`. attributes already present `target` left untouched. function useful manipulating data *_data preparation functions ensure attributes necessary creating plot lost.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/copy_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copy attributes from one object to another — copy_attributes","text":"","code":"copy_attributes(target, source)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/copy_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copy attributes from one object to another — copy_attributes","text":"target object attributes added. source object whose attributes copy.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/copy_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copy attributes from one object to another — copy_attributes","text":"object specified `target` additional attributes `source` object.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/copy_attributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Copy attributes from one object to another — copy_attributes","text":"","code":"## Simple example a <- data.frame(Var1 = runif(1:10), Var2 = runif(1:10)) b <- data.frame(Var3 = runif(1:10), Var4 = runif(1:10)) attr(b, \"attr1\") <- \"Lorem\" attr(b, \"attr2\") <- \"ipsum\"  print(attributes(a)) #> $names #> [1] \"Var1\" \"Var2\" #>  #> $class #> [1] \"data.frame\" #>  #> $row.names #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  print(attributes(b)) #> $names #> [1] \"Var3\" \"Var4\" #>  #> $class #> [1] \"data.frame\" #>  #> $row.names #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $attr1 #> [1] \"Lorem\" #>  #> $attr2 #> [1] \"ipsum\" #>   ## Copy over attributes of `b` into `a` print(copy_attributes(target = a, source = b)) #>          Var1      Var2 #> 1  0.54460339 0.8570836 #> 2  0.27859715 0.3848097 #> 3  0.44670247 0.5279170 #> 4  0.37151118 0.6006375 #> 5  0.02806097 0.2613714 #> 6  0.46598719 0.2900502 #> 7  0.39003139 0.4800752 #> 8  0.02006522 0.9200055 #> 9  0.37697093 0.4007202 #> 10 0.55991284 0.2131727 ## Note the attributes already present in `a` are left untouched  ## Can also be used in the dplyr pipeline library(dplyr)  iris_sub <- iris[1:10, ] attr(iris_sub, \"attr1\") <- \"Lorem\" attr(iris_sub, \"attr2\") <- \"ipsum\" attributes(iris_sub) #> $names #> [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"      #>  #> $row.names #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $class #> [1] \"data.frame\" #>  #> $attr1 #> [1] \"Lorem\" #>  #> $attr2 #> [1] \"ipsum\" #>   ## Grouping can drop attributes we set iris_sub %>%    group_by(Species) %>%    summarise(mean(Sepal.Length)) %>%    attributes() #> $class #> [1] \"tbl_df\"     \"tbl\"        \"data.frame\" #>  #> $row.names #> [1] 1 #>  #> $names #> [1] \"Species\"            \"mean(Sepal.Length)\" #>   ## Use copy_attributes with `iris_sub` object as source ##  to add the attributes again iris_sub %>%    group_by(Species) %>%    summarise(mean(Sepal.Length)) %>%    copy_attributes(source = iris_sub) %>%    attributes() #> $class #> [1] \"tbl_df\"     \"tbl\"        \"data.frame\" #>  #> $row.names #> [1] 1 #>  #> $names #> [1] \"Species\"            \"mean(Sepal.Length)\" #>  #> $attr1 #> [1] \"Lorem\" #>  #> $attr2 #> [1] \"ipsum\" #>"},{"path":"https://rishvish.github.io/DImodelsVis/reference/custom_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Special custom filtering for compositional data — custom_filter","title":"Special custom filtering for compositional data — custom_filter","text":"handy wrapper around dplyr filter() function enabling user filter rows satisfy specific conditions compositional data like equi-proportional communities, communities given value richness without make changes data adding additional columns. functionalities dplyr filter() function.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/custom_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Special custom filtering for compositional data — custom_filter","text":"","code":"custom_filter(data, ..., prop = NULL, special = NULL)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/custom_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Special custom filtering for compositional data — custom_filter","text":"data data frame containing compositional variables used perform filtering. ... additional arguments specified dplyr filter() function. Filtering conditions additional variables can also specified . prop character/numeric vector indicating columns containing compositional variables `data`. special character string specifying filtering condition. Four special keywords can specified filtering   1. richness: positive integer value filter communities                specific number compositional variables (variables non-zero values).   2. evenness: numeric value 0 1, filter rows based                relative abundances compositional variables higher                value signifies even community equal proportions                variables.   3. equi: boolean variable indicating whether filter rows containing            equi-proportional communities, .e., communities variables            non-zero proportion.   4. monos: boolean value indicating whether filter communities             containing single compositional variable, .e., richness == 1. keywords can combined using logical operators can even combined variables data. Please use exact keywords (case-sensitive) query get appropriate results. See examples details.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/custom_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Special custom filtering for compositional data — custom_filter","text":"subset original data matches specified filtering conditions.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/custom_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Special custom filtering for compositional data — custom_filter","text":"","code":"library(DImodels) library(dplyr)  ## Load data data(sim3)  # The special filter keywords should be specified as a string # Filter communities containing 3 species head(custom_filter(data = sim3, prop = 4:12,                    special = \"richness == 3\")) #>   community richness treatment p1        p2 p3        p4 p5 p6 p7        p8 #> 1        46        3         A  0 0.0000000  0 0.3333333  0  0  0 0.3333333 #> 2        46        3         B  0 0.0000000  0 0.3333333  0  0  0 0.3333333 #> 3        46        3         A  0 0.0000000  0 0.3333333  0  0  0 0.3333333 #> 4        46        3         B  0 0.0000000  0 0.3333333  0  0  0 0.3333333 #> 5        47        3         A  0 0.3333333  0 0.0000000  0  0  0 0.3333333 #> 6        47        3         B  0 0.3333333  0 0.0000000  0  0  0 0.3333333 #>          p9 response #> 1 0.3333333   16.812 #> 2 0.3333333    9.902 #> 3 0.3333333   14.462 #> 4 0.3333333    8.845 #> 5 0.3333333   14.575 #> 6 0.3333333   10.924  # Filter communities at richness 6 OR evenness 0 head(custom_filter(data = sim3, prop = 4:12,                    special = \"richness == 6 | evenness == 0\"), 12) #>    community richness treatment p1 p2 p3 p4 p5 p6 p7 p8 p9 response #> 1          1        1         A  0  0  0  0  0  0  0  0  1   10.265 #> 2          1        1         B  0  0  0  0  0  0  0  0  1    7.740 #> 3          1        1         A  0  0  0  0  0  0  0  0  1   12.173 #> 4          1        1         B  0  0  0  0  0  0  0  0  1    8.497 #> 5          2        1         A  0  0  0  0  0  0  0  1  0   10.763 #> 6          2        1         B  0  0  0  0  0  0  0  1  0    8.989 #> 7          2        1         A  0  0  0  0  0  0  0  1  0   10.161 #> 8          2        1         B  0  0  0  0  0  0  0  1  0    7.193 #> 9          3        1         A  0  0  0  0  0  0  1  0  0   10.171 #> 10         3        1         B  0  0  0  0  0  0  1  0  0    6.053 #> 11         3        1         A  0  0  0  0  0  0  1  0  0    8.383 #> 12         3        1         B  0  0  0  0  0  0  1  0  0    4.569  # Filter all monoculture AND treatment \"A\" (treatment is column present in data) head(custom_filter(data = sim3, prop = 4:12,                    special = \"monos == TRUE & treatment == 'A'\"), 10) #>    community richness treatment p1 p2 p3 p4 p5 p6 p7 p8 p9 response #> 1          1        1         A  0  0  0  0  0  0  0  0  1   10.265 #> 2          1        1         A  0  0  0  0  0  0  0  0  1   12.173 #> 3          2        1         A  0  0  0  0  0  0  0  1  0   10.763 #> 4          2        1         A  0  0  0  0  0  0  0  1  0   10.161 #> 5          3        1         A  0  0  0  0  0  0  1  0  0   10.171 #> 6          3        1         A  0  0  0  0  0  0  1  0  0    8.383 #> 7          4        1         A  0  0  0  0  0  1  0  0  0   10.182 #> 8          4        1         A  0  0  0  0  0  1  0  0  0    8.240 #> 9          5        1         A  0  0  0  0  1  0  0  0  0   15.467 #> 10         5        1         A  0  0  0  0  1  0  0  0  0   14.790  # Filter all equi proportional communities but NOT monocultures head(custom_filter(data = sim3, prop = 4:12,                    special = \"equi == TRUE & monos == FALSE\")) #>   community richness treatment p1 p2 p3 p4 p5 p6  p7  p8  p9 response #> 1        10        2         A  0  0  0  0  0  0 0.0 0.5 0.5   10.734 #> 2        10        2         B  0  0  0  0  0  0 0.0 0.5 0.5    7.465 #> 3        10        2         A  0  0  0  0  0  0 0.0 0.5 0.5   10.054 #> 4        10        2         B  0  0  0  0  0  0 0.0 0.5 0.5    8.615 #> 5        11        2         A  0  0  0  0  0  0 0.5 0.0 0.5    8.614 #> 6        11        2         B  0  0  0  0  0  0 0.5 0.0 0.5    7.851  # Can also use normal filter sim3 %>% custom_filter(p1 == 1) #>   community richness treatment p1 p2 p3 p4 p5 p6 p7 p8 p9 response #> 1         9        1         A  1  0  0  0  0  0  0  0  0   13.539 #> 2         9        1         B  1  0  0  0  0  0  0  0  0   11.768 #> 3         9        1         A  1  0  0  0  0  0  0  0  0   11.869 #> 4         9        1         B  1  0  0  0  0  0  0  0  0   10.393  # Both special filtering and normal filtering can be combined as well sim3 %>% custom_filter(prop = paste0(\"p\", 1:9),                        special = \"richness == 1\",                        community %in% c(7, 9)) #>   community richness treatment p1 p2 p3 p4 p5 p6 p7 p8 p9 response #> 1         7        1         A  0  0  1  0  0  0  0  0  0   12.413 #> 2         7        1         B  0  0  1  0  0  0  0  0  0    8.376 #> 3         7        1         A  0  0  1  0  0  0  0  0  0   12.264 #> 4         7        1         B  0  0  1  0  0  0  0  0  0    8.371 #> 5         9        1         A  1  0  0  0  0  0  0  0  0   13.539 #> 6         9        1         B  1  0  0  0  0  0  0  0  0   11.768 #> 7         9        1         A  1  0  0  0  0  0  0  0  0   11.869 #> 8         9        1         B  1  0  0  0  0  0  0  0  0   10.393"},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_colours.html","id":null,"dir":"Reference","previous_headings":"","what":"Return colour-blind friendly colours — get_colours","title":"Return colour-blind friendly colours — get_colours","text":"Utility function return either distinct colour-blind friendly colour variable functional grouping specified, shades colour variables within functional group","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_colours.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return colour-blind friendly colours — get_colours","text":"","code":"get_colours(vars, FG = NULL)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_colours.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return colour-blind friendly colours — get_colours","text":"vars Either numeric value `n` get n colours, character vector values value mapped colour. FG character vector describing functional grouping variable belongs. Variables within group different shades colour.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_colours.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return colour-blind friendly colours — get_colours","text":"named vector containing hex codes colours","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_colours.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return colour-blind friendly colours — get_colours","text":"","code":"## Get n colours get_colours(vars = 4) #> [1] \"#009E73\" \"#AA4499\" \"#0072B2\" \"#F0E442\"  # Get a color-map for each value specified in vars get_colours(vars = c(\"p1\", \"p2\", \"p3\", \"p4\")) #> [1] \"#009E73\" \"#AA4499\" \"#0072B2\" \"#F0E442\"  # Group values of vars using FG. Variables in the same group # will have same shades of a colour get_colours(vars = 4, FG = c(\"G1\", \"G1\", \"G2\", \"G2\")) #> [1] \"#2D6852\" \"#5FCBA0\" \"#7A406F\" \"#B26CA5\""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_equi_comms.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all equi-proportional communities at specific levels of richness — get_equi_comms","title":"Get all equi-proportional communities at specific levels of richness — get_equi_comms","text":"Get equi-proportional communities specific levels richness","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_equi_comms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all equi-proportional communities at specific levels of richness — get_equi_comms","text":"","code":"get_equi_comms(   nvars,   richness_lvl = 1:nvars,   variables = paste0(\"Var\", 1:nvars),   threshold = 1e+06 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_equi_comms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all equi-proportional communities at specific levels of richness — get_equi_comms","text":"nvars Number variables design richness_lvl richness levels (number non-zero compositional variables community) return equi-proportional communities. Defaults richness level 1 `nvars` (inclusive). variables Names variables. used column names final result. Default \"Var\" followed column number. threshold maximum number communities select level richness situations many equi-proportional communities. Default value million.  Note: threshold < `number possible equi-proportional communities` given level richness, random selection communities equal number specified threshold returned.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_equi_comms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get all equi-proportional communities at specific levels of richness — get_equi_comms","text":"dataframe consisting random selection equi-proportional         communities level richness","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_equi_comms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get all equi-proportional communities at specific levels of richness — get_equi_comms","text":"","code":"## Get all equi-proportional communities for each level of richness upto 10 data10 <- get_equi_comms(10) head(data10, 12) #>    Var1 Var2 Var3 Var4 Var5 Var6 Var7 Var8 Var9 Var10 Richness #> 1   1.0  0.0  0.0    0    0    0    0    0    0     0        1 #> 2   0.0  1.0  0.0    0    0    0    0    0    0     0        1 #> 3   0.0  0.0  1.0    0    0    0    0    0    0     0        1 #> 4   0.0  0.0  0.0    1    0    0    0    0    0     0        1 #> 5   0.0  0.0  0.0    0    1    0    0    0    0     0        1 #> 6   0.0  0.0  0.0    0    0    1    0    0    0     0        1 #> 7   0.0  0.0  0.0    0    0    0    1    0    0     0        1 #> 8   0.0  0.0  0.0    0    0    0    0    1    0     0        1 #> 9   0.0  0.0  0.0    0    0    0    0    0    1     0        1 #> 10  0.0  0.0  0.0    0    0    0    0    0    0     1        1 #> 11  0.5  0.5  0.0    0    0    0    0    0    0     0        2 #> 12  0.5  0.0  0.5    0    0    0    0    0    0     0        2  ## Change variable names data4 <- get_equi_comms(4, variables = c(\"Lollium perenne\", \"Chichorum intybus\",                                          \"Trifolium repens\", \"Trifolium pratense\")) head(data4) #>   Lollium perenne Chichorum intybus Trifolium repens Trifolium pratense #> 1             1.0               0.0              0.0                  0 #> 2             0.0               1.0              0.0                  0 #> 3             0.0               0.0              1.0                  0 #> 4             0.0               0.0              0.0                  1 #> 5             0.5               0.5              0.0                  0 #> 6             0.5               0.0              0.5                  0 #>   Richness #> 1        1 #> 2        1 #> 3        1 #> 4        1 #> 5        2 #> 6        2  ## Get equi-proportional communities at specific levels of richness ## Get all equi-proportional communities of four variables at richness ## levels 1 and 3 data4_13 <- get_equi_comms(nvars = 4, richness = c(1, 3)) data4_13 #>        Var1      Var2      Var3      Var4 Richness #> 1 1.0000000 0.0000000 0.0000000 0.0000000        1 #> 2 0.0000000 1.0000000 0.0000000 0.0000000        1 #> 3 0.0000000 0.0000000 1.0000000 0.0000000        1 #> 4 0.0000000 0.0000000 0.0000000 1.0000000        1 #> 5 0.3333333 0.3333333 0.3333333 0.0000000        3 #> 6 0.3333333 0.3333333 0.0000000 0.3333333        3 #> 7 0.3333333 0.0000000 0.3333333 0.3333333        3 #> 8 0.0000000 0.3333333 0.3333333 0.3333333        3  ## If threshold is specified and it is less than the number of possible ## equi-proportional communites at a given level of richness, then a ## random selection of communities from the total possible would be returned ## Return only 2 random equi-proportional communities at the chosen richness ## levels data4_13_2 <- get_equi_comms(nvars = 4, richness = c(1, 3), threshold = 2) data4_13_2 #>        Var1      Var2      Var3      Var4 Richness #> 1 1.0000000 0.0000000 0.0000000 0.0000000        1 #> 2 1.0000000 0.0000000 0.0000000 0.0000000        1 #> 3 0.3333333 0.3333333 0.0000000 0.3333333        3 #> 4 0.0000000 0.3333333 0.3333333 0.3333333        3  ## Set threshold to a very high positive number to ensure ## random selection is never performed data_no_random <- get_equi_comms(nvars = 15,                                  threshold = .Machine$integer.max) head(data_no_random) #>   Var1 Var2 Var3 Var4 Var5 Var6 Var7 Var8 Var9 Var10 Var11 Var12 Var13 Var14 #> 1    1    0    0    0    0    0    0    0    0     0     0     0     0     0 #> 2    0    1    0    0    0    0    0    0    0     0     0     0     0     0 #> 3    0    0    1    0    0    0    0    0    0     0     0     0     0     0 #> 4    0    0    0    1    0    0    0    0    0     0     0     0     0     0 #> 5    0    0    0    0    1    0    0    0    0     0     0     0     0     0 #> 6    0    0    0    0    0    1    0    0    0     0     0     0     0     0 #>   Var15 Richness #> 1     0        1 #> 2     0        1 #> 3     0        1 #> 4     0        1 #> 5     0        1 #> 6     0        1"},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_shades.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns shades of colours — get_shades","title":"Returns shades of colours — get_shades","text":"Returns shades colours","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_shades.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns shades of colours — get_shades","text":"","code":"get_shades(colours = c(\"#808080\"), shades = 3)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_shades.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns shades of colours — get_shades","text":"colours character vector colours recognizable R, produces shades shades numeric vector giving number shades colour","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_shades.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns shades of colours — get_shades","text":"list consisting hex codes describing shades colour","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/get_shades.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns shades of colours — get_shades","text":"","code":"## Shades for a single colour get_shades(c(\"red\")) #> $red #> [1] \"#A32929\" \"#EA3E3E\" \"#EB6161\" #>   ## Shades for multiple colours get_shades(c(\"red\", \"blue\" ,\"#A5F8E3\", \"#808080\"), shades = c(2, 3, 4, 5)) #> $red #> [1] \"#BB3030\" \"#EA5050\" #>  #> $blue #> [1] \"#222286\" \"#3535C2\" \"#5959D5\" #>  #> $`#A5F8E3` #> [1] \"#72E8C0\" \"#8DEED1\" \"#B9F4E4\" \"#EBFCF8\" #>  #> $`#808080` #> [1] \"#4D4D4D\" \"#666666\" \"#808080\" \"#9A9A9A\" \"#B3B3B3\" #>   ## A single value for shade would imply all colours get the same number of shades get_shades(c(\"red\", \"blue\" ,\"#A5F8E3\", \"#808080\"), shades = 2) #> $red #> [1] \"#BB3030\" \"#EA5050\" #>  #> $blue #> [1] \"#28289A\" \"#4747CD\" #>  #> $`#A5F8E3` #> [1] \"#99EFD7\" \"#DCFAF2\" #>  #> $`#808080` #> [1] \"#666666\" \"#9A9A9A\" #>"},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualise change in (predicted) response over diversity gradient — gradient_change","title":"Visualise change in (predicted) response over diversity gradient — gradient_change","text":"scatter-plot predicted response (raw response) diversity gradient specific observations shown. points can overlaid `pie-glyphs` show relative proportions compositional variables. average change user-chosen variable chosen diversity gradient can also shown using `y_var` parameter.  wrapper function specifically statistical models fit using DI() function DImodels R package implicitly calls gradient_change_data followed gradient_change_plot. model object fit using DImodels, associated data plot functions can instead called manually.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualise change in (predicted) response over diversity gradient — gradient_change","text":"","code":"gradient_change(   model,   data = NULL,   gradient = c(\"richness\", \"evenness\"),   add_var = list(),   plot = TRUE,   average = TRUE,   y_var = \".Pred\",   pie_data = NULL,   pie_colours = NULL,   pie_radius = 0.25,   points_size = 3,   facet_var = NULL,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualise change in (predicted) response over diversity gradient — gradient_change","text":"model Diversity Interactions model object fit using DI() function DImodels package. data dataframe specifying communities interest user wants visualise gradient. left blank, data used fit model used. gradient Diversity gradient show X-axis, one \"richness\" \"evenness\". Defaults \"richness\". See `Details` information. add_var list specifying values additional predictor variables model independent compositional predictor variables. useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data arranged grid according value specified `nrow` `ncol`. plot boolean variable indicating whether create plot return prepared data instead. default `TRUE` creates plot `FALSE` return prepared data plotting. useful user wants modify data first call plotting function manually. average boolean value indicating whether plot line indicating average change predicted response respect variable shown X-axis. average calculated median value variables specified. y_var character string indicating column name variable shown Y-axis. useful plotting raw data Y-axis. default value \".Pred\" referring column containing model predictions. pie_data Showing points graph pie-glyphs resource intensive. Hence subset data-frame specified `data`, can specified visualise specific points pie-glyphs. pie_colours character vector specifying colours slices within pie-glyphs. pie_radius numeric value specifying radius (cm) pie-glyphs. points_size numeric value specifying size points (pie-glyphs shown) shown plots. facet_var character string numeric index identifying column data used faceting plot multiple panels. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualise change in (predicted) response over diversity gradient — gradient_change","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualise change in (predicted) response over diversity gradient — gradient_change","text":"Currently two diversity gradients supported Richness: metric describing number non-zero compositional   variables observation. Evenness: metric quantifying relative abundances   compositional variables observation. Defined   $$(2s/(s-1)) \\sum_{, j = 1; < j}^{s}{p_i * p_j}$$ \\(s\\)   total number compositional variables \\(p_i\\) \\(p_j\\)   proportions variables \\(\\) \\(j\\).   See Kirwan et al., 2007 <doi:10.1890/08-1684.1 > Kirwan et al., 2009   <doi:10.1890/08-1684.1 >   information. small example metrics calculated observations. Suppose four compositional variables (.e. \\(s = 4\\)) following three observations = (0.5, 0.5, 0, 0) B = (0.25, 0.25, 0.25, 0.25) C = (1, 0, 0, 0) richness values three observations follows = 2 (Since two four compositional variables non-zero) B = 4 (Since four compositional variables non-zero) C = 1 (Since one four compositional variables non-zero) evenness values calculated follows = \\(2*4/(4-1)*(0.5*0.5+0.5*0+0.5*0+0.5*0+0.5*0+0*0) = 0.67\\) B = \\(2*4/(4-1)*(0.25*0.25+0.25*0.25+0..25*0.25+0.25*0.25+0.25*0.25+0.25*0) = 1\\) C = \\(2*4/(4-1)*(1*0+1*0+1*0+0*0+0*0+0*0) = 0\\)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualise change in (predicted) response over diversity gradient — gradient_change","text":"","code":"## Load DImodels package to fit the model library(DImodels) library(dplyr)  ## Load data data(sim4) sim4 <- sim4 %>% filter(treatment == 50)  ## Fit DI model mod <- DI(prop = 3:8, DImodel = \"AV\", data = sim4, y = \"response\") %>%          suppressWarnings() #> Fitted model: Average interactions 'AV' DImodel  ## Create visualisation  ## By default, 'richness' is the gradient and communities from the ## raw data are used to calculate average response gradient_change(model = mod) #> ✔ Finished data preparation #> ✔ Created plot.   ## Specify custom data gradient_change(model = mod, data = sim4 %>% filter(richness <= 4)) #> ✔ Finished data preparation #> ✔ Created plot.   ## Create plot for all equi-proportional communities at a ## given level of richness plot_data <- get_equi_comms(6, variables = paste0(\"p\", 1:6)) gradient_change(model = mod, data = plot_data) #> ✔ Finished data preparation #> ✔ Created plot.   ## Can also plot average response across evenness and ## change colours of the pie-slices using `pie_colours` gradient_change(model = mod, gradient = \"evenness\",                 pie_colours = c(\"darkolivegreen1\", \"darkolivegreen4\",                                 \"orange1\", \"orange4\",                                 \"steelblue1\", \"steelblue4\")) #> ✔ Finished data preparation #> ✔ Created plot.   ## Manually specify only specific communities to be shown as pie-chart ## glyphs using `pie_data` and `facet_var` to facet the plot on ## an additional variable. gradient_change(model = mod,                 pie_data = sim4 %>% filter(richness %in% c(1, 6)),                 facet_var = \"treatment\") #> ✔ Finished data preparation #> ✔ Created plot.   ## Use `add_var` to add additional variables independent of the compositions ## Multiple plots will be produced and can be arranged using nrow and ncol ## Create plot arranged in 2 columns # \\donttest{ gradient_change(model = mod,                 data = sim4[, -2],                 add_var = list(\"treatment\" = c(50, 250)),                 pie_data = sim4[, -2] %>% filter(richness %in% c(1, 6)),                 ncol = 2) #> ✔ Finished data preparation #> ✔ Created all plots.  # }  ## Specify `plot = FALSE` to not create the plot but return the prepared data head(gradient_change(model = mod, plot = FALSE,                      pie_data = sim4 %>% filter(richness %in% c(1, 6)),                      facet_var = \"treatment\")) #> ✔ Finished data preparation #> # A tibble: 6 × 14 #>   richness treatment    p1    p2    p3    p4    p5    p6 response .Richness #>      <int>     <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>     <dbl> #> 1        1        50     1     0     0     0     0     0     26.3         1 #> 2        1        50     1     0     0     0     0     0     29.1         1 #> 3        1        50     1     0     0     0     0     0     27.6         1 #> 4        1        50     0     1     0     0     0     0     17.4         1 #> 5        1        50     0     1     0     0     0     0     15.7         1 #> 6        1        50     0     1     0     0     0     0     14.3         1 #> # ℹ 4 more variables: .Evenness <dbl>, .Gradient <chr>, .Pred <dbl>, .Avg <dbl>"},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate change in predicted response over diversity gradient — gradient_change_data","title":"Calculate change in predicted response over diversity gradient — gradient_change_data","text":"Helper function creating data visualise scatter-plot response diversity gradient. \"richness\" \"evenness\" diversity gradients currently supported. average (predicted) response calculated communities present given level chosen diversity gradient `data`. output function can passed gradient_change_plot function visualise results.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate change in predicted response over diversity gradient — gradient_change_data","text":"","code":"gradient_change_data(   data,   prop,   add_var = list(),   gradient = c(\"richness\", \"evenness\"),   prediction = TRUE,   ... )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate change in predicted response over diversity gradient — gradient_change_data","text":"data data-frame consisting variable proportions necessary variables make predictions `model` `coefficients`. prop vector identifying column-names indices columns containing variable proportions `data`. add_var list specifying values additional predictor variables model independent compositional predictor variables. useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data arranged grid according value specified `nrow` `ncol`. gradient Diversity gradient show X-axis, one \"richness\" \"evenness\". Defaults \"richness\". See `Details` information. prediction logical value indicating whether pass final data `add_prediction` function append predictions data. Default value TRUE, often desirable make additional changes data making predictions, user can set FALSE manually call `add_prediction` function. ... Arguments passed add_prediction model regression model object used make predictions observations `data`. override `coefficients` specified. coefficients regression model available (fit R), regression coefficients model fit language can used calculate predictions. However, user ensure appropriate one--one positional mapping data columns coefficient values. , also provide variance-covariance matrix coefficients `vcov` parameter want associated CI prediction possible calculate confidence/prediction intervals using method. vcov regression coefficients specified, variance-covariance matrix coefficients can specified calculate associated confidence interval around prediction. Failure result confidence intervals returned. Ensure `coefficients` `vcov` positional mapping data. coeff_cols `coefficients` specified one--one positional mapping data-columns coefficient vector present. character string numeric index can specified reorder data columns match corresponding coefficient value respective data column. See \"Use model coefficients prediction\" section examples. conf.level confidence level calculating confidence/prediction intervals. Default 0.95. interval Type interval calculate: \"none\" (default) interval calculated. \"confidence\" Calculate confidence interval. \"prediction\" Calculate prediction interval.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate change in predicted response over diversity gradient — gradient_change_data","text":"data-frame following columns appended end .Richness richness (number non-zero compositional variables)                     within observation. .Evenness evenness (metric quantifying relative abundance                     compositional variable) within observation. .Gradient character string defining diversity gradient used                     averaging response. .add_str_ID identifier column grouping cartesian product                       additional columns specified `add_var`                       parameter (`add_var` specified). .Pred predicted response obsvervation. .Lower lower limit prediction/confidence interval                  observation. .Upper upper limit prediction/confidence interval                  observation. .Avg averaged value predicted response unique                value selected diversity gradient.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate change in predicted response over diversity gradient — gradient_change_data","text":"Currently two diversity gradients supported Richness: metric describing number non-zero compositional   variables observation. Evenness: metric quantifying relative abundances   compositional variables observation. Defined   $$(2s/(s-1)) \\sum_{, j = 1; < j}^{s}{p_i * p_j}$$ \\(s\\)   total number compositional variables \\(p_i\\) \\(p_j\\)   proportions variables \\(\\) \\(j\\).   See Kirwan et al., 2007 <doi:10.1890/08-1684.1 > Kirwan et al., 2009   <doi:10.1890/08-1684.1 >   information. small example metrics calculated observations. Suppose four compositional variables (.e. \\(s = 4\\)) following three observations = (0.5, 0.5, 0, 0) B = (0.25, 0.25, 0.25, 0.25) C = (1, 0, 0, 0) richness values three observations follows = 2 (Since two four compositional variables non-zero) B = 4 (Since four compositional variables non-zero) C = 1 (Since one four compositional variables non-zero) evenness values calculated follows = \\(2*4/(4-1)*(0.5*0.5+0.5*0+0.5*0+0.5*0+0.5*0+0*0) = 0.67\\) B = \\(2*4/(4-1)*(0.25*0.25+0.25*0.25+0..25*0.25+0.25*0.25+0.25*0.25+0.25*0) = 1\\) C = \\(2*4/(4-1)*(1*0+1*0+1*0+0*0+0*0+0*0) = 0\\)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate change in predicted response over diversity gradient — gradient_change_data","text":"","code":"library(DImodels) library(dplyr)  ## Load data data(sim2)  ## Fit model mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4)^2, data = sim2)  ## Create data ## By default response would be averaged on the basis of richness head(gradient_change_data(data = sim2,                           prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                           model = mod)) #> ✔ Finished data preparation #> # A tibble: 6 × 12 #>   community block    p1    p2    p3    p4 response .Richness .Evenness .Gradient #>       <int> <fct> <dbl> <dbl> <dbl> <dbl>    <dbl>     <dbl>     <dbl> <chr>     #> 1         1 1       0.7   0.1   0.1   0.1     20.2         4      0.64 .Richness #> 2         1 2       0.7   0.1   0.1   0.1     20.1         4      0.64 .Richness #> 3         1 3       0.7   0.1   0.1   0.1     20.9         4      0.64 .Richness #> 4         1 4       0.7   0.1   0.1   0.1     17.0         4      0.64 .Richness #> 5         2 1       0.1   0.7   0.1   0.1     17.2         4      0.64 .Richness #> 6         2 2       0.1   0.7   0.1   0.1     19.9         4      0.64 .Richness #> # ℹ 2 more variables: .Pred <dbl>, .Avg <dbl>  ## Average response with respect to evenness head(gradient_change_data(data = sim2,                           prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                           model = mod,                           gradient = \"evenness\")) #> ✔ Finished data preparation #> # A tibble: 6 × 12 #>   community block    p1    p2    p3    p4 response .Richness .Evenness .Gradient #>       <int> <fct> <dbl> <dbl> <dbl> <dbl>    <dbl>     <dbl>     <dbl> <chr>     #> 1         1 1       0.7   0.1   0.1   0.1     20.2         4      0.64 .Evenness #> 2         1 2       0.7   0.1   0.1   0.1     20.1         4      0.64 .Evenness #> 3         1 3       0.7   0.1   0.1   0.1     20.9         4      0.64 .Evenness #> 4         1 4       0.7   0.1   0.1   0.1     17.0         4      0.64 .Evenness #> 5         2 1       0.1   0.7   0.1   0.1     17.2         4      0.64 .Evenness #> 6         2 2       0.1   0.7   0.1   0.1     19.9         4      0.64 .Evenness #> # ℹ 2 more variables: .Pred <dbl>, .Avg <dbl>  ## Additional variables can also be added to the data by either specifying ## them directly in the `data` or by using the `add_var` argument ## Refit model sim2$block <- as.numeric(sim2$block) new_mod <- update(mod, ~. + block, data = sim2) ## This model has block so we can either specify block in the data subset_data <- sim2[c(1,5,9,11), 2:6] subset_data #>    block  p1  p2  p3  p4 #> 1      1 0.7 0.1 0.1 0.1 #> 5      1 0.1 0.7 0.1 0.1 #> 9      1 0.1 0.1 0.7 0.1 #> 11     3 0.1 0.1 0.7 0.1 head(gradient_change_data(data = subset_data,                           prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                           model = mod,                           gradient = \"evenness\")) #> ✔ Finished data preparation #> # A tibble: 4 × 10 #>   block    p1    p2    p3    p4 .Richness .Evenness .Gradient .Pred  .Avg #>   <dbl> <dbl> <dbl> <dbl> <dbl>     <dbl>     <dbl> <chr>     <dbl> <dbl> #> 1     1   0.7   0.1   0.1   0.1         4      0.64 .Evenness  18.4  17.3 #> 2     1   0.1   0.7   0.1   0.1         4      0.64 .Evenness  17.5  17.3 #> 3     1   0.1   0.1   0.7   0.1         4      0.64 .Evenness  16.6  17.3 #> 4     3   0.1   0.1   0.7   0.1         4      0.64 .Evenness  16.6  17.3 ## Or we could add the variable using `add_var` subset_data <- sim2[c(1,5,9,11), 3:6] subset_data #>     p1  p2  p3  p4 #> 1  0.7 0.1 0.1 0.1 #> 5  0.1 0.7 0.1 0.1 #> 9  0.1 0.1 0.7 0.1 #> 11 0.1 0.1 0.7 0.1 head(gradient_change_data(data = subset_data,                           prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                           model = new_mod,                           gradient = \"evenness\",                           add_var = list(block = c(1, 2)))) #> ✔ Finished data preparation #> # A tibble: 6 × 11 #>      p1    p2    p3    p4 block .add_str_ID .Richness .Evenness .Gradient .Pred #>   <dbl> <dbl> <dbl> <dbl> <dbl> <chr>           <dbl>     <dbl> <chr>     <dbl> #> 1   0.7   0.1   0.1   0.1     1 block: 1            4      0.64 .Evenness  19.1 #> 2   0.1   0.7   0.1   0.1     1 block: 1            4      0.64 .Evenness  18.2 #> 3   0.1   0.1   0.7   0.1     1 block: 1            4      0.64 .Evenness  17.3 #> 4   0.1   0.1   0.7   0.1     1 block: 1            4      0.64 .Evenness  17.3 #> 5   0.7   0.1   0.1   0.1     2 block: 2            4      0.64 .Evenness  18.7 #> 6   0.1   0.7   0.1   0.1     2 block: 2            4      0.64 .Evenness  17.8 #> # ℹ 1 more variable: .Avg <dbl> ## The benefit of specifying the variable this way is we have an ID ## columns now called `.add_str_ID` which could be used to create a ## separate plot for each value of the additional variable   ## Model coefficients can also be used, but then user would have ## to specify the data with all columns corresponding to each coefficient coef_data <- sim2 %>%                mutate(`p1:p2` = p1*p2, `p1:p3` = p1*p2, `p1:p4` = p1*p4,                       `p2:p3` = p2*p3, `p2:p4` = p2*p4, `p3:p4` = p3*p4) %>%                select(p1, p2, p3, p4,                       `p1:p2`, `p1:p3`, `p1:p4`,                       `p2:p3`, `p2:p4`, `p3:p4`) %>%                slice(1,5,9,11) print(coef_data) #>     p1  p2  p3  p4 p1:p2 p1:p3 p1:p4 p2:p3 p2:p4 p3:p4 #> 1  0.7 0.1 0.1 0.1  0.07  0.07  0.07  0.01  0.01  0.01 #> 5  0.1 0.7 0.1 0.1  0.07  0.07  0.01  0.07  0.07  0.01 #> 9  0.1 0.1 0.7 0.1  0.01  0.01  0.01  0.07  0.01  0.07 #> 11 0.1 0.1 0.7 0.1  0.01  0.01  0.01  0.07  0.01  0.07 print(mod$coefficients) #>        p1        p2        p3        p4     p1:p2     p1:p3     p1:p4     p2:p3  #> 10.699426 10.228917  8.939289  8.532857 33.894874 37.552444 32.720996 26.739691  #>     p2:p4     p3:p4  #> 33.188799 27.771368  gradient_change_data(data = coef_data,                      prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                      gradient = \"evenness\",                      coefficients = mod$coefficients,                      interval = \"none\") #> ✔ Finished data preparation #> # A tibble: 4 × 15 #>      p1    p2    p3    p4 `p1:p2` `p1:p3` `p1:p4` `p2:p3` `p2:p4` `p3:p4` #>   <dbl> <dbl> <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> #> 1   0.7   0.1   0.1   0.1    0.07    0.07    0.07    0.01    0.01    0.01 #> 2   0.1   0.7   0.1   0.1    0.07    0.07    0.01    0.07    0.07    0.01 #> 3   0.1   0.1   0.7   0.1    0.01    0.01    0.01    0.07    0.01    0.07 #> 4   0.1   0.1   0.7   0.1    0.01    0.01    0.01    0.07    0.01    0.07 #> # ℹ 5 more variables: .Richness <dbl>, .Evenness <dbl>, .Gradient <chr>, #> #   .Pred <dbl>, .Avg <dbl>"},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualise change in (predicted) response over diversity gradient — gradient_change_plot","title":"Visualise change in (predicted) response over diversity gradient — gradient_change_plot","text":"Helper function plotting average (predicted) response level diversity gradient. output gradient_change_data function passed visualise scatter-plot predicted response (raw response) diversity gradient. points can overlaid `pie-glyphs` show relative proportions compositional variables. average change user-chosen variable chosen diversity gradient can also shown using `y_var` parameter.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualise change in (predicted) response over diversity gradient — gradient_change_plot","text":"","code":"gradient_change_plot(   data,   prop = NULL,   pie_data = NULL,   pie_colours = NULL,   pie_radius = 0.25,   points_size = 3,   average = TRUE,   y_var = \".Pred\",   facet_var = NULL,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualise change in (predicted) response over diversity gradient — gradient_change_plot","text":"data data-frame output `gradient_change_data` function, consisting predicted response averaged particular diversity gradient. prop vector column names indices identifying columns containing species proportions data. inferred data created using `gradient_change_data` function, user also flexibility manually specifying values. pie_data subset data-frame specified `data`, visualise individual data-points pie-glyphs showing relative proportions variables data-point. pie_colours character vector specifying colours slices within pie-glyphs. pie_radius numeric value specifying radius (cm) pie-glyphs. points_size numeric value specifying size points (pie-glyphs shown) shown plots. average boolean value indicating whether plot line indicating average change predicted response respect variable shown X-axis. average calculated median value variables specified. y_var character string indicating column name variable shown Y-axis. useful plotting raw data Y-axis. default value \".Pred\" referring column containing model predictions. facet_var character string numeric index identifying column data used faceting plot multiple panels. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualise change in (predicted) response over diversity gradient — gradient_change_plot","text":"ggplot object","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/gradient_change_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualise change in (predicted) response over diversity gradient — gradient_change_plot","text":"","code":"library(DImodels) library(dplyr)  ## Load data data(sim4) sim4 <- sim4 %>% filter(treatment %in% c(50, 150))  ## Fit model mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4 + p5 + p6)^2, data = sim4)  ## Create data ## By default response would be averaged on the basis of richness plot_data <- gradient_change_data(data = sim4,                                   prop = c(\"p1\", \"p2\", \"p3\",                                            \"p4\", \"p5\", \"p6\"),                                   model = mod) #> ✔ Finished data preparation  ## Create plot gradient_change_plot(data = plot_data) #> ✔ Created plot.   ## Average response with respect to evenness plot_data <- gradient_change_data(data = sim4,                                   prop = c(\"p1\", \"p2\", \"p3\",                                            \"p4\", \"p5\", \"p6\"),                                   model = mod,                                   gradient = \"evenness\") #> ✔ Finished data preparation gradient_change_plot(data = plot_data) #> ✔ Created plot.   ## Can also manually specify prop variables ## Add grouped proportions to data plot_data <- group_prop(plot_data,                        prop = c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"),                        FG = c(\"Gr\", \"Gr\", \"Le\", \"Le\", \"He\", \"He\")) ## Manually specify prop to show in pie-glyphs gradient_change_plot(data = plot_data,                      prop = c(\"Gr\", \"Le\", \"He\")) #> ✔ Created plot.   ## Don't show line indicating the average change by using `average = FALSE` and ## Change colours of the pie-slices using `pie_colours` gradient_change_plot(data = plot_data,                      average = FALSE,                      pie_colours = c(\"darkolivegreen1\", \"darkolivegreen4\",                                      \"orange1\", \"orange4\",                                      \"steelblue1\", \"steelblue4\")) #> ✔ Created plot.   ## Manually specify only specific communities to be shown as pie-chart ## glyphs using `pie_data`. ## Note: It is important for the data specified in ## `pie_data` to have the .Pred and .Gradient columns. ## So the best use case for this parameter is to accept ## a subset of the data specified in `data`.#' ## Also use `facet_var` to facet the plot on an additional variable gradient_change_plot(data = plot_data,                      pie_data = plot_data %>% filter(.Richness %in% c(1, 6)),                      facet_var = \"treatment\") #> ✔ Created plot.   ## If `add_var` was used during the data preparation step then ## multiple plots will be produced and can be arranged using nrow and ncol # \\donttest{ new_mod <- update(mod, ~. + treatment, data = sim4) plot_data <- gradient_change_data(data = sim4[c(seq(1, 18, 3), 19:47), -2],                                   prop = c(\"p1\", \"p2\", \"p3\",                                            \"p4\", \"p5\", \"p6\"),                                   model = new_mod,                                   add_var = list(\"treatment\" = c(50, 250))) #> ✔ Finished data preparation ## Create plot arranged in 2 columns gradient_change_plot(data = plot_data,                      pie_data = plot_data %>% filter(.Richness %in% c(1, 6)),                      ncol = 2) #> ✔ Created all plots.   ## Create plot for raw data instead of predictions ## Create the data for plotting by specifying `prediction = FALSE` plot_data <- gradient_change_data(data = sim4[sim4$treatment == 50, ],                                   prop = c(\"p1\", \"p2\", \"p3\",                                            \"p4\", \"p5\", \"p6\"),                                   prediction = FALSE) #> ✔ Finished data preparation ## This data will not have any predictions head(plot_data) #>   richness treatment p1 p2 p3 p4 p5 p6 response .Richness .Evenness .Gradient #> 1        1        50  1  0  0  0  0  0   26.325         1         0 .Richness #> 2        1        50  1  0  0  0  0  0   29.083         1         0 .Richness #> 3        1        50  1  0  0  0  0  0   27.581         1         0 .Richness #> 4        1        50  0  1  0  0  0  0   17.391         1         0 .Richness #> 5        1        50  0  1  0  0  0  0   15.678         1         0 .Richness #> 6        1        50  0  1  0  0  0  0   14.283         1         0 .Richness ## Call the plotting function by specifying the variable you we wish to ## plot on the Y-axis by using the argument `y_var` ## Since this data wasn't created using `gradient_change_data` ## `prop` should be manually specified gradient_change_plot(data = plot_data, y_var = \"response\",                      prop = c(\"p1\", \"p2\", \"p3\",                               \"p4\", \"p5\", \"p6\")) #> ✔ Created plot.  # }"},{"path":"https://rishvish.github.io/DImodelsVis/reference/group_prop.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine variable proportions into groups — group_prop","title":"Combine variable proportions into groups — group_prop","text":"Combine variable proportions groups","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/group_prop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine variable proportions into groups — group_prop","text":"","code":"group_prop(data, prop, FG = NULL)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/group_prop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine variable proportions into groups — group_prop","text":"data data frame containing compositional variables need grouped. prop character/numeric vector indicating columns containing compositional variables `data`. FG character vector length `prop` specifying group variable belongs .","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/group_prop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine variable proportions into groups — group_prop","text":"data-frame additional columns appended end contain grouped variable proportions.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/group_prop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine variable proportions into groups — group_prop","text":"","code":"library(DImodels)  data(sim1)  head(group_prop(data = sim1, prop = 3:6,                 FG = c(\"Gr1\", \"Gr1\", \"Gr1\", \"Gr2\"))) #>   community block  p1  p2  p3  p4 response Gr1 Gr2 #> 1         1     1 0.7 0.1 0.1 0.1   10.815 0.9 0.1 #> 2         1     2 0.7 0.1 0.1 0.1   11.232 0.9 0.1 #> 3         1     3 0.7 0.1 0.1 0.1   10.192 0.9 0.1 #> 4         1     4 0.7 0.1 0.1 0.1    8.157 0.9 0.1 #> 5         2     1 0.1 0.7 0.1 0.1    6.724 0.9 0.1 #> 6         2     2 0.1 0.7 0.1 0.1   11.093 0.9 0.1  head(group_prop(data = sim1, prop = 3:6,                 FG = c(\"Group1\", \"Group2\", \"Group1\", \"Group3\"))) #>   community block  p1  p2  p3  p4 response Group1 Group2 Group3 #> 1         1     1 0.7 0.1 0.1 0.1   10.815    0.8    0.1    0.1 #> 2         1     2 0.7 0.1 0.1 0.1   11.232    0.8    0.1    0.1 #> 3         1     3 0.7 0.1 0.1 0.1   10.192    0.8    0.1    0.1 #> 4         1     4 0.7 0.1 0.1 0.1    8.157    0.8    0.1    0.1 #> 5         2     1 0.1 0.7 0.1 0.1    6.724    0.2    0.7    0.1 #> 6         2     2 0.1 0.7 0.1 0.1   11.093    0.2    0.7    0.1  ## Data is returned as is, if no groups are specified in FG head(group_prop(data = sim1, prop = 3:6)) #>   community block  p1  p2  p3  p4 response #> 1         1     1 0.7 0.1 0.1 0.1   10.815 #> 2         1     2 0.7 0.1 0.1 0.1   11.232 #> 3         1     3 0.7 0.1 0.1 0.1   10.192 #> 4         1     4 0.7 0.1 0.1 0.1    8.157 #> 5         2     1 0.1 0.7 0.1 0.1    6.724 #> 6         2     2 0.1 0.7 0.1 0.1   11.093"},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional ternary diagrams at functional group level — grouped_ternary","title":"Conditional ternary diagrams at functional group level — grouped_ternary","text":"Grouped ternary diagrams created combining proportions compositional variables groups visualising groups 2-d ternary diagram. useful multiple compositional variables can grouped together hierarchical grouping structure. example, grouping species ecosystem based functions perform, grouping political parties based national alliances. Grouping variables way allows us reduce dimensionality compositional data visualise . akin looking 2-d slice high dimensional simplex. relative proportions variable within group can adjusted look different slices simplex. Looking multiple slices enable us create approximation response varies across original n-dimensional simplex. wrapper function specifically statistical models fit using DI() function DImodels R package implicitly call grouped_ternary_data followed grouped_ternary_plot. model object fit using DImodels, consider calling functions manually.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional ternary diagrams at functional group level — grouped_ternary","text":"","code":"grouped_ternary(   model,   FG,   values = NULL,   tern_vars = NULL,   conditional = NULL,   add_var = list(),   resolution = 3,   plot = TRUE,   nlevels = 7,   colours = NULL,   lower_lim = NULL,   upper_lim = NULL,   contour_text = FALSE,   show_axis_labels = TRUE,   show_axis_guides = FALSE,   axis_label_size = 4,   vertex_label_size = 5,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional ternary diagrams at functional group level — grouped_ternary","text":"model Diversity Interactions model object fit using DI() function DImodels package. FG character vector specifying groupings variables specified `prop`. values numeric vector specifying proportional split variables within group. default split group proportion equally variable group. tern_vars character vector giving names three variables shown ternary diagram. conditional data-frame describing names compositional variables respective values slice simplex space. format , example, follows: data.frame(\"p1\" = c(0, 0.5), \"p2\" = c(0.2, 0.1))  One figure created row `conditional` respective values specified variables. compositional variables specified `conditional` assumed 0. add_var list data-frame specifying values additional variables model proportions (.e. part simplex design). useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data. resolution number 1 10 describing resolution resultant graph. high value result higher definition figure cost computationally expensive. plot boolean variable indicating whether create plot return prepared data instead. default TRUE creates plot FALSE return prepared data plotting. useful user wants modify data first create plot. nlevels number levels show contour map. colours character vector function specifying colours contour map points. number colours `nlevels` (`show = \"contours\"`).  default colours scheme terrain.colors() continuous variables extended version Okabe-Ito colour scale categorical variables. lower_lim number set custom lower limit contour (`show = \"contours\"`). default minimum prediction. upper_lim number set custom upper limit contour (`show = \"contours\"`). default maximum prediction. contour_text boolean value indicating whether include labels contour lines showing values (`show = \"contours\"`). default FALSE. show_axis_labels boolean value indicating whether show axis labels along edges ternary. default TRUE. show_axis_guides boolean value indicating whether show axis guides within interior ternary. default FALSE. axis_label_size numeric value adjust size axis labels ternary plot. default size 4. vertex_label_size numeric value adjust size vertex labels ternary plot. default size 5. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional ternary diagrams at functional group level — grouped_ternary","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional ternary diagrams at functional group level — grouped_ternary","text":"","code":"library(DImodels) library(dplyr) data(sim3) m1 <- DI(y = \"response\", prop = paste0(\"p\", 1:9),          DImodel = \"AV\", data = sim3) %>%          suppressWarnings() #> Fitted model: Average interactions 'AV' DImodel  ## We have nine (p1 to p9) variables here and using `conditional_ternary` ## to visualise the simplex space won't be very helpful as there are too ## variables to condition on ## Instead we group the nine-variables into three groups called \"G\", \"L\" and \"H\" grouped_ternary(model = m1, FG = c(\"G\",\"G\",\"G\",\"G\",\"G\",\"L\",\"L\",\"H\",\"H\"),                 resolution = 1) #> Warning: The proportional split of species in the groups was not specified in `values`. #> Assuming an equal split for species in each group. #> ✔ Finished data preparation. #> ✔ Created plot.  ## By default the variables within a group take up an equal share of the ## group proportion. So for example, each point along the above ternary ## would have a 50:50 split of the variables in the group \"L\" or \"H\", thus ## the vertex where \"L\" is 1, would mean that p6 and p7 are 0.5 each, ## similarly, the vertex \"H\" is made up of 0.5 of p8 and p9 while the \"G\" ## vertex is comprised of 0.2 of each of p1, p2, p3, p4, and p5. The concepts ## also extend to points along the edges and interior of the ternary.  ## We can also manually specify the split of the species within a group ## This would mean we are looking at a different slice of the simplex ## For example this would mean the groups \"L\" group is made up of 100% of ## p7 and doesn't contain any p6, while \"H\" group contains 30% of p8 and ## 70% of p9, while \"G\" group still contains 20% of each p1 to p5. grouped_ternary(m1, FG = c(\"G\",\"G\",\"G\",\"G\",\"G\",\"L\",\"L\",\"H\",\"H\"),                 resolution = 1,                 values = c(0.2, 0.2, 0.2, 0.2, 0.2,                            0, 1,                            0.3, 0.7)) #> ✔ Finished data preparation. #> ✔ Created plot.   ## If here are more than three groups then, we could condition some groups ## to have a fixed value while three groups are manipulated within a ternary ## The group \"G\" is now split into two groups \"G1\" and \"G2\" ## We can create conditional ternary diagram at the grouped level as well ## Notice the values going in `tern_vars` and `conditional` are names ## of the groups and not the original compositional variables grouped_ternary(m1, FG = c(\"G1\",\"G1\",\"G2\",\"G2\",\"G2\",\"L\",\"L\",\"H\",\"H\"),                 resolution = 1,                 tern_vars = c(\"G1\", \"L\", \"H\"),                 conditional = data.frame(\"G2\" = c(0, 0.25, 0.5))) #> Warning: The proportional split of species in the groups was not specified in `values`. #> Assuming an equal split for species in each group. #> ✔ Finished data preparation. #> ✔ Created plot.   ## Specify `plot = FALSE` to not create the plot but return the prepared data head(grouped_ternary(m1, FG = c(\"G1\",\"G1\",\"G2\",\"G2\",\"G2\",\"L\",\"L\",\"H\",\"H\"),                      resolution = 1, plot = FALSE,                      tern_vars = c(\"G1\", \"L\", \"H\"),                      conditional = data.frame(\"G2\" = c(0, 0.25, 0.5)))) #> Warning: The proportional split of species in the groups was not specified in `values`. #> Assuming an equal split for species in each group. #> ✔ Finished data preparation. #>   G1         L           H          .x .y p1 p2 p3 p4 p5        p6        p7 #> 1  0 1.0000000 0.000000000 0.000000000  0  0  0  0  0  0 0.5000000 0.5000000 #> 2  0 0.9949749 0.005025126 0.005025126  0  0  0  0  0  0 0.4974874 0.4974874 #> 3  0 0.9899497 0.010050251 0.010050251  0  0  0  0  0  0 0.4949749 0.4949749 #> 4  0 0.9849246 0.015075377 0.015075377  0  0  0  0  0  0 0.4924623 0.4924623 #> 5  0 0.9798995 0.020100503 0.020100503  0  0  0  0  0  0 0.4899497 0.4899497 #> 6  0 0.9748744 0.025125628 0.025125628  0  0  0  0  0  0 0.4874372 0.4874372 #>            p8          p9 G2 .Sp .Value .Facet    .Pred #> 1 0.000000000 0.000000000  0  G2      0 G2 = 0 7.351083 #> 2 0.002512563 0.002512563  0  G2      0 G2 = 0 7.388483 #> 3 0.005025126 0.005025126  0  G2      0 G2 = 0 7.425747 #> 4 0.007537688 0.007537688  0  G2      0 G2 = 0 7.462876 #> 5 0.010050251 0.010050251  0  G2      0 G2 = 0 7.499869 #> 6 0.012562814 0.012562814  0  G2      0 G2 = 0 7.536726  ## All other functionality from \\code{\\link{condtional_ternary_plot}} is ## available in this function too."},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Grouped ternary diagrams — grouped_ternary_data","title":"Grouped ternary diagrams — grouped_ternary_data","text":"helper function preparing underlying data creating grouped ternary diagrams proportions compositional variables combined groups visualised ternary diagram. useful multiple compositional variables can grouped together hierarchical grouping structure. example, grouping species ecosystem based functions perform, grouping political parties based national alliances. Grouping variables way allows us reduce dimensionality compositional data visualise . akin looking 2-d slice high dimensional simplex. relative proportions variable within group can adjust look different slices simplex. Looking multiple slices enable us create approximation response varies across original n-dimensional simplex. output function can passed grouped_ternary_plot function plot results.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grouped ternary diagrams — grouped_ternary_data","text":"","code":"grouped_ternary_data(   prop,   FG,   values = NULL,   tern_vars = NULL,   conditional = NULL,   add_var = list(),   resolution = 3,   prediction = TRUE,   ... )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grouped ternary diagrams — grouped_ternary_data","text":"prop character vector indicating model coefficients corresponding variable proportions. variables compositional nature (.e., proportions sum 1). FG character vector specifying groupings variables specified `prop`. values numeric vector specifying proportional split variables within group. default split group proportion equally variable group. tern_vars character vector giving names three variables shown ternary diagram. conditional data-frame describing names compositional variables respective values slice simplex space. format , example, follows: data.frame(\"p1\" = c(0, 0.5), \"p2\" = c(0.2, 0.1))  One figure created row `conditional` respective values specified variables. compositional variables specified `conditional` assumed 0. add_var list data-frame specifying values additional variables model proportions (.e. part simplex design). useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data. resolution number 1 10 describing resolution resultant graph. high value result higher definition figure cost computationally expensive. prediction logical value indicating whether pass final data `add_prediction` function append predictions data. Default value TRUE, often desirable make additional changes data making predictions, user can set FALSE manually call `add_prediction` function. ... Arguments passed add_prediction model regression model object used make predictions observations `data`. override `coefficients` specified. coefficients regression model available (fit R), regression coefficients model fit language can used calculate predictions. However, user ensure appropriate one--one positional mapping data columns coefficient values. , also provide variance-covariance matrix coefficients `vcov` parameter want associated CI prediction possible calculate confidence/prediction intervals using method. vcov regression coefficients specified, variance-covariance matrix coefficients can specified calculate associated confidence interval around prediction. Failure result confidence intervals returned. Ensure `coefficients` `vcov` positional mapping data. coeff_cols `coefficients` specified one--one positional mapping data-columns coefficient vector present. character string numeric index can specified reorder data columns match corresponding coefficient value respective data column. See \"Use model coefficients prediction\" section examples. conf.level confidence level calculating confidence/prediction intervals. Default 0.95. interval Type interval calculate: \"none\" (default) interval calculated. \"confidence\" Calculate confidence interval. \"prediction\" Calculate prediction interval.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grouped ternary diagrams — grouped_ternary_data","text":"data-frame containing compositional columns names specified         `FG` `prop` parameters along additional columns         specified `add_var` parameter following columns appended         end. .x x-projection points within ternary. .y y-projection points within ternary. .add_str_ID identifier column grouping cartesian product                       additional columns specified `add_var`                       parameter (`add_var` specified). .Sp identifier column specifying functional group along               high dimensional simplex sliced (              3 groups). .Value value (0 1) along direction functional                  group `.Sp` high dimensional simplex sliced. .Facet identifier column formed combining `.Sp` `.value`                  group observations within specific slice                  high dimensional simplex. .Pred predicted response observation.                 (`prediction` TRUE) .Lower lower limit prediction/confidence interval                  observation. .Upper upper limit prediction/confidence interval                  observation.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grouped ternary diagrams — grouped_ternary_data","text":"","code":"library(DImodels)  ## Load data data(sim3)  ## Fit model mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9)^2,            data = sim3)  ## Create data ## We have nine (p1 to p9) variables here and using \\code{\\link{conditional_ternary}} ## to visualise the simplex space won't be very helpful as there are too ## variables to condition on ## Instead we group the nine-variables into three groups called \"G\", \"L\" and \"H\" head(grouped_ternary_data(model = mod,                           prop = paste0(\"p\", 1:9),                           FG = c(\"G\",\"G\",\"G\",\"G\",\"G\",\"L\",\"L\",\"H\",\"H\"),                           resolution = 1)) #> Warning: The proportional split of species in the groups was not specified in `values`. #> Assuming an equal split for species in each group. #> ✔ Finished data preparation. #>   G         L           H          .x .y p1 p2 p3 p4 p5        p6        p7 #> 1 0 1.0000000 0.000000000 0.000000000  0  0  0  0  0  0 0.5000000 0.5000000 #> 2 0 0.9949749 0.005025126 0.005025126  0  0  0  0  0  0 0.4974874 0.4974874 #> 3 0 0.9899497 0.010050251 0.010050251  0  0  0  0  0  0 0.4949749 0.4949749 #> 4 0 0.9849246 0.015075377 0.015075377  0  0  0  0  0  0 0.4924623 0.4924623 #> 5 0 0.9798995 0.020100503 0.020100503  0  0  0  0  0  0 0.4899497 0.4899497 #> 6 0 0.9748744 0.025125628 0.025125628  0  0  0  0  0  0 0.4874372 0.4874372 #>            p8          p9    .Pred #> 1 0.000000000 0.000000000 7.493868 #> 2 0.002512563 0.002512563 7.517016 #> 3 0.005025126 0.005025126 7.540053 #> 4 0.007537688 0.007537688 7.562977 #> 5 0.010050251 0.010050251 7.585788 #> 6 0.012562814 0.012562814 7.608488  ## By default the variables within a group take up an equal share of the ## group proportion. So for example, each point along the above ternary ## would have a 50:50 split of the variables in the group \"L\" or \"H\", thus ## the vertex where \"L\" is 1, would mean that p6 and p7 are 0.5 each, ## similarly, the vertex \"H\" is made up of 0.5 of p8 and p9 while the \"G\" ## vertex is comprised of 0.2 of each of p1, p2, p3, p4, and p5. The concepts ## also extend to points along the edges and interior of the ternary.  ## Change the proportional split of species within an FG by using `values` ## `values` takes a numeric vector where the position of each element ## describes the proportion of the corresponding species within the ## corresponding FG ## For examples this vector describes, 2-% each of p1, p2, p3, p4 and p5, ## in G, 0% and 100% of p6 and p7, respectively in G2 and 30% and 70% of ## p8 and p9, respectively in G3. vals <- c(0.2, 0.2, 0.2, 0.2, 0.2,           0, 1,           0.3, 0.7) head(grouped_ternary_data(prop = paste0(\"p\", 1:9),                           FG = c(\"G\",\"G\",\"G\",\"G\",\"G\",\"L\",\"L\",\"H\",\"H\"),                           values = vals,                           resolution = 1,                           model = mod)) #> ✔ Finished data preparation. #>   G         L           H          .x .y p1 p2 p3 p4 p5 p6        p7 #> 1 0 1.0000000 0.000000000 0.000000000  0  0  0  0  0  0  0 1.0000000 #> 2 0 0.9949749 0.005025126 0.005025126  0  0  0  0  0  0  0 0.9949749 #> 3 0 0.9899497 0.010050251 0.010050251  0  0  0  0  0  0  0 0.9899497 #> 4 0 0.9849246 0.015075377 0.015075377  0  0  0  0  0  0  0 0.9849246 #> 5 0 0.9798995 0.020100503 0.020100503  0  0  0  0  0  0  0 0.9798995 #> 6 0 0.9748744 0.025125628 0.025125628  0  0  0  0  0  0  0 0.9748744 #>            p8          p9    .Pred #> 1 0.000000000 0.000000000 7.110611 #> 2 0.001507538 0.003517588 7.135017 #> 3 0.003015075 0.007035176 7.159316 #> 4 0.004522613 0.010552764 7.183509 #> 5 0.006030151 0.014070352 7.207595 #> 6 0.007537688 0.017587940 7.231576  ## Can also add any additional experimental structures ## Notice .add_str_ID in the data head(grouped_ternary_data(prop = paste0(\"p\", 1:9),                           FG = c(\"G\",\"G\",\"G\",\"G\",\"G\",\"L\",\"L\",\"H\",\"H\"),                           add_var = list(\"treatment\" = c(\"50\", \"150\")),                           values = vals,                           model = mod,                           resolution = 1)) #> ✔ Finished data preparation. #>   G         L           H          .x .y p1 p2 p3 p4 p5 p6        p7 #> 1 0 1.0000000 0.000000000 0.000000000  0  0  0  0  0  0  0 1.0000000 #> 2 0 0.9949749 0.005025126 0.005025126  0  0  0  0  0  0  0 0.9949749 #> 3 0 0.9899497 0.010050251 0.010050251  0  0  0  0  0  0  0 0.9899497 #> 4 0 0.9849246 0.015075377 0.015075377  0  0  0  0  0  0  0 0.9849246 #> 5 0 0.9798995 0.020100503 0.020100503  0  0  0  0  0  0  0 0.9798995 #> 6 0 0.9748744 0.025125628 0.025125628  0  0  0  0  0  0  0 0.9748744 #>            p8          p9 treatment   .add_str_ID    .Pred #> 1 0.000000000 0.000000000        50 treatment: 50 7.110611 #> 2 0.001507538 0.003517588        50 treatment: 50 7.135017 #> 3 0.003015075 0.007035176        50 treatment: 50 7.159316 #> 4 0.004522613 0.010552764        50 treatment: 50 7.183509 #> 5 0.006030151 0.014070352        50 treatment: 50 7.207595 #> 6 0.007537688 0.017587940        50 treatment: 50 7.231576  ## It could be desirable to take the output of this function and add ## additional variables to the data before making predictions ## Use `prediction = FALSE` to get data without any predictions grouped_data <- grouped_ternary_data(prop = paste0(\"p\", 1:9),                                      FG = c(\"G\",\"G\",\"G\",\"G\",\"G\",\"L\",\"L\",\"H\",\"H\"),                                      values = vals,                                      resolution = 1,                                      prediction = FALSE) #> ✔ Finished data preparation. grouped_data$treatment <- 250 # Add predictions head(add_prediction(data = grouped_data, model = mod)) #>   G         L           H          .x .y p1 p2 p3 p4 p5 p6        p7 #> 1 0 1.0000000 0.000000000 0.000000000  0  0  0  0  0  0  0 1.0000000 #> 2 0 0.9949749 0.005025126 0.005025126  0  0  0  0  0  0  0 0.9949749 #> 3 0 0.9899497 0.010050251 0.010050251  0  0  0  0  0  0  0 0.9899497 #> 4 0 0.9849246 0.015075377 0.015075377  0  0  0  0  0  0  0 0.9849246 #> 5 0 0.9798995 0.020100503 0.020100503  0  0  0  0  0  0  0 0.9798995 #> 6 0 0.9748744 0.025125628 0.025125628  0  0  0  0  0  0  0 0.9748744 #>            p8          p9 treatment    .Pred #> 1 0.000000000 0.000000000       250 7.110611 #> 2 0.001507538 0.003517588       250 7.135017 #> 3 0.003015075 0.007035176       250 7.159316 #> 4 0.004522613 0.010552764       250 7.183509 #> 5 0.006030151 0.014070352       250 7.207595 #> 6 0.007537688 0.017587940       250 7.231576"},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional ternary diagrams at functional group level — grouped_ternary_plot","title":"Conditional ternary diagrams at functional group level — grouped_ternary_plot","text":"helper function plotting grouped ternary diagrams. output `grouped_ternary_data` compositional variables combined groups passed visualised 2-d ternary diagram. useful multiple compositional variables can grouped together hierarchical grouping structure. example, grouping species ecosystem based functions perform, grouping political parties based national alliances.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional ternary diagrams at functional group level — grouped_ternary_plot","text":"","code":"grouped_ternary_plot(   data,   col_var = \".Pred\",   nlevels = 7,   colours = NULL,   lower_lim = NULL,   upper_lim = NULL,   tern_labels = colnames(data)[1:3],   contour_text = FALSE,   show_axis_labels = TRUE,   show_axis_guides = FALSE,   axis_label_size = 4,   vertex_label_size = 5,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional ternary diagrams at functional group level — grouped_ternary_plot","text":"data data-frame output `conditional_ternary_data` function. col_var column name containing variable used colouring contours points. default \".Pred\". nlevels number levels show contour map. colours character vector function specifying colours contour map points. number colours `nlevels` (`show = \"contours\"`).  default colours scheme terrain.colors() continuous variables extended version Okabe-Ito colour scale categorical variables. lower_lim number set custom lower limit contour (`show = \"contours\"`). default minimum prediction. upper_lim number set custom upper limit contour (`show = \"contours\"`). default maximum prediction. tern_labels character vector containing labels vertices ternary. default column names first three columns data, first column corresponding top vertex, second column corresponding left vertex third column corresponding right vertex ternary. contour_text boolean value indicating whether include labels contour lines showing values (`show = \"contours\"`). default FALSE. show_axis_labels boolean value indicating whether show axis labels along edges ternary. default TRUE. show_axis_guides boolean value indicating whether show axis guides within interior ternary. default FALSE. axis_label_size numeric value adjust size axis labels ternary plot. default size 4. vertex_label_size numeric value adjust size vertex labels ternary plot. default size 5. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional ternary diagrams at functional group level — grouped_ternary_plot","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/grouped_ternary_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional ternary diagrams at functional group level — grouped_ternary_plot","text":"","code":"library(DImodels)  ## Load data data(sim3)  ## Fit model mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9)^2,            data = sim3)  ## Create data ## We have nine (p1 to p9) variables here and using conditional_ternary ## to visualise the simplex space won't be very helpful as there are too ## variables to condition on ## Instead we group the nine-variables into three groups called \"G\", \"L\" and \"H\" plot_data <- grouped_ternary_data(model = mod,                                   prop = paste0(\"p\", 1:9),                                   FG = c(\"G\",\"G\",\"G\",\"G\",\"G\",\"L\",\"L\",\"H\",\"H\"),                                   resolution = 1) #> Warning: The proportional split of species in the groups was not specified in `values`. #> Assuming an equal split for species in each group. #> ✔ Finished data preparation. grouped_ternary_plot(plot_data) #> ✔ Created plot.   ## By default the variables within a group take up an equal share of the ## group proportion. So for example, each point along the above ternary ## would have a 50:50 split of the variables in the group \"L\" or \"H\", thus ## the vertex where \"L\" is 1, would mean that p6 and p7 are 0.5 each, ## similarly, the vertex \"H\" is made up of 0.5 of p8 and p9 while the \"G\" ## vertex is comprised of 0.2 of each of p1, p2, p3, p4, and p5. The concepts ## also extend to points along the edges and interior of the ternary.  ## Change the proportional split of species within an FG by using `values` ## `values` takes a numeric vector where the position of each element ## describes the proportion of the corresponding species within the ## corresponding FG ## For examples this vector describes, 2-% each of p1, p2, p3, p4 and p5, ## in G, 0% and 100% of p6 and p7, respectively in G2 and 30% and 70% of ## p8 and p9, respectively in G3. vals <- c(0.2, 0.2, 0.2, 0.2, 0.2,           0, 1,           0.3, 0.7) plot_data <- grouped_ternary_data(prop = paste0(\"p\", 1:9),                                   FG = c(\"G\",\"G\",\"G\",\"G\",\"G\",\"L\",\"L\",\"H\",\"H\"),                                   values = vals,                                   resolution = 1,                                   model = mod) #> ✔ Finished data preparation. ## Change number of contours and colour scheme grouped_ternary_plot(plot_data,                      nlevels = 8,                      colours = hcl.colors(8)) #> ✔ Created plot.   ## Can also add any additional experimental structures ## Notice .add_str_ID in the data plot_data <- grouped_ternary_data(prop = paste0(\"p\", 1:9),                                   FG = c(\"G\",\"G\",\"G\",\"G\",\"G\",\"L\",\"L\",\"H\",\"H\"),                                   add_var = list(\"treatment\" = c(\"50\", \"150\")),                                   values = vals,                                   model = mod,                                   resolution = 1) #> ✔ Finished data preparation. grouped_ternary_plot(data = plot_data) #> ✔ Created all plots."},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Regression diagnostics plots with pie-glyphs — model_diagnostics","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics","text":"function returns regression diagnostics plots model points replaced pie-glyphs making easier track various data points plots. useful models compositional predictors quickly identify observations unusual residuals, hat values, etc.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics","text":"","code":"model_diagnostics(   model,   which = c(1, 2, 3, 5),   prop = NULL,   FG = NULL,   npoints = 3,   cook_levels = c(0.5, 1),   pie_radius = 0.2,   pie_colours = NULL,   only_extremes = FALSE,   label_size = 4,   points_size = 3,   plot = TRUE,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics","text":"model statistical regression model object fit using lm, glm, nlme functions, etc. subset numbers 1 6, default 1, 2, 3, 5, referring  1 - \"Residuals vs Fitted\", aka \"Tukey-Anscombe\" plot  2 - \"Normal Q-Q\" plot, enhanced qqnorm(resid(.))  3 - \"Scale-Location\"  4 - \"Cook's distance\"  5 - \"Residuals vs Leverage\"  6 - \"Cook's dist vs Lev./(1-Lev.)\" Note: specified model object inherit lm class, might possible create diagnostics plots. cases, user notified plots created. prop character vector giving names columns containing proportions show pie-glyphs. specified, black points (geom_point) shown observation model. Note: \\code{prop} can left blank interpreted model Diversity-Interactions (DI) model object fit using DI() function DImodels package. FG character vector length prop specifying group variable belongs . npoints Number points labelled plot, starting extreme (points highest absolute residuals hat values). cook_levels numeric vector specifying levels Cook's distance draw contours. pie_radius numeric value specifying radius (cm) pie-glyphs. pie_colours character vector specifying colours slices within pie-glyphs. only_extremes logical value indicating whether show pie-glyphs extreme observations (points highest absolute residuals hat values). label_size numeric value specifying size labels identifying extreme observations. points_size numeric value specifying size points (pie-glyphs shown) shown plots. plot boolean variable indicating whether create plot return prepared data instead. default TRUE creates plot FALSE return prepared data plotting. useful user wants modify data first create plot. nrow Number rows arrange final plot. ncol Number columns arrange final plot.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics","text":"ggmultiplot (ggplot single plot returned) class object data-frame (plot = FALSE).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics","text":"","code":"library(DImodels)  ## Load data data(sim1)  ## Fit model mod1 <- lm(response ~ 0 + (p1 + p2 + p3 + p4)^2, data = sim1)  ## Get diagnostics plot ## Recommend to store plot in a variable, to access individual plots later diagnostics <- model_diagnostics(mod1, prop = c(\"p1\", \"p2\", \"p3\", \"p4\")) #> ✔ Created all plots. print(diagnostics)   ## Access individual plots print(diagnostics[[1]])  print(diagnostics[[4]])   ## Change plot arrangement # \\donttest{ model_diagnostics(mod1, prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                   which = c(1, 3), nrow = 2, ncol = 1) #> ✔ Created all plots.  # }  ## Show only extreme points as pie-glyphs to avoid overplotting model_diagnostics(mod1, prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                   which = 2, npoints = 5, only_extremes = TRUE) #> ✔ Created all plots.   ## If model is a DImodels object, the don't need to specify prop DI_mod <- DI(y = \"response\", prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),              DImodel = \"FULL\", data = sim1) #> Fitted model: Separate pairwise interactions 'FULL' DImodel model_diagnostics(DI_mod, which = 1) #> ✔ Created all plots.   ## Specify `plot = FALSE` to not create the plot but return the prepared data head(model_diagnostics(DI_mod, which = 1, plot  = FALSE)) #>   response p1_ID p2_ID p3_ID p4_ID p1:p2 p1:p3 p1:p4 p2:p3 p2:p4 p3:p4  p1  p2 #> 1   10.815   0.7   0.1   0.1   0.1  0.07  0.07  0.07  0.01  0.01  0.01 0.7 0.1 #> 2   11.232   0.7   0.1   0.1   0.1  0.07  0.07  0.07  0.01  0.01  0.01 0.7 0.1 #> 3   10.192   0.7   0.1   0.1   0.1  0.07  0.07  0.07  0.01  0.01  0.01 0.7 0.1 #> 4    8.157   0.7   0.1   0.1   0.1  0.07  0.07  0.07  0.01  0.01  0.01 0.7 0.1 #> 5    6.724   0.1   0.7   0.1   0.1  0.07  0.01  0.01  0.07  0.07  0.01 0.1 0.7 #> 6   11.093   0.1   0.7   0.1   0.1  0.07  0.01  0.01  0.07  0.07  0.01 0.1 0.7 #>    p3  p4 community block       .hat   .sigma      .cooksd  .fitted     .resid #> 1 0.1 0.1         1     1 0.07512992 1.343832 0.0005750445 10.47436  0.3406361 #> 2 0.1 0.1         1     2 0.07512992 1.340067 0.0028447324 10.47436  0.7576361 #> 3 0.1 0.1         1     3 0.07512992 1.344130 0.0003951286 10.47436 -0.2823639 #> 4 0.1 0.1         1     4 0.07512992 1.299979 0.0266139030 10.47436 -2.3173639 #> 5 0.1 0.1         2     1 0.07512992 1.238479 0.0616767948 10.25177 -3.5277748 #> 6 0.1 0.1         2     2 0.07512992 1.338966 0.0035070720 10.25177  0.8412252 #>    .stdresid Obs Label         .qq weights #> 1  0.2660631   1     1  0.06270678       1 #> 2  0.5917723   2     2  0.45376219       1 #> 3 -0.2205480   3     3 -0.31863936       1 #> 4 -1.8100401   4     4 -1.73166440       1 #> 5 -2.7554644   5     5 -2.39397980       1 #> 6  0.6570619   6     6  0.54852228       1"},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Data preparation for regression diagnostics plots with pie-glyphs — model_diagnostics_data","title":"Data preparation for regression diagnostics plots with pie-glyphs — model_diagnostics_data","text":"function prepares data-frame necessary attributes creating regression diagnostics plots model compositional predictors points replaced pie-glyphs making easier track various data points plots. output data-frame can passed model_diagnostics_plot create visualisation.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data preparation for regression diagnostics plots with pie-glyphs — model_diagnostics_data","text":"","code":"model_diagnostics_data(model, prop = NULL)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data preparation for regression diagnostics plots with pie-glyphs — model_diagnostics_data","text":"model statistical regression model object fit using lm, glm, nlme functions, etc. prop character vector giving names compositional predictors model. specified plots prepared using data contain pie-glyphs.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data preparation for regression diagnostics plots with pie-glyphs — model_diagnostics_data","text":"original data used fitting model response         model predictors along following additional columns .hat Diagonal hat matrix. .sigma Estimate residual standard deviation corresponding observation dropped model. .cooksd cook's distance (cooks.distance()) observation. .fitted Fitted values model. .resid residuals observations. .stdresid standardised (Pearson) residuals observations. Obs unique identifier observation. Label labels displayed besides observations plot. .qq quantile values standardised residuals generated using qqnorm(). weights weights observation model (useful context weighted regression).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data preparation for regression diagnostics plots with pie-glyphs — model_diagnostics_data","text":"","code":"library(DImodels)  ## Load data data(sim1)  ## Fit model mod1 <- lm(response ~ 0 + (p1 + p2 + p3 + p4)^2, data = sim1)  ## Get data for diagnostics plot diagnostics_data <- model_diagnostics_data(mod1,                                            prop = c(\"p1\", \"p2\", \"p3\", \"p4\")) print(head(diagnostics_data)) #>   response  p1  p2  p3  p4       .hat   .sigma      .cooksd  .fitted     .resid #> 1   10.815 0.7 0.1 0.1 0.1 0.07512992 1.343832 0.0005750445 10.47436  0.3406361 #> 2   11.232 0.7 0.1 0.1 0.1 0.07512992 1.340067 0.0028447324 10.47436  0.7576361 #> 3   10.192 0.7 0.1 0.1 0.1 0.07512992 1.344130 0.0003951286 10.47436 -0.2823639 #> 4    8.157 0.7 0.1 0.1 0.1 0.07512992 1.299979 0.0266139030 10.47436 -2.3173639 #> 5    6.724 0.1 0.7 0.1 0.1 0.07512992 1.238479 0.0616767948 10.25177 -3.5277748 #> 6   11.093 0.1 0.7 0.1 0.1 0.07512992 1.338966 0.0035070720 10.25177  0.8412252 #>    .stdresid Obs Label         .qq #> 1  0.2660631   1     1  0.06270678 #> 2  0.5917723   2     2  0.45376219 #> 3 -0.2205480   3     3 -0.31863936 #> 4 -1.8100401   4     4 -1.73166440 #> 5 -2.7554644   5     5 -2.39397980 #> 6  0.6570619   6     6  0.54852228  ## The compositional predictors in the data are added as attributes to the data attr(diagnostics_data, \"prop\") #> [1] \"p1\" \"p2\" \"p3\" \"p4\""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Regression diagnostics plots with pie-glyphs — model_diagnostics_plot","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics_plot","text":"function accepts output model_diagnostics_data function returns regression diagnostics plots model points replaced pie-glyphs making easier track various data points plots. useful models compositional predictors quickly identify observations unusual residuals, hat values, etc.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics_plot","text":"","code":"model_diagnostics_plot(   data,   which = c(1, 2, 3, 5),   prop = NULL,   FG = NULL,   npoints = 3,   cook_levels = c(0.5, 1),   pie_radius = 0.2,   pie_colours = NULL,   only_extremes = FALSE,   label_size = 4,   points_size = 3,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics_plot","text":"data data-frame containing model-fit statistics regression model. data prepared using `model_diagnostics_data` function, created manually user necessary information stored respective columns. subset numbers 1 6, default 1, 2, 3, 5, referring  1 - \"Residuals vs Fitted\", aka \"Tukey-Anscombe\" plot  2 - \"Normal Q-Q\" plot, enhanced qqnorm(resid(.))  3 - \"Scale-Location\"  4 - \"Cook's distance\"  5 - \"Residuals vs Leverage\"  6 - \"Cook's dist vs Lev./(1-Lev.)\" Note: specified model object inherit lm class, might possible create diagnostics plots. cases, user notified plots created. prop character vector giving names columns containing proportions show pie-glyphs. specified, black points (geom_point) shown observation model. Note: \\code{prop} can left blank interpreted model Diversity-Interactions (DI) model object fit using DI() function DImodels package. FG character vector length prop specifying group variable belongs . npoints Number points labelled plot, starting extreme (points highest absolute residuals hat values). cook_levels numeric vector specifying levels Cook's distance draw contours. pie_radius numeric value specifying radius (cm) pie-glyphs. pie_colours character vector specifying colours slices within pie-glyphs. only_extremes logical value indicating whether show pie-glyphs extreme observations (points highest absolute residuals hat values). label_size numeric value specifying size labels identifying extreme observations. points_size numeric value specifying size points (pie-glyphs shown) shown plots. nrow Number rows arrange final plot. ncol Number columns arrange final plot.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics_plot","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_diagnostics_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regression diagnostics plots with pie-glyphs — model_diagnostics_plot","text":"","code":"library(DImodels)  ## Load data data(sim1)  ## Fit model mod1 <- lm(response ~ 0 + (p1 + p2 + p3 + p4)^2, data = sim1)  ## Get data for diagnostics plot diagnostics_data <- model_diagnostics_data(mod1,                                            prop = c(\"p1\", \"p2\", \"p3\", \"p4\"))  ## Create diagnostics plots diagnostics <- model_diagnostics_plot(diagnostics_data) #> ✔ Created all plots. print(diagnostics)   ## Access individual plots print(diagnostics[[1]])  print(diagnostics[[4]])   ## Change plot arrangement model_diagnostics_plot(diagnostics_data, which = c(1, 3),                        nrow = 2, ncol = 1) #> ✔ Created all plots.   ## Show only extreme points as pie-glyphs to avoid overplotting model_diagnostics_plot(diagnostics_data, which = 2,                        npoints = 3, only_extremes = TRUE) #> ✔ Created all plots.   ## Change size and colours of pie_glyphs model_diagnostics_plot(diagnostics_data, which = 2,                        npoints = 3, only_extremes = TRUE,                        pie_radius = 0.3,                        pie_colours = c(\"gold\", \"steelblue\", \"tomato\", \"darkgrey\")) #> ✔ Created all plots."},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualising model selection — model_selection","title":"Visualising model selection — model_selection","text":"function helps visualise model selection showing visual comparison information criteria different models. also possible visualise breakup information criteria deviance (goodness--fit) penalty terms model. aid understanding parsimonious model preferable complex model.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualising model selection — model_selection","text":"","code":"model_selection(   models,   metric = c(\"AIC\", \"BIC\", \"AICc\", \"BICc\", \"deviance\"),   sort = FALSE,   breakup = FALSE,   plot = TRUE,   model_names = names(models) )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualising model selection — model_selection","text":"models List statistical regression model objects. metric Metric used comparisons models. Takes values c(\"AIC\", \"BIC\", \"AICc\", \"BICc\", \"logLik\"). Can choose single multiple metrics comparing different models. sort boolean value indicating whether sort model highest lowest value chosen metric. breakup boolean value indicating whether breakup metric value deviance (defined -2*loglikelihood) penalty components. work single metric \"AIC\", \"AICc\", \"BIC\", \"BICc\" chosen plot. plot boolean variable indicating whether create plot return prepared data instead. default `TRUE` creates plot `FALSE` return prepared data plotting. useful user wants modify data first call plotting model_names character string describing names display X-axis model order appear models parameter.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualising model selection — model_selection","text":"ggplot object data-frame (`plot == FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualising model selection — model_selection","text":"","code":"library(DImodels)  ## Load data data(sim2)  ## Fit different DI models mod_AV <- DI(prop = 3:6, DImodel = \"AV\", data = sim2, y = \"response\") #> Fitted model: Average interactions 'AV' DImodel mod_FULL <- DI(prop = 3:6, DImodel = \"FULL\", data = sim2, y = \"response\") #> Fitted model: Separate pairwise interactions 'FULL' DImodel mod_FG <- DI(prop = 3:6, DImodel = \"FG\", FG = c(\"G\",\"G\",\"L\",\"L\"),              data = sim2, y = \"response\") #> Fitted model: Functional group effects 'FG' DImodel mod_AV_theta <- DI(prop = 3:6, DImodel = \"AV\", data = sim2,                    y = \"response\", estimate_theta = TRUE) #> Fitted model: Average interactions 'AV' DImodel #> Theta estimate: 0.4533 mod_FULL_theta <- DI(prop = 3:6, DImodel = \"FULL\", data = sim2,                      y = \"response\", estimate_theta = TRUE) #> Fitted model: Separate pairwise interactions 'FULL' DImodel #> Theta estimate: 0.4525 mod_FG_theta <- DI(prop = 3:6, DImodel = \"FG\", FG = c(\"G\",\"G\",\"L\",\"L\"),                    data = sim2, y = \"response\", estimate_theta = TRUE) #> Fitted model: Functional group effects 'FG' DImodel #> Theta estimate: 0.4529  models_list <- list(\"AV model\" = mod_AV, \"Full model\" = mod_FULL,                     \"FG model\" = mod_FG, \"AV model_t\" = mod_AV_theta,                     \"Full model_t\" = mod_FULL_theta,                     \"FG model_t\" = mod_FG_theta)  ## Specific metric model_selection(models = models_list,                 metric = c(\"AIC\"))   ## Multiple metrics can be plotted together as well model_selection(models = models_list,                 metric = c(\"AIC\", \"BIC\"))   ## If single metric is specified then breakup of metric ## between goodness of fit and penalty can also be visualised model_selection(models = models_list,                 metric = c(\"AICc\"),                 breakup = TRUE)   ## Sort models model_selection(models = models_list,                 metric = c(\"AICc\"),                 breakup = TRUE, sort = TRUE)   ## If multiple metrics are specified then sorting ## will be done on first metric specified in list (AIC in this case) model_selection(models = models_list,                 metric = c(\"AIC\", \"BIC\", \"AICc\", \"BICc\"), sort = TRUE)   ## If the list specified in models is not named then ## By default the labels on the X-axis for the models will be ## created by assigning a unique ID to each model sequentially ## in the order they appear in the models object names(models_list) <- NULL model_selection(models = models_list,                 metric = c(\"AIC\", \"BIC\", \"AICc\"), sort = TRUE) #> → The list of models specified in `models` is not named. #> → They are given numeric identifiers in the order they appear in the `models` #>   parameter. #> → If this is not desirable consider providing names for the models in the #>   `model_names` parameter.   ## When possible the variables names of objects containing the ## individual models would be used as axis labels model_selection(models = list(mod_AV, mod_FULL, mod_FG,                               mod_AV_theta, mod_FULL_theta, mod_FG_theta),                 metric = c(\"AIC\", \"BIC\"), sort = TRUE) #> → The list of models specified in `models` is not named. #> → The models are given the same names as the variables they were stored in. #> → If this is not desirable consider providing names for the models in the #>   `model_names` parameter.   ## If neither of these two situations are desirable custom labels ## for each model can be specified using the model_names parameter model_selection(models = list(mod_AV, mod_FULL, mod_FG,                               mod_AV_theta, mod_FULL_theta, mod_FG_theta),                 metric = c(\"AIC\", \"BIC\"), sort = TRUE,                 model_names = c(\"AV model\", \"Full model\", \"FG model\",                                 \"AV theta\", \"Full theta\", \"FG theta\"))   ## Specify `plot = FALSE` to not create the plot but return the prepared data head(model_selection(models = list(mod_AV, mod_FULL, mod_FG,                                    mod_AV_theta, mod_FULL_theta, mod_FG_theta),                      metric = c(\"AIC\", \"BIC\"), sort = TRUE, plot = FALSE,                      model_names = c(\"AV model\", \"Full model\", \"FG model\",                                      \"AV theta\", \"Full theta\", \"FG theta\"))) #> # A tibble: 6 × 9 #>   model_name deviance logLik   AIC   BIC  AICc  BICc Component Value #>   <fct>         <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <fct>     <dbl> #> 1 AV theta      104.    203.  217.  232.  220.  237. AIC        217. #> 2 AV theta      104.    203.  217.  232.  220.  237. BIC        232. #> 3 FG theta      102.    202.  220.  239.  224   247. AIC        220. #> 4 FG theta      102.    202.  220.  239.  224   247. BIC        239. #> 5 Full theta     99.0   200.  224.  249.  231.  263. AIC        224. #> 6 Full theta     99.0   200.  224.  249.  231.  263. BIC        249."},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare data for visualising model selection — model_selection_data","title":"Prepare data for visualising model selection — model_selection_data","text":"data preparation function visualising model selection. output function can passed model_selection_plot function showing visual comparison information criteria different models. also possible visualise breakup information criteria deviance (goodness--fit) penalty terms model.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare data for visualising model selection — model_selection_data","text":"","code":"model_selection_data(   models,   metric = c(\"AIC\", \"BIC\", \"AICc\", \"BICc\", \"deviance\"),   sort = FALSE,   breakup = FALSE,   model_names = names(models) )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare data for visualising model selection — model_selection_data","text":"models List statistical regression model objects. metric Metric used comparisons models. Takes values c(\"AIC\", \"BIC\", \"AICc\", \"BICc\", \"logLik\"). Can choose single multiple metrics comparing different models. sort boolean value indicating whether sort model highest lowest value chosen metric. breakup boolean value indicating whether breakup metric value deviance (defined -2*loglikelihood) penalty components. work single metric \"AIC\", \"AICc\", \"BIC\", \"BICc\" chosen plot. model_names character string describing names display X-axis model order appear models parameter.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare data for visualising model selection — model_selection_data","text":"data-frame multiple columns containing values several         information criteria model specified `models`. model_name identifier name model object shown X-axis. deviance deviance values model object. logLik -2*Log-Likelihood values model object. AIC Akaike information criteria (AIC) values model object. BIC Bayesian information criteria (BIC) values model object. AICc corrected AIC (AICc) values model object. BICc corrected BIC (BICc) values model object. Component names components shown plot. Value values components shown plot.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare data for visualising model selection — model_selection_data","text":"","code":"## Fit different candidate models mod1 <- lm(mpg ~ disp, data = mtcars) mod2 <- lm(mpg ~ disp + hp, data = mtcars) mod3 <- lm(mpg ~ disp + hp + wt, data = mtcars) mod4 <- lm(mpg ~ disp + hp + wt + carb, data = mtcars)  ## Group models into list models_list <- list(\"Model 1\" = mod1, \"Model 2\" = mod2,                     \"Model 3\" = mod3, \"Model 4\" = mod4)  ## Prepare data for visualisation ## Specific metric model_selection_data(models = models_list,                      metric = c(\"AIC\")) #> # A tibble: 4 × 9 #>   model_name deviance logLik   AIC   BIC  AICc  BICc Component Value #>   <fct>         <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <fct>     <dbl> #> 1 Model 1        317.   164.  170.  175.  171.  176. AIC        170. #> 2 Model 2        283.   161.  169.  174.  170.  177. AIC        169. #> 3 Model 3        195.   149.  159.  166.  161.  170. AIC        159. #> 4 Model 4        194.   148.  161.  169.  164.  175. AIC        161.  ## Multiple metrics can be plotted together as well model_selection_data(models = models_list,                      metric = c(\"AIC\", \"BIC\")) #> # A tibble: 8 × 9 #>   model_name deviance logLik   AIC   BIC  AICc  BICc Component Value #>   <fct>         <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <fct>     <dbl> #> 1 Model 1        317.   164.  170.  175.  171.  176. AIC        170. #> 2 Model 1        317.   164.  170.  175.  171.  176. BIC        175. #> 3 Model 2        283.   161.  169.  174.  170.  177. AIC        169. #> 4 Model 2        283.   161.  169.  174.  170.  177. BIC        174. #> 5 Model 3        195.   149.  159.  166.  161.  170. AIC        159. #> 6 Model 3        195.   149.  159.  166.  161.  170. BIC        166. #> 7 Model 4        194.   148.  161.  169.  164.  175. AIC        161. #> 8 Model 4        194.   148.  161.  169.  164.  175. BIC        169.  ## If single metric is specified then breakup of metric ## between goodness of fit and penalty can also be visualised model_selection_data(models = models_list,                      metric = c(\"AICc\"),                      breakup = TRUE) #> # A tibble: 8 × 9 #>   model_name deviance logLik   AIC   BIC  AICc  BICc Component        Value #>   <fct>         <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <chr>            <dbl> #> 1 Model 1        317.   164.  170.  175.  171.  176. Goodness of fit 164.   #> 2 Model 1        317.   164.  170.  175.  171.  176. Penalty           6.87 #> 3 Model 2        283.   161.  169.  174.  170.  177. Goodness of fit 161.   #> 4 Model 2        283.   161.  169.  174.  170.  177. Penalty           9.48 #> 5 Model 3        195.   149.  159.  166.  161.  170. Goodness of fit 149.   #> 6 Model 3        195.   149.  159.  166.  161.  170. Penalty          12.3  #> 7 Model 4        194.   148.  161.  169.  164.  175. Goodness of fit 148.   #> 8 Model 4        194.   148.  161.  169.  164.  175. Penalty          15.4   ## Sort models model_selection_data(models = models_list,                      metric = c(\"AICc\"),                      breakup = TRUE, sort = TRUE) #> # A tibble: 8 × 9 #>   model_name deviance logLik   AIC   BIC  AICc  BICc Component        Value #>   <fct>         <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <chr>            <dbl> #> 1 Model 3        195.   149.  159.  166.  161.  170. Goodness of fit 149.   #> 2 Model 3        195.   149.  159.  166.  161.  170. Penalty          12.3  #> 3 Model 4        194.   148.  161.  169.  164.  175. Goodness of fit 148.   #> 4 Model 4        194.   148.  161.  169.  164.  175. Penalty          15.4  #> 5 Model 2        283.   161.  169.  174.  170.  177. Goodness of fit 161.   #> 6 Model 2        283.   161.  169.  174.  170.  177. Penalty           9.48 #> 7 Model 1        317.   164.  170.  175.  171.  176. Goodness of fit 164.   #> 8 Model 1        317.   164.  170.  175.  171.  176. Penalty           6.87  ## If multiple metrics are specified then sorting ## will be done on first metric specified in list (AIC in this case) model_selection_data(models = models_list,                      metric = c(\"AIC\", \"BIC\", \"AICc\", \"BICc\"), sort = TRUE) #> # A tibble: 16 × 9 #>    model_name deviance logLik   AIC   BIC  AICc  BICc Component Value #>    <fct>         <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <fct>     <dbl> #>  1 Model 3        195.   149.  159.  166.  161.  170. AIC        159. #>  2 Model 3        195.   149.  159.  166.  161.  170. BIC        166. #>  3 Model 3        195.   149.  159.  166.  161.  170. AICc       161. #>  4 Model 3        195.   149.  159.  166.  161.  170. BICc       170. #>  5 Model 4        194.   148.  161.  169.  164.  175. AIC        161. #>  6 Model 4        194.   148.  161.  169.  164.  175. BIC        169. #>  7 Model 4        194.   148.  161.  169.  164.  175. AICc       164. #>  8 Model 4        194.   148.  161.  169.  164.  175. BICc       175. #>  9 Model 2        283.   161.  169.  174.  170.  177. AIC        169. #> 10 Model 2        283.   161.  169.  174.  170.  177. BIC        174. #> 11 Model 2        283.   161.  169.  174.  170.  177. AICc       170. #> 12 Model 2        283.   161.  169.  174.  170.  177. BICc       177. #> 13 Model 1        317.   164.  170.  175.  171.  176. AIC        170. #> 14 Model 1        317.   164.  170.  175.  171.  176. BIC        175. #> 15 Model 1        317.   164.  170.  175.  171.  176. AICc       171. #> 16 Model 1        317.   164.  170.  175.  171.  176. BICc       176."},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualise model selection — model_selection_plot","title":"Visualise model selection — model_selection_plot","text":"function accepts output model_selection_data function helps visualise model selection showing visual comparison information criteria different models. also possible visualise breakup information criteria deviance (goodness--fit) penalty terms model. aid understanding parsimonious model preferable complex model.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualise model selection — model_selection_plot","text":"","code":"model_selection_plot(data)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualise model selection — model_selection_plot","text":"data data-frame consisting information criteria different regression models. data prepared using `model_selection_data` function, created manually user necessary information stored respective columns.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualise model selection — model_selection_plot","text":"ggplot2 object","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/model_selection_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualise model selection — model_selection_plot","text":"","code":"## Fit different candidate models mod1 <- lm(mpg ~ disp, data = mtcars) mod2 <- lm(mpg ~ disp + hp, data = mtcars) mod3 <- lm(mpg ~ disp + hp + wt, data = mtcars) mod4 <- lm(mpg ~ disp + hp + wt + carb, data = mtcars)  ## Group models into list models_list <- list(\"Model 1\" = mod1, \"Model 2\" = mod2,                     \"Model 3\" = mod3, \"Model 4\" = mod4)  ## Prepare data for visualisation ## Specific metric plot_data1 <- model_selection_data(models = models_list,                                    metric = c(\"AIC\")) ## Visualise model_selection_plot(plot_data1)   ## Multiple metrics can be plotted together as well plot_data2 <- model_selection_data(models = models_list,                                    metric = c(\"AIC\", \"BIC\")) ## Visualise model_selection_plot(plot_data2)   ## If single metric is specified then breakup of metric ## between goodness of fit and penalty can also be visualised plot_data3 <- model_selection_data(models = models_list,                                    metric = c(\"AICc\"),                                    breakup = TRUE) ## Visualise model_selection_plot(plot_data3)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Model term contributions to predicted response — prediction_contributions","title":"Model term contributions to predicted response — prediction_contributions","text":"stacked bar_chart shown individual contributions (parameter estimate * predictor value) term statistical model stacked top another. total height stacked bar gives value predicted response. uncertainty around predicted response can also shown plot. wrapper function specifically designed statistical models fit using DI() function DImodels R package implicitly calls prediction_contributions_data followed prediction_contributions_plot. model object fit using DImodels, associated data plot functions can instead called manually.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model term contributions to predicted response — prediction_contributions","text":"","code":"prediction_contributions(   model,   data = NULL,   add_var = list(),   groups = list(),   conf.level = 0.95,   bar_labs = rownames(data),   colours = NULL,   se = FALSE,   FG = NULL,   interval = c(\"confidence\", \"prediction\", \"none\"),   bar_orientation = c(\"vertical\", \"horizontal\"),   facet_var = NULL,   plot = TRUE,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model term contributions to predicted response — prediction_contributions","text":"model Diversity Interactions model object fit using DI() function DImodels package. data user-defined data-frame containing values compositional variables along additional variables user wishes predict . left blank, selection observations (2 level richness) original data used fit model selected. add_var list specifying values additional predictor variables model independent compositional predictor variables. useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data arranged grid according value specified `nrow` `ncol`. groups list specifying groupings arrange coefficients . coefficients within group added together shown single component respective bars plot. useful grouping multiple similar terms single term better visibility. conf.level confidence level calculating confidence prediction intervals. bar_labs labels shown bar plot. user three options:    - default, row-names data used      labels bars.    - character string numeric index indicating ID      column data.    - character vector length number rows      data, manually specifies names bar. none three options available, function assign unique ID bar. colours character vector specifying colours contributions different coefficients. specified, default colour-scheme chosen, however might uninformative situations (examples manual groupings specified using `groups` parameter). se logical value indicating whether show prediction intervals predictions plot. FG higher level grouping compositional variables data. Variables belonging group assigned different shades colour. user can manually specify character vector giving group variable belongs . left empty function try get grouping original DI model object. interval Type interval calculate: \"none\" interval calculated. \"confidence\" (default) Calculate confidence interval. \"prediction\" Calculate prediction interval. bar_orientation One \"vertical\" \"horizontal\" indicating orientation bars. Defaults vertical orientation. facet_var character string numeric index identifying column data used faceting plot multiple panels. plot boolean variable indicating whether create plot return prepared data instead. default `TRUE` creates plot `FALSE` return prepared data plotting. useful user wants modify data first call plotting function manually. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model term contributions to predicted response — prediction_contributions","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model term contributions to predicted response — prediction_contributions","text":"","code":"#' ## Load DImodels package to fit the model library(DImodels)  ## Load data data(sim2)  ## Fit DI model model1 <- DI(prop = 3:6, DImodel = 'FULL', data = sim2, y = 'response') #> Fitted model: Separate pairwise interactions 'FULL' DImodel  ## Create visualisation ## If no communities are specified 2 communities at ## each level of richness from the original data are used prediction_contributions(model1) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Can also manually specify communities of interest my_comms <- data.frame(p1 = c(1, 0, 0,   0.5, 1/3, 0.25),                        p2 = c(0, 0, 0.5, 0,   1/3, 0.25),                        p3 = c(0, 1, 0.5, 0,   1/3, 0.25),                        p4 = c(0, 0, 0,   0.5, 0,   0.25))  prediction_contributions(model1, data = my_comms) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Group contributions to show as a single component on the plot prediction_contributions(model1, data = my_comms,                          groups = list(\"Interactions\" = c(\"`p1:p2`\", \"`p1:p3`\",                                                           \"`p1:p4`\", \"`p2:p3`\",                                                           \"`p2:p4`\", \"`p3:p4`\"))) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Add a prediction interval using `se = TRUE` and show bars horizontally prediction_contributions(model1, data = my_comms, se = TRUE,                          bar_orientation = \"horizontal\",                          groups = list(\"Interactions\" = c(\"`p1:p2`\", \"`p1:p3`\",                                                           \"`p1:p4`\", \"`p2:p3`\",                                                           \"`p2:p4`\", \"`p3:p4`\"))) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Facet the plot on any variable my_comms$richness <- c(1, 1, 2, 2, 3, 4) ## Use `facet_var` prediction_contributions(model1, data = my_comms, facet_var = \"richness\",                          bar_orientation = \"horizontal\",                          groups = list(\"Interactions\" = c(\"`p1:p2`\", \"`p1:p3`\",                                                           \"`p1:p4`\", \"`p2:p3`\",                                                           \"`p2:p4`\", \"`p3:p4`\"))) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Can also add additional variables independent of the simplex design ## to get a separate plot for unique combination of the variables prediction_contributions(model1, data = my_comms,                          add_var = list(\"block\" = factor(c(1, 2),                                                          levels = c(1, 2, 3, 4)))) #> ✔ Finished data preparation. #> ✔ Created all plots.   ## Manually specify colours and bar labels ## Model has 10 terms but we grouped 6 of them into 1 term, ## so we need to specify 5 colours (4 ungrouped terms + 1 grouped term) ## Bar labels can be specified using `bar_labs` ## Also, using nrow to arrange plots in rows prediction_contributions(model1, data = my_comms,                          colours = c(\"steelblue1\", \"steelblue4\",                                      \"orange\", \"orange4\",                                      \"grey\"),                          bar_labs = c(\"p1 Mono\", \"p3 Mono\", \"1/2 p2 p3\",                                       \"1/2 p1 p4\", \"1/3 p1 p2 p3\", \"Centroid\"),                          add_var = list(\"block\" = factor(c(1, 2),                                                          levels = c(1, 2, 3, 4))),                          nrow = 2,                          groups = list(\"Interactions\" = c(\"`p1:p2`\", \"`p1:p3`\",                                                           \"`p1:p4`\", \"`p2:p3`\",                                                           \"`p2:p4`\", \"`p3:p4`\"))) #> ✔ Finished data preparation. #> ✔ Created all plots.   ## Specify `plot = FALSE` to not create the plot but return the prepared data head(prediction_contributions(model1, data = my_comms, plot = FALSE,                               facet_var = \"richness\",                               bar_orientation = \"horizontal\")) #> ✔ Finished data preparation. #> # A tibble: 6 × 19 #>   .x_labs .Community     p1    p2    p3    p4 richness .Richness `p1:p2` `p1:p3` #>   <chr>   <fct>       <dbl> <dbl> <dbl> <dbl>    <dbl>     <dbl>   <dbl>   <dbl> #> 1 1       Community 1     1     0     0     0        1         1       0       0 #> 2 1       Community 1     1     0     0     0        1         1       0       0 #> 3 1       Community 1     1     0     0     0        1         1       0       0 #> 4 1       Community 1     1     0     0     0        1         1       0       0 #> 5 1       Community 1     1     0     0     0        1         1       0       0 #> 6 1       Community 1     1     0     0     0        1         1       0       0 #> # ℹ 9 more variables: `p1:p4` <dbl>, `p2:p3` <dbl>, `p2:p4` <dbl>, #> #   `p3:p4` <dbl>, .Pred <dbl>, .Lower <dbl>, .Upper <dbl>, #> #   .Contributions <chr>, .Value <dbl>"},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Model term contributions to predicted response — prediction_contributions_data","title":"Model term contributions to predicted response — prediction_contributions_data","text":"helper function preparing data split predicted response regression model contributions (predictor coefficient * predictor value) terms model. output function can passed `prediction_contributions_plot` function visualise results.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model term contributions to predicted response — prediction_contributions_data","text":"","code":"prediction_contributions_data(   data,   model = NULL,   coefficients = NULL,   coeff_cols = NULL,   vcov = NULL,   add_var = list(),   groups = list(),   conf.level = 0.95,   interval = c(\"confidence\", \"prediction\", \"none\"),   bar_labs = rownames(data) )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model term contributions to predicted response — prediction_contributions_data","text":"data user-defined data-frame containing values compositional variables along additional variables user wishes predict . left blank, selection observations (2 level richness) original data used fit model selected. model Diversity Interactions model object fit using DI() function DImodels package. coefficients regression model available (fit R), regression coefficients model fit language can used calculate predictions. However, user ensure appropriate one--one positional mapping data columns coefficient values. , also provide variance-covariance matrix coefficients `vcov` parameter want associated CI prediction possible calculate confidence/prediction intervals using method. coeff_cols `coefficients` specified one--one positional mapping data-columns coefficient vector present. character string numeric index can specified reorder data columns match corresponding coefficient value respective data column. See \"Use model coefficients prediction\" section examples. vcov regression coefficients specified, variance-covariance matrix coefficients can specified calculate associated confidence interval around prediction. Failure result confidence intervals returned. Ensure `coefficients` `vcov` positional mapping data. add_var list specifying values additional predictor variables model independent compositional predictor variables. useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data arranged grid according value specified `nrow` `ncol`. groups list specifying groupings arrange coefficients . coefficients within group added together shown single component respective bars plot. useful grouping multiple similar terms single term better visibility. conf.level confidence level calculating confidence prediction intervals. interval Type interval calculate: \"none\" interval calculated. \"confidence\" (default) Calculate confidence interval. \"prediction\" Calculate prediction interval. bar_labs labels shown bar plot. user three options:    - default, row-names data used      labels bars.    - character string numeric index indicating ID      column data.    - character vector length number rows      data, manually specifies names bar. none three options available, function assign unique ID bar.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model term contributions to predicted response — prediction_contributions_data","text":"data-frame following columns. additional columns used fitting model also present. .Community identifier column discern                      observation data. labels                      displayed bars plot. .add_str_ID identifier column grouping cartesian product                       additional columns specified `add_var`                       parameter (`add_var` specified). .Pred predicted repsonse observation. .Lower lower limit prediction interval                  observation. .Upper lower limit prediction interval                  observation. .Contributions identifier describing name                          coefficient contributing response. .Value contributed value respective coefficient/group                  total prediction.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model term contributions to predicted response — prediction_contributions_data","text":"","code":"library(DImodels) library(dplyr)  ## Load data data(sim2)  ## Fit model mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4)^2, data = sim2)  prediction_contributions_data(data = sim2[c(1,5,9,11), ],                               model = mod) #> ✔ Finished data preparation. #> # A tibble: 40 × 10 #>    .x_labs .Community  community block response .Pred .Lower .Upper #>    <chr>   <fct>           <int> <fct>    <dbl> <dbl>  <dbl>  <dbl> #>  1 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  2 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  3 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  4 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  5 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  6 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  7 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  8 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  9 1       Community 1         1 1         20.2  18.4   17.6   19.3 #> 10 1       Community 1         1 1         20.2  18.4   17.6   19.3 #> # ℹ 30 more rows #> # ℹ 2 more variables: .Contributions <chr>, .Value <dbl>  ## Specific coefficients can also be grouped together ## Either by their indices in the model coefficient vector prediction_contributions_data(data = sim2[c(1,5,9,11), ],                               model = mod,                               groups = list(\"Interactions\" = 5:10)) #> ✔ Finished data preparation. #> # A tibble: 20 × 10 #>    .x_labs .Community  community block response .Pred .Lower .Upper #>    <chr>   <fct>           <int> <fct>    <dbl> <dbl>  <dbl>  <dbl> #>  1 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  2 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  3 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  4 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  5 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  6 5       Community 2         2 1         17.2  17.5   16.7   18.4 #>  7 5       Community 2         2 1         17.2  17.5   16.7   18.4 #>  8 5       Community 2         2 1         17.2  17.5   16.7   18.4 #>  9 5       Community 2         2 1         17.2  17.5   16.7   18.4 #> 10 5       Community 2         2 1         17.2  17.5   16.7   18.4 #> 11 9       Community 3         3 1         17.9  16.6   15.8   17.5 #> 12 9       Community 3         3 1         17.9  16.6   15.8   17.5 #> 13 9       Community 3         3 1         17.9  16.6   15.8   17.5 #> 14 9       Community 3         3 1         17.9  16.6   15.8   17.5 #> 15 9       Community 3         3 1         17.9  16.6   15.8   17.5 #> 16 11      Community 4         3 3         17.6  16.6   15.8   17.5 #> 17 11      Community 4         3 3         17.6  16.6   15.8   17.5 #> 18 11      Community 4         3 3         17.6  16.6   15.8   17.5 #> 19 11      Community 4         3 3         17.6  16.6   15.8   17.5 #> 20 11      Community 4         3 3         17.6  16.6   15.8   17.5 #> # ℹ 2 more variables: .Contributions <chr>, .Value <dbl> ## Or by specifying the coefficient names as character strings prediction_contributions_data(data = sim2[c(1,5,9,11), ],                               model = mod,                               groups = list(\"p1_Ints\" = c(\"p1:p2\",                                                           \"p1:p3\",                                                           \"p1:p4\"))) #> ✔ Finished data preparation. #> # A tibble: 32 × 10 #>    .x_labs .Community  community block response .Pred .Lower .Upper #>    <chr>   <fct>           <int> <fct>    <dbl> <dbl>  <dbl>  <dbl> #>  1 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  2 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  3 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  4 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  5 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  6 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  7 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  8 1       Community 1         1 1         20.2  18.4   17.6   19.3 #>  9 5       Community 2         2 1         17.2  17.5   16.7   18.4 #> 10 5       Community 2         2 1         17.2  17.5   16.7   18.4 #> # ℹ 22 more rows #> # ℹ 2 more variables: .Contributions <chr>, .Value <dbl>  ## Additional variables can also be added to the data by either specifying ## them directly in the `data` or by using the `add_var` argument ## Refit model sim2$block <- as.numeric(sim2$block) new_mod <- update(mod, ~. + block, data = sim2) ## This model has block so we can either specify block in the data subset_data <- sim2[c(1,5,9,11), 2:6] subset_data #>    block  p1  p2  p3  p4 #> 1      1 0.7 0.1 0.1 0.1 #> 5      1 0.1 0.7 0.1 0.1 #> 9      1 0.1 0.1 0.7 0.1 #> 11     3 0.1 0.1 0.7 0.1 head(prediction_contributions_data(data = subset_data,                                    model = new_mod)) #> ✔ Finished data preparation. #> # A tibble: 6 × 7 #>   .x_labs .Community  .Pred .Lower .Upper .Contributions .Value #>   <chr>   <fct>       <dbl>  <dbl>  <dbl> <chr>           <dbl> #> 1 1       Community 1  19.1   18.2   20.1 p1              8.29  #> 2 1       Community 1  19.1   18.2   20.1 p2              1.14  #> 3 1       Community 1  19.1   18.2   20.1 p3              1.01  #> 4 1       Community 1  19.1   18.2   20.1 p4              0.967 #> 5 1       Community 1  19.1   18.2   20.1 block          -0.456 #> 6 1       Community 1  19.1   18.2   20.1 p1:p2           2.37  ## Or we could add the variable using `add_var` subset_data <- sim2[c(1,5,9,11), 3:6] subset_data #>     p1  p2  p3  p4 #> 1  0.7 0.1 0.1 0.1 #> 5  0.1 0.7 0.1 0.1 #> 9  0.1 0.1 0.7 0.1 #> 11 0.1 0.1 0.7 0.1 head(prediction_contributions_data(data = subset_data,                                    model = new_mod,                                    add_var = list(block = c(1, 2)))) #> ✔ Finished data preparation. #> # A tibble: 6 × 8 #>   .x_labs .Community  .add_str_ID .Pred .Lower .Upper .Contributions .Value #>   <chr>   <fct>       <chr>       <dbl>  <dbl>  <dbl> <chr>           <dbl> #> 1 1       Community 1 block: 1     19.1   18.2   20.1 p1              8.29  #> 2 1       Community 1 block: 1     19.1   18.2   20.1 p2              1.14  #> 3 1       Community 1 block: 1     19.1   18.2   20.1 p3              1.01  #> 4 1       Community 1 block: 1     19.1   18.2   20.1 p4              0.967 #> 5 1       Community 1 block: 1     19.1   18.2   20.1 block          -0.456 #> 6 1       Community 1 block: 1     19.1   18.2   20.1 p1:p2           2.37  ## The benefit of specifying the variable this way is we have an ID ## columns now called `.add_str_ID` which would be used to create a ## separate plot for each value of the additional variable   ## Model coefficients can also be used, but then user would have ## to specify the data with all columns corresponding to each coefficient coef_data <- sim2 %>%                mutate(`p1:p2` = p1*p2, `p1:p3` = p1*p2, `p1:p4` = p1*p4,                       `p2:p3` = p2*p3, `p2:p4` = p2*p4, `p3:p4` = p3*p4) %>%                select(p1, p2, p3, p4,                       `p1:p2`, `p1:p3`, `p1:p4`,                       `p2:p3`, `p2:p4`, `p3:p4`) %>%                slice(1,5,9,11) print(coef_data) #>     p1  p2  p3  p4 p1:p2 p1:p3 p1:p4 p2:p3 p2:p4 p3:p4 #> 1  0.7 0.1 0.1 0.1  0.07  0.07  0.07  0.01  0.01  0.01 #> 5  0.1 0.7 0.1 0.1  0.07  0.07  0.01  0.07  0.07  0.01 #> 9  0.1 0.1 0.7 0.1  0.01  0.01  0.01  0.07  0.01  0.07 #> 11 0.1 0.1 0.7 0.1  0.01  0.01  0.01  0.07  0.01  0.07 print(mod$coefficients) #>        p1        p2        p3        p4     p1:p2     p1:p3     p1:p4     p2:p3  #> 10.699426 10.228917  8.939289  8.532857 33.894874 37.552444 32.720996 26.739691  #>     p2:p4     p3:p4  #> 33.188799 27.771368  prediction_contributions_data(data = coef_data,                               coefficients = mod$coefficients,                               interval = \"none\") #> ✔ Finished data preparation. #> # A tibble: 40 × 5 #>    .x_labs .Community  .Pred .Contributions .Value #>    <chr>   <fct>       <dbl> <chr>           <dbl> #>  1 1       Community 1  18.4 p1              7.49  #>  2 1       Community 1  18.4 p2              1.02  #>  3 1       Community 1  18.4 p3              0.894 #>  4 1       Community 1  18.4 p4              0.853 #>  5 1       Community 1  18.4 p1:p2           2.37  #>  6 1       Community 1  18.4 p1:p3           2.63  #>  7 1       Community 1  18.4 p1:p4           2.29  #>  8 1       Community 1  18.4 p2:p3           0.267 #>  9 1       Community 1  18.4 p2:p4           0.332 #> 10 1       Community 1  18.4 p3:p4           0.278 #> # ℹ 30 more rows ## To get uncertainity using coefficients vcov matrix would have to specified prediction_contributions_data(data = coef_data,                               coefficients = mod$coefficients,                               vcov = vcov(mod)) #> ✔ Finished data preparation. #> # A tibble: 40 × 7 #>    .x_labs .Community  .Pred .Lower .Upper .Contributions .Value #>    <chr>   <fct>       <dbl>  <dbl>  <dbl> <chr>           <dbl> #>  1 1       Community 1  18.4   17.6   19.3 p1              7.49  #>  2 1       Community 1  18.4   17.6   19.3 p2              1.02  #>  3 1       Community 1  18.4   17.6   19.3 p3              0.894 #>  4 1       Community 1  18.4   17.6   19.3 p4              0.853 #>  5 1       Community 1  18.4   17.6   19.3 p1:p2           2.37  #>  6 1       Community 1  18.4   17.6   19.3 p1:p3           2.63  #>  7 1       Community 1  18.4   17.6   19.3 p1:p4           2.29  #>  8 1       Community 1  18.4   17.6   19.3 p2:p3           0.267 #>  9 1       Community 1  18.4   17.6   19.3 p2:p4           0.332 #> 10 1       Community 1  18.4   17.6   19.3 p3:p4           0.278 #> # ℹ 30 more rows  ## Specifying `bar_labs` ## Our data has four rows so we'd need four labels in bar_labs prediction_contributions_data(data = coef_data,                               coefficients = mod$coefficients,                               vcov = vcov(mod),                               bar_labs = c(\"p1 Domm\", \"p2 Domm\",                                            \"p3 Domm\", \"p4 Domm\")) #> ✔ Finished data preparation. #> # A tibble: 40 × 7 #>    .x_labs .Community  .Pred .Lower .Upper .Contributions .Value #>    <chr>   <fct>       <dbl>  <dbl>  <dbl> <chr>           <dbl> #>  1 p1 Domm Community 1  18.4   17.6   19.3 p1              7.49  #>  2 p1 Domm Community 1  18.4   17.6   19.3 p2              1.02  #>  3 p1 Domm Community 1  18.4   17.6   19.3 p3              0.894 #>  4 p1 Domm Community 1  18.4   17.6   19.3 p4              0.853 #>  5 p1 Domm Community 1  18.4   17.6   19.3 p1:p2           2.37  #>  6 p1 Domm Community 1  18.4   17.6   19.3 p1:p3           2.63  #>  7 p1 Domm Community 1  18.4   17.6   19.3 p1:p4           2.29  #>  8 p1 Domm Community 1  18.4   17.6   19.3 p2:p3           0.267 #>  9 p1 Domm Community 1  18.4   17.6   19.3 p2:p4           0.332 #> 10 p1 Domm Community 1  18.4   17.6   19.3 p3:p4           0.278 #> # ℹ 30 more rows"},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualise model term contributions to predicted response — prediction_contributions_plot","title":"Visualise model term contributions to predicted response — prediction_contributions_plot","text":"plotting function visualise predicted response regression model stacked bar-chart showing contributions (predictor coefficient * predictor value) model term total predicted value (represented total height bar). Requires output `prediction_contributions_data` input `data` parameter.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualise model term contributions to predicted response — prediction_contributions_plot","text":"","code":"prediction_contributions_plot(   data,   colours = NULL,   se = FALSE,   bar_orientation = c(\"vertical\", \"horizontal\"),   facet_var = NULL,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualise model term contributions to predicted response — prediction_contributions_plot","text":"data data-frame output `prediction_contributions_data` function, consisting predicted response split contributions different coefficients. colours character vector specifying colours contributions different coefficients. specified, default colour-scheme chosen, however uninformative recommended manually choose contrasting colours coefficient group render informative plot. se logical value indicating whether show prediction intervals predictions plot. bar_orientation One \"vertical\" \"horizontal\" indicating orientation bars. Defaults vertical orientation. facet_var character string numeric index identifying column data used faceting plot multiple panels. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualise model term contributions to predicted response — prediction_contributions_plot","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/prediction_contributions_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualise model term contributions to predicted response — prediction_contributions_plot","text":"","code":"library(DImodels) library(dplyr)  ## Load data data(sim2) sim2$AV <- DI_data_E_AV(data = sim2, prop = 3:6)$AV  ## Fit model mod <- glm(response ~ 0 + (p1 + p2 + p3 + p4 + AV), data = sim2)  ## Create data for plotting plot_data <- prediction_contributions_data(data = sim2[c(1,5,9,11,15,19,23), ],                                            model = mod) #> ✔ Finished data preparation. ## Create plot prediction_contributions_plot(data = plot_data) #> Warning: No colours were specified for the response contributions. #> ℹ The default colours might not result in an informative plot, consider choosing specific colours to contrast the contributions of different groups in the response. #> This warning is displayed once per session. #> ✔ Created plot.   ## Choose distinct colours for groups of coefficients for better visibility ID_cols <- get_colours(4, FG = c(\"G\", \"G\", \"H\", \"H\")) int_cols <- \"#808080\" cols <- c(ID_cols, int_cols) ## Specify colours using `cols` prediction_contributions_plot(data = plot_data, colours = cols) #> ✔ Created plot.   ## Show prediction intervals prediction_contributions_plot(data = plot_data, colours = cols, se = TRUE) #> ✔ Created plot.   ## Change orientation of bars using `bar_orientation` prediction_contributions_plot(data = plot_data, colours = cols,                               se = TRUE, bar_orientation = \"horizontal\") #> ✔ Created plot.   ## Facet plot based on a variable in the data prediction_contributions_plot(data = plot_data, colours = cols,                               se = TRUE, bar_orientation = \"horizontal\",                               facet_var = \"block\") #> ✔ Created plot.   ## If multiple plots are desired `add_var` can be specified during ## data preparation and the plots can be arranged using nrow and ncol sim2$block <- as.character(sim2$block) new_mod <- update(mod, ~. + block, data = sim2) plot_data <- prediction_contributions_data(data = sim2[c(1,5,9,11,15,19,23), c(3:6, 8)],                                            model = new_mod,                                            add_var = list(\"block\" = c(\"1\", \"2\"))) #> ✔ Finished data preparation. ## Arrange in two columns prediction_contributions_plot(data = plot_data, ncol = 2) #> ✔ Created all plots."},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualising the change in a response variable between two points in the simplex space — simplex_path","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path","text":"function prepare underlying data plot results visualising change response variable move across straight line two points simplex space single function call. two sets points specified `starts` `ends` parameters joined straight line across simplex space response predicted starting, ending intermediate communities along line. associated uncertainty along prediction also shown. generated plot show individual curves indicating variation response points. `Pie-glyphs` used highlight compositions starting, ending midpoint straight line two points. wrapper function specifically statistical models fit using DI() function DImodels R package implicitly call simplex_path_data followed simplex_path_plot. model object fit using DImodels, consider calling functions manually.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path","text":"","code":"simplex_path(   model,   starts,   ends,   add_var = list(),   interval = c(\"confidence\", \"prediction\", \"none\"),   conf.level = 0.95,   se = FALSE,   pie_positions = c(0, 0.5, 1),   pie_colours = NULL,   pie_radius = 0.3,   FG = NULL,   facet_var = NULL,   plot = TRUE,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path","text":"model Diversity Interactions model object fit using `DI()` function `DImodels` package. starts data-frame specifying starting proportions compositional variables. model object specified data contain variables present model object including additional non-compositional variables. coefficient vector specified data contain number columns number elements coefficient vector one--one positional mapping assumed data columns elements coefficient vector. ends data-frame specifying ending proportions compositional variables. model object specified data contain variables present model object including additional non-compositional variables. coefficient vector specified data contain number columns number elements coefficient vector one--one positional mapping assumed data columns elements coefficient vector. add_var list specifying values additional variables model proportions (.e. part simplex design). useful compare predictions across different values categorical variable. One plot generated unique combination values specified . interval Type interval calculate: \"none\" interval calculated. \"confidence\" (default) Calculate confidence interval. \"prediction\" Calculate prediction interval. conf.level confidence level calculating confidence/prediction intervals. Default 0.95. se boolean variable indicating whether plot confidence intervals associated effect species increase decrease pie_positions numeric vector values 0 1 (inclusive) indicating positions along X-axis show pie-glyphs curve. Default c(0, 0.5, 1) meaning pie-glyphs shown start, midpoint end curve. pie_colours character vector indicating colours slices pie-glyphs.  left NULL, colour blind friendly colours pie-glyph slices. pie_radius numeric value specifying radius (cm) pie-glyphs. Default 0.3 cm. FG higher level grouping compositional variables data. Variables belonging group assigned different shades colour. user can manually specify character vector giving group variable belongs . left empty function try get grouping original DI model object. facet_var character string numeric index identifying column data used faceting plot multiple panels. plot boolean variable indicating whether create plot return prepared data instead. default `TRUE` creates plot `FALSE` return prepared data plotting. useful user wants modify data first call plotting function manually. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path","text":"","code":"library(DImodels) data(sim2)  # Fit model mod <- DI(y = \"response\", prop = 3:6, DImodel = \"AV\", data = sim2) #> Fitted model: Average interactions 'AV' DImodel  # Create plot # Move from p3 monoculture to p4 monoculture simplex_path(model = mod,              starts = data.frame(p1 = 0, p2 = 0, p3 = 1, p4 = 0),              ends = data.frame(p1 = 0, p2 = 0, p3 = 0, p4 = 1)) #> ✔ Finished data preparation. #> ✔ Created plot.   # Move from each 70% dominant mixtures to p1 monoculture simplex_path(model = mod,              starts = sim2[c(1, 5, 9, 13), 3:6],              ends = data.frame(p1 = 1, p2 = 0, p3 = 0, p4 = 0)) #> ✔ Finished data preparation. #> ✔ Created plot.   # Move from centroid community to each monoculture simplex_path(model = mod,              starts = sim2[c(18),],              ends = sim2[c(48, 52, 56, 60), ]) #> ✔ Finished data preparation. #> ✔ Created plot.   # Show change across multiple points simultaneously and show confidence bands # using `se = TRUE` simplex_path(model = mod,              starts = sim2[c(1, 17, 22), ],              ends = sim2[c(5, 14, 17), ], se = TRUE) #> ✔ Finished data preparation. #> ✔ Created plot.   # Change pie_colours using `pie_colours` and show pie-glyph at different # points along the curve using `pie_positions` simplex_path(model = mod,              starts = sim2[c(1, 17, 22), ],              ends = sim2[c(5, 14, 17), ], se = TRUE,              pie_positions = c(0, 0.25, 0.5, 0.75, 1),              pie_colours = c(\"steelblue1\", \"steelblue4\", \"orange1\", \"orange4\")) #> ✔ Finished data preparation. #> ✔ Created plot.   # Facet based on existing variables # \\donttest{ simplex_path(model = mod,              starts = sim2[c(1, 17, 22), ],              ends = sim2[c(5, 14, 17), ], se = TRUE, facet_var = \"block\",              pie_colours = c(\"steelblue1\", \"steelblue4\", \"orange1\", \"orange4\")) #> ✔ Finished data preparation. #> ✔ Created plot.   # Add additional variables and create a separate plot for each simplex_path(model = mod,              starts = sim2[c(1, 17, 22), 3:6],              ends = sim2[c(5, 14, 17), 3:6], se = TRUE,              pie_colours = c(\"steelblue1\", \"steelblue4\", \"orange1\", \"orange4\"),              add_var = list(\"block\" = factor(c(1, 3),                                              levels = c(1, 2, 3, 4)))) #> ✔ Finished data preparation. #> ✔ Created all plots.  # }  ## Specify `plot = FALSE` to not create the plot but return the prepared data head(simplex_path(model = mod, plot = FALSE,                   starts = sim2[c(1, 17, 22), 3:6],                   ends = sim2[c(5, 14, 17), 3:6], se = TRUE,                   pie_colours = c(\"steelblue1\", \"steelblue4\",                                   \"orange1\", \"orange4\"),                   add_var = list(\"block\" = factor(c(1, 3),                                                   levels = c(1, 2, 3, 4))))) #> ✔ Finished data preparation. #>      p1    p2  p3  p4 .InterpConst .Group block .add_str_ID    .Pred   .Lower #> 1 0.700 0.100 0.1 0.1         0.00      1     1    block: 1 18.19429 17.45473 #> 2 0.694 0.106 0.1 0.1         0.01      1     1    block: 1 18.30217 17.56890 #> 3 0.688 0.112 0.1 0.1         0.02      1     1    block: 1 18.40775 17.68057 #> 4 0.682 0.118 0.1 0.1         0.03      1     1    block: 1 18.51103 17.78973 #> 5 0.676 0.124 0.1 0.1         0.04      1     1    block: 1 18.61200 17.89639 #> 6 0.670 0.130 0.1 0.1         0.05      1     1    block: 1 18.71068 18.00055 #>     .Upper #> 1 18.93385 #> 2 19.03544 #> 3 19.13494 #> 4 19.23233 #> 5 19.32762 #> 6 19.42080"},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating data for visualising the change in a response variable between two points in the simplex space — simplex_path_data","title":"Creating data for visualising the change in a response variable between two points in the simplex space — simplex_path_data","text":"helper function prepare underlying data visualising change response variable two points simplex space. two points specified `starts` `ends` parameters joined straight line across simplex space response predicted starting, ending intermediate communities along line. associated uncertainty along prediction also returned. output function can passed simplex_path_plot function visualise change response.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating data for visualising the change in a response variable between two points in the simplex space — simplex_path_data","text":"","code":"simplex_path_data(starts, ends, prop, add_var = list(), prediction = TRUE, ...)"},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating data for visualising the change in a response variable between two points in the simplex space — simplex_path_data","text":"starts data-frame specifying starting proportions compositional variables. model object specified data contain variables present model object including additional non-compositional variables. coefficient vector specified data contain number columns number elements coefficient vector one--one positional mapping assumed data columns elements coefficient vector. ends data-frame specifying ending proportions compositional variables. model object specified data contain variables present model object including additional non-compositional variables. coefficient vector specified data contain number columns number elements coefficient vector one--one positional mapping assumed data columns elements coefficient vector. prop vector column names identifying columns containing variable proportions (.e., compositional columns) data. add_var list data-frame specifying values additional variables model proportions (.e. part simplex design). useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data. prediction logical value indicating whether pass final data `add_prediction` function append predictions data. Default value TRUE, often desirable make additional changes data making predictions, user can set FALSE manually call `add_prediction` function. ... Arguments passed add_prediction model regression model object used make predictions observations `data`. override `coefficients` specified. coefficients regression model available (fit R), regression coefficients model fit language can used calculate predictions. However, user ensure appropriate one--one positional mapping data columns coefficient values. , also provide variance-covariance matrix coefficients `vcov` parameter want associated CI prediction possible calculate confidence/prediction intervals using method. vcov regression coefficients specified, variance-covariance matrix coefficients can specified calculate associated confidence interval around prediction. Failure result confidence intervals returned. Ensure `coefficients` `vcov` positional mapping data. coeff_cols `coefficients` specified one--one positional mapping data-columns coefficient vector present. character string numeric index can specified reorder data columns match corresponding coefficient value respective data column. See \"Use model coefficients prediction\" section examples. conf.level confidence level calculating confidence/prediction intervals. Default 0.95. interval Type interval calculate: \"none\" (default) interval calculated. \"confidence\" Calculate confidence interval. \"prediction\" Calculate prediction interval.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating data for visualising the change in a response variable between two points in the simplex space — simplex_path_data","text":"data frame following columns appended end .InterpConst value interpolation constant creating                        intermediate compositions start end compositions. .Group identifier column discern different curves. .add_str_ID identifier column grouping cartesian product                       additional columns specified `add_var`                       parameter (`add_var` specified). .Pred predicted response observation. .Lower lower limit prediction/confidence interval observation. .Upper upper limit prediction/confidence interval observation.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating data for visualising the change in a response variable between two points in the simplex space — simplex_path_data","text":"","code":"library(DImodels)  ## Load data data(sim2)  ## Fit model mod <- glm(response ~ (p1 + p2 + p3 + p4)^2 + 0, data = sim2)  ## Create data for visualising change in response as we move from ## a species dominated by 70% of one species to a monoculture of ## same species head(simplex_path_data(starts = sim2[c(1, 5, 9, 13), 3:6],                        ends = sim2[c(48, 52, 56, 60), 3:6],                        prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                        model = mod)) #> ✔ Finished data preparation. #>      p1    p2    p3    p4 .InterpConst .Group    .Pred   .Lower   .Upper #> 1 0.700 0.100 0.100 0.100         0.00      1 18.42849 17.58232 19.27465 #> 2 0.703 0.099 0.099 0.099         0.01      1 18.37345 17.52663 19.22027 #> 3 0.706 0.098 0.098 0.098         0.02      1 18.31797 17.47045 19.16548 #> 4 0.709 0.097 0.097 0.097         0.03      1 18.26203 17.41378 19.11028 #> 5 0.712 0.096 0.096 0.096         0.04      1 18.20565 17.35661 19.05468 #> 6 0.715 0.095 0.095 0.095         0.05      1 18.14881 17.29895 18.99868  ## Create data for visualising change in response as we move from ## the centroid mixture to each monoculture ## If either of starts or ends have only row, then they'll be recycled ## to match the number of rows in the other ## Notice starts has only one row here, but will be recycled to have 4 ## since ends has 4 four rows head(simplex_path_data(starts = sim2[c(18),3:6],                        ends = sim2[c(48, 52, 56, 60),3:6],                        prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                        model = mod)) #> ✔ Finished data preparation. #>       p1     p2     p3     p4 .InterpConst .Group    .Pred   .Lower   .Upper #> 1 0.2500 0.2500 0.2500 0.2500         0.00      1 21.59188 20.99819 22.18557 #> 2 0.2575 0.2475 0.2475 0.2475         0.01      1 21.62206 21.02781 22.21630 #> 3 0.2650 0.2450 0.2450 0.2450         0.02      1 21.64942 21.05356 22.24528 #> 4 0.2725 0.2425 0.2425 0.2425         0.03      1 21.67397 21.07553 22.27242 #> 5 0.2800 0.2400 0.2400 0.2400         0.04      1 21.69572 21.09380 22.29763 #> 6 0.2875 0.2375 0.2375 0.2375         0.05      1 21.71465 21.10848 22.32082  ## Changing the confidence level for the prediction interval ## Use `conf.level` parameter head(simplex_path_data(starts = sim2[c(18), 3:6],                        ends = sim2[c(48, 52, 56, 60),3:6],                        prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                        model = mod, conf.level = 0.99)) #> ✔ Finished data preparation. #>       p1     p2     p3     p4 .InterpConst .Group    .Pred   .Lower   .Upper #> 1 0.2500 0.2500 0.2500 0.2500         0.00      1 21.59188 20.80038 22.38338 #> 2 0.2575 0.2475 0.2475 0.2475         0.01      1 21.62206 20.82981 22.41430 #> 3 0.2650 0.2450 0.2450 0.2450         0.02      1 21.64942 20.85502 22.44382 #> 4 0.2725 0.2425 0.2425 0.2425         0.03      1 21.67397 20.87613 22.47182 #> 5 0.2800 0.2400 0.2400 0.2400         0.04      1 21.69572 20.89325 22.49818 #> 6 0.2875 0.2375 0.2375 0.2375         0.05      1 21.71465 20.90651 22.52279  ## Adding additional variables to the data using `add_var` ## Notice the new .add_str_ID column in the output sim2$block <- as.numeric(sim2$block) new_mod <- update(mod, ~ . + block, data = sim2) head(simplex_path_data(starts = sim2[c(18), 3:6],                        ends = sim2[c(48, 52, 56, 60), 3:6],                        prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                        model = new_mod, conf.level = 0.99,                        add_var = list(\"block\" = c(1, 2)))) #> ✔ Finished data preparation. #>       p1     p2     p3     p4 .InterpConst .Group block .add_str_ID    .Pred #> 1 0.2500 0.2500 0.2500 0.2500         0.00      1     1    block: 1 22.27542 #> 2 0.2575 0.2475 0.2475 0.2475         0.01      1     1    block: 1 22.30560 #> 3 0.2650 0.2450 0.2450 0.2450         0.02      1     1    block: 1 22.33296 #> 4 0.2725 0.2425 0.2425 0.2425         0.03      1     1    block: 1 22.35751 #> 5 0.2800 0.2400 0.2400 0.2400         0.04      1     1    block: 1 22.37926 #> 6 0.2875 0.2375 0.2375 0.2375         0.05      1     1    block: 1 22.39819 #>     .Lower   .Upper #> 1 21.27206 23.27879 #> 2 21.30171 23.30948 #> 3 21.32756 23.33836 #> 4 21.34970 23.36533 #> 5 21.36819 23.39032 #> 6 21.38312 23.41326  ## Use predict = FALSE to get raw data structure out_data <- simplex_path_data(starts = sim2[c(18), 3:6],                               ends = sim2[c(48, 52, 56, 60), 3:6],                               prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                               model = new_mod,                               prediction = FALSE) #> ✔ Finished data preparation. head(out_data) #>       p1     p2     p3     p4 .InterpConst .Group #> 1 0.2500 0.2500 0.2500 0.2500         0.00      1 #> 2 0.2575 0.2475 0.2475 0.2475         0.01      1 #> 3 0.2650 0.2450 0.2450 0.2450         0.02      1 #> 4 0.2725 0.2425 0.2425 0.2425         0.03      1 #> 5 0.2800 0.2400 0.2400 0.2400         0.04      1 #> 6 0.2875 0.2375 0.2375 0.2375         0.05      1 ## Manually add block out_data$block = 3 ## Call `add_prediction` to get prediction head(add_prediction(data = out_data, model = new_mod, interval = \"conf\")) #>       p1     p2     p3     p4 .InterpConst .Group block    .Pred   .Lower #> 1 0.2500 0.2500 0.2500 0.2500         0.00      1     3 21.36404 20.78032 #> 2 0.2575 0.2475 0.2475 0.2475         0.01      1     3 21.39421 20.80999 #> 3 0.2650 0.2450 0.2450 0.2450         0.02      1     3 21.42157 20.83590 #> 4 0.2725 0.2425 0.2425 0.2425         0.03      1     3 21.44613 20.85812 #> 5 0.2800 0.2400 0.2400 0.2400         0.04      1     3 21.46787 20.87674 #> 6 0.2875 0.2375 0.2375 0.2375         0.05      1     3 21.48680 20.89183 #>     .Upper #> 1 21.94775 #> 2 21.97843 #> 3 22.00725 #> 4 22.03413 #> 5 22.05900 #> 6 22.08178"},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualising the change in a response variable between two points in the simplex space — simplex_path_plot","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path_plot","text":"helper function plotting change response variable straight line two points across simplex space. output simplex_path_data function (desired modifications) passed . generated plot show individual curves indicating variation response points. `Pie-glyphs` used highlight compositions starting, ending midpoint straight line two points.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path_plot","text":"","code":"simplex_path_plot(   data,   prop = NULL,   pie_positions = c(0, 0.5, 1),   pie_radius = 0.3,   pie_colours = NULL,   se = FALSE,   facet_var = NULL,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path_plot","text":"data data frame created using simplex_path_data function. prop vector column names indices identifying columns containing species proportions data. inferred data created using `simplex_path_data` function, user also flexibility manually specifying values. pie_positions numeric vector values 0 1 (inclusive) indicating positions along X-axis show pie-glyphs curve. Default c(0, 0.5, 1) meaning pie-glyphs shown start, midpoint end curve. pie_radius numeric value specifying radius (cm) pie-glyphs. Default 0.3 cm. pie_colours character vector indicating colours slices pie-glyphs.  left NULL, colour blind friendly colours pie-glyph slices. se boolean variable indicating whether plot confidence intervals associated effect species increase decrease facet_var character string numeric index identifying column data used faceting plot multiple panels. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path_plot","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/simplex_path_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualising the change in a response variable between two points in the simplex space — simplex_path_plot","text":"","code":"library(DImodels)  ## Load data data(sim2)  ## Fit model mod <- glm(response ~ (p1 + p2 + p3 + p4)^2 + 0, data = sim2)  ## Visualise change as we move from the centroid community to each monoculture plot_data <- simplex_path_data(starts = sim2[c(19, 20, 19, 20), ],                                ends = sim2[c(47, 52, 55, 60), ],                                prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                                model = mod) #> ✔ Finished data preparation. ## prop will be inferred from data simplex_path_plot(data = plot_data) #> ✔ Created plot.   ## Show specific curves simplex_path_plot(data = plot_data[plot_data$.Group %in% c(1, 4), ]) #> ✔ Created plot.   ## Show uncertainty using `se = TRUE` simplex_path_plot(data = plot_data[plot_data$.Group %in% c(1, 4), ],                   se = TRUE) #> ✔ Created plot.   ## Change colours of pie-glyphs using `pie_colours` simplex_path_plot(data = plot_data[plot_data$.Group %in% c(1, 4), ],                   se = TRUE,                   pie_colours = c(\"steelblue1\", \"steelblue4\", \"orange1\", \"orange4\")) #> ✔ Created plot.   ## Show pie-glyphs at different points along the curve using `pie_positions` simplex_path_plot(data = plot_data[plot_data$.Group %in% c(1, 4), ],                   se = TRUE,                   pie_positions = c(0, 0.25, 0.5, 0.75, 1),                   pie_colours = c(\"steelblue1\", \"steelblue4\", \"orange1\", \"orange4\")) #> ✔ Created plot.   ## Facet plot based on specific variables simplex_path_plot(data = plot_data,                   se = TRUE,                   facet_var = \"block\",                   pie_colours = c(\"steelblue1\", \"steelblue4\", \"orange1\", \"orange4\")) #> ✔ Created plot.   ## Simulataneously create multiple plots for additional variables sim2$block <- as.numeric(sim2$block) new_mod <- update(mod, ~ . + block, data = sim2) plot_data <- simplex_path_data(starts = sim2[c(18), 3:6],                        ends = sim2[c(48, 60), 3:6],                        prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                        model = new_mod, conf.level = 0.95,                        add_var = list(\"block\" = c(1, 2))) #> ✔ Finished data preparation.  simplex_path_plot(data = plot_data,                   pie_colours = c(\"steelblue1\", \"steelblue4\",                                   \"orange1\", \"orange4\"),                   nrow = 1, ncol = 2) #> ✔ Created all plots."},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare data for showing contours in ternary diagrams. — ternary_data","title":"Prepare data for showing contours in ternary diagrams. — ternary_data","text":"data preparation function creating equally spaced grid three compositional variables (.e., three variables sum 1 point along grid). projection point grid x-y plane also calculated. data can used relevant statistical model predict response across ternary surface. output function can passed ternary_plot function visualise change response contour plot. Note: function works models three compositional predictors. models three compositional predictors see conditional_ternary.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare data for showing contours in ternary diagrams. — ternary_data","text":"","code":"ternary_data(   prop = c(\".P1\", \".P2\", \".P3\"),   add_var = list(),   resolution = 3,   prediction = TRUE,   ... )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare data for showing contours in ternary diagrams. — ternary_data","text":"prop character vector specifying columns names compositional variables whose proportions manipulate. Default \".P1\", \".P2\", \".P3\". add_var list data-frame specifying values additional variables model proportions (.e. part simplex design). useful comparing predictions across different values non-compositional variable. specified list, expanded show plot unique combination values specified, specified data-frame, one plot generated row data. resolution number 1 10 describing resolution resultant graph. high value result higher definition figure cost computationally expensive. prediction logical value indicating whether pass final data `add_prediction` function append predictions data. Default value TRUE, often desirable make additional changes data making predictions, user can set FALSE manually call `add_prediction` function. ... Arguments passed add_prediction model regression model object used make predictions observations `data`. override `coefficients` specified. coefficients regression model available (fit R), regression coefficients model fit language can used calculate predictions. However, user ensure appropriate one--one positional mapping data columns coefficient values. , also provide variance-covariance matrix coefficients `vcov` parameter want associated CI prediction possible calculate confidence/prediction intervals using method. vcov regression coefficients specified, variance-covariance matrix coefficients can specified calculate associated confidence interval around prediction. Failure result confidence intervals returned. Ensure `coefficients` `vcov` positional mapping data. coeff_cols `coefficients` specified one--one positional mapping data-columns coefficient vector present. character string numeric index can specified reorder data columns match corresponding coefficient value respective data column. See \"Use model coefficients prediction\" section examples. conf.level confidence level calculating confidence/prediction intervals. Default 0.95. interval Type interval calculate: \"none\" (default) interval calculated. \"confidence\" Calculate confidence interval. \"prediction\" Calculate prediction interval.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare data for showing contours in ternary diagrams. — ternary_data","text":"data-frame following columns additional columns         specified `add_var` parameter .x x component x-y projection simplex point. .y y component x-y projection simplex point. .P1 first variable whose proportion varied across simplex. .P2 second variable whose proportion varied across simplex. .P3 third variable whose proportion varied across simplex. .add_str_ID identifier column grouping cartesian product                       additional columns specified `add_var`                       parameter (`add_var` specified). .Pred predicted response observation                (`prediction` TRUE). .Lower lower limit prediction/confidence interval                  observation. .Upper upper limit prediction/confidence interval                  observation.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare data for showing contours in ternary diagrams. — ternary_data","text":"","code":"library(DImodels) library(dplyr)  ## Load data data(sim0)  ## Fit model mod <- lm(response ~ 0 + (p1 + p2 + p3)^2, data = sim0)  ## Prepare data for creating a contour map of predicted response over ## the ternary surface ## Remember to specify prop with the same character values as the names ## of the variables in the model containing the prop. plot_data <- ternary_data(resolution = 1, model = mod,                           prop = c(\"p1\", \"p2\", \"p3\")) ## Show plot ternary_plot(data = plot_data) #> ✔ Created plot.   ## Can also add any additional variables independent of the simplex using ## the `add_var` argument sim0$treatment <-  rep(c(\"A\", \"B\", \"C\", \"D\"), each = 16) new_mod <- update(mod, ~. + treatment, data = sim0) plot_data <- ternary_data(prop = c(\"p1\", \"p2\", \"p3\"),                           add_var = list(\"treatment\" = c(\"A\", \"B\")),                           resolution = 1, model = new_mod) ## Plot to compare between additional variables # \\donttest{ ternary_plot(plot_data) #> ✔ Created all plots.  # }  ## It could be desirable to take the output of this function and add ## additional variables to the data before making predictions ## Use `prediction = FALSE` to get data without any predictions contour_data <- ternary_data(prop = c(\"p1\", \"p2\", \"p3\"),                              model = mod,                              prediction = FALSE,                              resolution = 1) head(contour_data) #>   p1        p2          p3          .x .y #> 1  0 1.0000000 0.000000000 0.000000000  0 #> 2  0 0.9949749 0.005025126 0.005025126  0 #> 3  0 0.9899497 0.010050251 0.010050251  0 #> 4  0 0.9849246 0.015075377 0.015075377  0 #> 5  0 0.9798995 0.020100503 0.020100503  0 #> 6  0 0.9748744 0.025125628 0.025125628  0  ## Manually add the treatment variable contour_data$treatment <- \"A\" ## Make predictions head(add_prediction(data = contour_data, model = new_mod)) #>   p1        p2          p3          .x .y treatment    .Pred #> 1  0 1.0000000 0.000000000 0.000000000  0         A 19.16711 #> 2  0 0.9949749 0.005025126 0.005025126  0         A 19.38754 #> 3  0 0.9899497 0.010050251 0.010050251  0         A 19.60556 #> 4  0 0.9849246 0.015075377 0.015075377  0         A 19.82115 #> 5  0 0.9798995 0.020100503 0.020100503  0         A 20.03433 #> 6  0 0.9748744 0.025125628 0.025125628  0         A 20.24508  ## Manually add the interaction terms contour_data <- contour_data %>%                   mutate(`p1:p2` = p1*p2,                          `p2:p3` = p2*p3,                          `p1:p3` = p1*p3)  ## Add predictions using model coefficients contour_data <- add_prediction(data = contour_data,                                coefficient = mod$coefficient) head(contour_data) #>   p1        p2          p3          .x .y treatment p1:p2       p2:p3 p1:p3 #> 1  0 1.0000000 0.000000000 0.000000000  0         A     0 0.000000000     0 #> 2  0 0.9949749 0.005025126 0.005025126  0         A     0 0.004999874     0 #> 3  0 0.9899497 0.010050251 0.010050251  0         A     0 0.009949244     0 #> 4  0 0.9849246 0.015075377 0.015075377  0         A     0 0.014848110     0 #> 5  0 0.9798995 0.020100503 0.020100503  0         A     0 0.019696472     0 #> 6  0 0.9748744 0.025125628 0.025125628  0         A     0 0.024494331     0 #>      .Pred #> 1 18.61551 #> 2 18.83595 #> 3 19.05396 #> 4 19.26956 #> 5 19.48273 #> 6 19.69349  ## Note: Add predictions via coefficients would not give confidence intervals ## to get CIs using coefficients we need to specify the variance-covariance ## matrix using `vcov` contour_data <- add_prediction(data = contour_data,                                coefficient = mod$coefficient,                                vcov = vcov(mod),                                interval = \"confidence\") head(contour_data) #>   p1        p2          p3          .x .y treatment p1:p2       p2:p3 p1:p3 #> 1  0 1.0000000 0.000000000 0.000000000  0         A     0 0.000000000     0 #> 2  0 0.9949749 0.005025126 0.005025126  0         A     0 0.004999874     0 #> 3  0 0.9899497 0.010050251 0.010050251  0         A     0 0.009949244     0 #> 4  0 0.9849246 0.015075377 0.015075377  0         A     0 0.014848110     0 #> 5  0 0.9798995 0.020100503 0.020100503  0         A     0 0.019696472     0 #> 6  0 0.9748744 0.025125628 0.025125628  0         A     0 0.024494331     0 #>      .Pred   .Lower   .Upper #> 1 18.61551 17.10673 20.12430 #> 2 18.83595 17.35220 20.31969 #> 3 19.05396 17.59460 20.51332 #> 4 19.26956 17.83392 20.70519 #> 5 19.48273 18.07015 20.89532 #> 6 19.69349 18.30327 21.08370 ## Show plot # \\donttest{ ternary_plot(contour_data) #> ✔ Created plot.  # } ## See `?ternary_plot` for options to customise the ternary_plot"},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Ternary diagrams — ternary_plot","title":"Ternary diagrams — ternary_plot","text":"Create ternary diagram showing scatter-plot points across surface contour map showing change continuous variable across ternary surface. ternary surface can created using ternary_data function.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ternary diagrams — ternary_plot","text":"","code":"ternary_plot(   data,   prop = NULL,   col_var = \".Pred\",   show = c(\"contours\", \"points\"),   tern_labels = c(\"P1\", \"P2\", \"P3\"),   show_axis_labels = TRUE,   show_axis_guides = FALSE,   axis_label_size = 4,   vertex_label_size = 5,   points_size = 2,   nlevels = 7,   colours = NULL,   lower_lim = NULL,   upper_lim = NULL,   contour_text = FALSE,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ternary diagrams — ternary_plot","text":"data data-frame consisting x-y plane projection 2-d simplex. data output `ternary_data` function, contain  predicted response point along simplex show variation response contour map. prop character vector specifying columns names compositional variables. default, function try automatically interpret values data. col_var column name containing variable used colouring contours points. default \".Pred\". show character string indicating whether show data-points contours ternary. default show \"contours\". tern_labels character vector containing labels vertices ternary. default column names first three columns data, first column corresponding top vertex, second column corresponding left vertex third column corresponding right vertex ternary. show_axis_labels boolean value indicating whether show axis labels along edges ternary. default TRUE. show_axis_guides boolean value indicating whether show axis guides within interior ternary. default FALSE. axis_label_size numeric value adjust size axis labels ternary plot. default size 4. vertex_label_size numeric value adjust size vertex labels ternary plot. default size 5. points_size showing points, numeric value specifying size points. nlevels number levels show contour map. colours character vector function specifying colours contour map points. number colours `nlevels` (`show = \"contours\"`).  default colours scheme terrain.colors() continuous variables extended version Okabe-Ito colour scale categorical variables. lower_lim number set custom lower limit contour (`show = \"contours\"`). default minimum prediction. upper_lim number set custom upper limit contour (`show = \"contours\"`). default maximum prediction. contour_text boolean value indicating whether include labels contour lines showing values (`show = \"contours\"`). default FALSE. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ternary diagrams — ternary_plot","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/ternary_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ternary diagrams — ternary_plot","text":"","code":"library(DImodels) library(dplyr) library(ggplot2)  ## Load data data(sim0)  ### Show raw data as points in ternary ## `ternary_plot` shows contours by default, use `show = \"points\"` to show ## points across the ternary ternary_plot(data = sim0, prop = c(\"p1\", \"p2\", \"p3\"), show = \"points\") #> ✔ Created plot.   ## The points can also be coloured using an additional variable by ## specifying it in `col_var` ternary_plot(data = sim0, prop = c(\"p1\", \"p2\", \"p3\"),              col_var = \"response\", show = \"points\") #> ✔ Created plot.   ## Categorical variables can also be shown ## Also show axis guides using `show_axis_guides` sim0$richness <- as.factor(sim0$richness) ternary_plot(data = sim0, prop = c(\"p1\", \"p2\", \"p3\"),              col_var = \"richness\", show = \"points\",              show_axis_guides = TRUE) #> ✔ Created plot.   ## Change colours by using `colours` argument ## and increase points size using `points_size` ternary_plot(data = sim0, prop = c(\"p1\", \"p2\", \"p3\"),              col_var = \"richness\", show = \"points\",              colours = c(\"tomato\", \"steelblue\", \"orange\"),              points_size = 4) #> ✔ Created plot.   ### Show contours of response ## Fit model mod <- lm(response ~ 0 + (p1 + p2 + p3)^2, data = sim0)  ## Create a contour map of predicted response over the ternary surface ## Remember to specify prop with the same character values as the names ## of the variables in the model containing the prop. plot_data <- ternary_data(resolution = 1, model = mod,                           prop = c(\"p1\", \"p2\", \"p3\"))  ## Create a contour plot of response across the ternary space ternary_plot(plot_data) #> ✔ Created plot.   ## Change colour scheme cols <- hcl.colors(7) # because there are 7 contour levels by default ternary_plot(plot_data, colours = cols) #> ✔ Created plot.   # \\donttest{ ## Change number of contours using `nlevels` ## and set custom upper and lower limits for the scale ternary_plot(plot_data, nlevels = 10, colours = hcl.colors(10),              lower_lim = 10, upper_lim = 35) #> ✔ Created plot.   ## Change ternary labels along with their font-size ternary_plot(plot_data, tern_labels = c(\"Sp1\", \"Sp2\", \"Sp3\"),              vertex_label_size = 6, axis_label_size = 5) #> ✔ Created plot.   ## Add additional variables and create a separate plot for each sim0$treatment <-  rep(c(\"A\", \"B\", \"C\", \"D\"), each = 16) new_mod <- update(mod, ~. + treatment, data = sim0) tern_data <- ternary_data(resolution = 1, model = new_mod,                           prop = c(\"p1\", \"p2\", \"p3\"),                           add_var = list(\"treatment\" = c(\"A\", \"C\"))) ## Arrange plot in 2 columns ternary_plot(data = tern_data, ncol = 2) #> ✔ Created all plots.  # }"},{"path":"https://rishvish.github.io/DImodelsVis/reference/theme_DI.html","id":null,"dir":"Reference","previous_headings":"","what":"Default theme for DImodelsVis — theme_DI","title":"Default theme for DImodelsVis — theme_DI","text":"Default theme DImodelsVis","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/theme_DI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default theme for DImodelsVis — theme_DI","text":"","code":"theme_DI(   font_size = 14,   font_family = \"\",   legend = c(\"top\", \"bottom\", \"left\", \"right\", \"none\") )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/theme_DI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default theme for DImodelsVis — theme_DI","text":"font_size Base font size text across plot font_family Font family text across plot legend One c(\"top\", \"bottom\", \"left\", \"right\", \"none\") specifying position legend. legend position can also specified numeric vector form c(x, y) x y values 0 1. specified numeric vector legend within plotting region c(0,0) corresponds \"bottom left\" c(1,1) corresponds \"top right\" position. default position \"top\".","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/theme_DI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default theme for DImodelsVis — theme_DI","text":"ggplot theme object","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/theme_DI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Default theme for DImodelsVis — theme_DI","text":"","code":"library(ggplot2)  plot_data <- mtcars plot_data$gear <- as.factor(plot_data$gear) ggplot(data = plot_data,        aes(x = mpg, y = disp, colour = gear))+    geom_point(size = 3)+    facet_wrap(~cyl) +    theme_DI()"},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Effects plot for compositional data — visualise_effects","title":"Effects plot for compositional data — visualise_effects","text":"function prepare underlying data plot results visualising effect increasing decreasing proportion predictor variable (set compositional variables). generated plot show curve observation (whenever possible) data. Pie-glyphs used highlight compositions specified communities ending community variable interest either completes dominates community (looking effect increase) completely vanishes community (looking effect decrease) . wrapper function specifically statistical models fit using DI() function DImodels R package implicitly call visualise_effects_data followed visualise_effects_plot. model object fit using DImodels, users can call data plot functions manually, one one.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effects plot for compositional data — visualise_effects","text":"","code":"visualise_effects(   model,   data = NULL,   var_interest = NULL,   effect = c(\"increase\", \"decrease\", \"both\"),   add_var = list(),   interval = c(\"confidence\", \"prediction\", \"none\"),   conf.level = 0.95,   se = FALSE,   average = TRUE,   pie_colours = NULL,   pie_radius = 0.3,   FG = NULL,   plot = TRUE,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Effects plot for compositional data — visualise_effects","text":"model Diversity Interactions model object fit using `DI()` function `DImodels` package. data dataframe specifying communities interest user wants visualise effect species decrease increase. left blank, communities original data used fit model selected. var_interest character vector specifying variable visualise effect change response. left blank, variables assumed interest. effect One \"increase\", \"decrease\" \"\" indicate whether look effect increasing proportion, decreasing proportion simultaneously, respectively response. default \"increasing\". add_var list specifying values additional variables model proportions (.e. part simplex design). useful compare predictions across different values categorical variable. One plot generated unique combination values specified . interval Type interval calculate: \"none\" interval calculated. \"confidence\" (default) Calculate confidence interval. \"prediction\" Calculate prediction interval. conf.level confidence level calculating confidence/prediction intervals. Default 0.95. se boolean variable indicating whether plot confidence intervals associated effect species increase decrease average boolean value indicating whether add line describing \"average\" effect variable increase decrease. average calculated median value variables specified. pie_colours character vector indicating colours slices pie-glyphs.  left NULL, colour blind friendly colours pie-glyph slices. pie_radius numeric value specifying radius (cm) pie-glyphs. Default 0.3 cm. FG higher level grouping compositional variables data. Variables belonging group assigned different shades colour. user can manually specify character vector giving group variable belongs . left empty function try get grouping original DI model object. plot boolean variable indicating whether create plot return prepared data instead. default `TRUE` creates plot `FALSE` return prepared data plotting. useful user wants modify data first call plotting function manually. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Effects plot for compositional data — visualise_effects","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Effects plot for compositional data — visualise_effects","text":"","code":"library(DImodels)  ## Load data data(sim1)  ## Fit model mod <- DI(prop = 3:6, DImodel = \"AV\", data = sim1, y = \"response\") #> Fitted model: Average interactions 'AV' DImodel  ## Get effects plot for all species in design visualise_effects(model = mod) #> • `var_interest` was not specified. Assuming all variables are of interest. #> ✔ Finished data preparation. #> ✔ Created plot.   ## Choose a variable of interest using `var_interest` visualise_effects(model = mod, var_interest = c(\"p1\", \"p3\")) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Add custom communities to plot instead of design communities ## Any variable not specified will be assumed to be 0 ## Not showing the average curve using `average = FALSE` visualise_effects(model = mod, average = FALSE,                   data = data.frame(\"p1\" = c(0.7, 0.1),                                     \"p2\" = c(0.3, 0.5),                                     \"p3\" = c(0,   0.4)),                   var_interest = c(\"p2\", \"p3\")) #> • The variable \"p4\" was not present in the data specified, assuming their #>   proportions to be 0. #> ✔ Finished data preparation. #> ✔ Created plot.   ## Add uncertainty on plot visualise_effects(model = mod, average = TRUE,                   data = data.frame(\"p1\" = c(0.7, 0.1),                                     \"p2\" = c(0.3, 0.5),                                     \"p3\" = c(0,   0.4)),                   var_interest = c(\"p2\", \"p3\"), se = TRUE) #> • The variable \"p4\" was not present in the data specified, assuming their #>   proportions to be 0. #> ✔ Finished data preparation. #> ✔ Created plot.   ## Visualise effect of species decrease for particular species ## Show a 99% confidence interval using `conf.level` visualise_effects(model = mod, effect = \"decrease\",                   average = TRUE, se = TRUE, conf.level = 0.99,                   data = data.frame(\"p1\" = c(0.7, 0.1),                                     \"p2\" = c(0.3, 0.5),                                     \"p3\" = c(0,   0.4),                                     \"p4\" = 0),                   var_interest = c(\"p1\", \"p3\")) #> ✔ Finished data preparation. #> ✔ Created plot.   ## Show effects of both increase and decrease using `effect = \"both\"` ## and change colours of pie-glyphs using `pie_colours` visualise_effects(model = mod, effect = \"both\",                   average = FALSE,                   pie_colours = c(\"steelblue1\", \"steelblue4\", \"orange1\", \"orange4\"),                   data = data.frame(\"p1\" = c(0.7, 0.1),                                     \"p2\" = c(0.3, 0.5),                                     \"p3\" = c(0,   0.4),                                     \"p4\" = 0),                   var_interest = c(\"p1\", \"p3\")) #> ✔ Finished data preparation. #> ✔ Created plot.   # Add additional variables and create a separate plot for each # \\donttest{ visualise_effects(model = mod, effect = \"both\",                   average = FALSE,                   pie_colours = c(\"steelblue1\", \"steelblue4\", \"orange1\", \"orange4\"),                   data = data.frame(\"p1\" = c(0.7, 0.1),                                     \"p2\" = c(0.3, 0.5),                                     \"p3\" = c(0,   0.4),                                     \"p4\" = 0),                   var_interest = c(\"p1\", \"p3\"),                   add_var = list(\"block\" = factor(c(1, 2),                                                   levels = c(1, 2, 3, 4)))) #> ✔ Finished data preparation. #> ✔ Created all plots.  # }  ## Specify `plot = FALSE` to not create the plot but return the prepared data head(visualise_effects(model = mod, effect = \"both\",                        average = FALSE, plot = FALSE,                        pie_colours = c(\"steelblue1\", \"steelblue4\",                                        \"orange1\", \"orange4\"),                        data = data.frame(\"p1\" = c(0.7, 0.1),                                          \"p2\" = c(0.3, 0.5),                                          \"p3\" = c(0,   0.4),                                          \"p4\" = 0),                        var_interest = c(\"p1\", \"p3\"))) #> ✔ Finished data preparation. #>      p1    p2 p3 p4 .Sp .Proportion .Group    .Pred   .Lower   .Upper .Marginal #> 1 0.000 1.000  0  0  p1       0.000      1 10.39773 9.297929 11.49753 0.9694331 #> 2 0.014 0.986  0  0  p1       0.014      1 10.41130 9.341016 11.48159 0.9519870 #> 3 0.028 0.972  0  0  p1       0.028      1 10.42463 9.382816 11.46645 0.9345409 #> 4 0.042 0.958  0  0  p1       0.042      1 10.43771 9.423328 11.45210 0.9170948 #> 5 0.056 0.944  0  0  p1       0.056      1 10.45055 9.462555 11.43855 0.8996487 #> 6 0.070 0.930  0  0  p1       0.070      1 10.46315 9.500501 11.42580 0.8822026 #>   .Threshold .MarEffect .Effect #> 1      0.784   Negative    both #> 2      0.784   Negative    both #> 3      0.784   Negative    both #> 4      0.784   Negative    both #> 5      0.784   Negative    both #> 6      0.784   Negative    both"},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare data for effects plots for compositional data — visualise_effects_data","title":"Prepare data for effects plots for compositional data — visualise_effects_data","text":"helper function create underlying data visualising effect increasing decreasing () proportion variable set compositional variables. special case simplex_path function end points either monoculture (.e. variable interest = 1, others equal 0) variable interest (increasing proportion) community without variable interest (decreasing proportion). observations specified `data` connected respective communities (monoculture variable interest community without variable interest) straight line across simplex; effect changing proportion variable interest whilst adjusting proportion variables keeping ratio relative proportions unchanged, thereby preserving compositional nature data. See examples information. output function can passed visualise_effects_plot function visualise results.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare data for effects plots for compositional data — visualise_effects_data","text":"","code":"visualise_effects_data(   data,   prop,   var_interest = NULL,   effect = c(\"increase\", \"decrease\", \"both\"),   add_var = list(),   prediction = TRUE,   ... )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare data for effects plots for compositional data — visualise_effects_data","text":"data dataframe specifying initial communities interest visualise effect increasing/decreasing variable. model object specified data contain variables present model object including additional variables part simplex design. coefficient vector specified data contain number columns number elements coefficient vector one--one positional mapping assumed data columns elements coefficient vector. prop vector column names indices identifying columns containing variable proportions (.e., compositional columns) data. var_interest character vector specifying variable visualise effect change response. left blank, variables assumed interest. effect One \"increase\", \"decrease\" \"\" indicate whether look effect increasing proportion, decreasing proportion simultaneously, respectively response. default \"increasing\". add_var list specifying values additional variables model proportions (.e. part simplex design). useful compare predictions across different values categorical variable. One plot generated unique combination values specified . prediction logical value indicating whether pass final data `add_prediction` add predictions data. Default value TRUE, often desirable make additional changes data making predictions, user can set FALSE manually call `add_prediction` function. ... Arguments passed add_prediction model regression model object used make predictions observations `data`. override `coefficients` specified. coefficients regression model available (fit R), regression coefficients model fit language can used calculate predictions. However, user ensure appropriate one--one positional mapping data columns coefficient values. , also provide variance-covariance matrix coefficients `vcov` parameter want associated CI prediction possible calculate confidence/prediction intervals using method. vcov regression coefficients specified, variance-covariance matrix coefficients can specified calculate associated confidence interval around prediction. Failure result confidence intervals returned. Ensure `coefficients` `vcov` positional mapping data. coeff_cols `coefficients` specified one--one positional mapping data-columns coefficient vector present. character string numeric index can specified reorder data columns match corresponding coefficient value respective data column. See \"Use model coefficients prediction\" section examples. conf.level confidence level calculating confidence/prediction intervals. Default 0.95. interval Type interval calculate: \"none\" (default) interval calculated. \"confidence\" Calculate confidence interval. \"prediction\" Calculate prediction interval.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare data for effects plots for compositional data — visualise_effects_data","text":"data frame following columns appended end .Sp identifier column discern variable interest               modified curve. .Proportion value variable interest within community. .Group identifier column discern different curves. .add_str_ID identifier column grouping cartesian product                       additional columns specified `add_var`                       parameter (`add_var` specified). .Pred predicted response observation. .Lower lower limit prediction/confidence interval                  observation. .Upper upper limit prediction/confidence interval                  observation. .Marginal marginal change response (first derivative)                     respect gradual change proportion                     species interest. .Threshold numeric value indicating maximum proportion                      species interest within particular community                      positive marginal effect response. .MarEffect character string entailing whether increase/decrease                      species interest particular community                      result positive negative marginal effect                      response. .Effect identifier column signifying whether considering                   effect species addition species decrease.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare data for effects plots for compositional data — visualise_effects_data","text":"","code":"library(DImodels)  ## Load data data(sim1)  ## Fit model mod <- glm(response ~ p1 + p2 + p3 + p4 + 0, data = sim1)  ## Create data for visualising effect of increasing the proportion of ## variable p1 in data ## Notice how the proportion of `p1` increases while the proportion of ## the other variables decreases whilst maintaining their relative proportions head(visualise_effects_data(data = sim1, prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                             var_interest = \"p1\", effect = \"increase\",                             model = mod)) #> ✔ Finished data preparation. #>      p1    p2    p3    p4 community block response .Sp .Proportion .Group #> 1 0.700 0.100 0.100 0.100         1     1   10.815  p1       0.700      1 #> 2 0.703 0.099 0.099 0.099         1     1   10.815  p1       0.703      1 #> 3 0.706 0.098 0.098 0.098         1     1   10.815  p1       0.706      1 #> 4 0.709 0.097 0.097 0.097         1     1   10.815  p1       0.709      1 #> 5 0.712 0.096 0.096 0.096         1     1   10.815  p1       0.712      1 #> 6 0.715 0.095 0.095 0.095         1     1   10.815  p1       0.715      1 #>      .Pred   .Lower   .Upper .Marginal .Threshold .MarEffect  .Effect #> 1 10.42269 9.789966 11.05541  1.559416      0.826   Negative increase #> 2 10.42737 9.791585 11.06315  1.559416      0.826   Negative increase #> 3 10.43204 9.793199 11.07089  1.559416      0.826   Negative increase #> 4 10.43672 9.794807 11.07864  1.559416      0.826   Negative increase #> 5 10.44140 9.796410 11.08639  1.559416      0.826   Negative increase #> 6 10.44608 9.798008 11.09415  1.559416      0.826   Negative increase  ## Create data for visualising the effect of decreasing the proportion ## variable p1 in data using `effect = \"decrease\"` head(visualise_effects_data(data = sim1, prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                             var_interest = \"p1\", effect = \"decrease\",                             model = mod)) #> ✔ Finished data preparation. #>      p1        p2        p3        p4 community block response .Sp .Proportion #> 1 0.000 0.3333333 0.3333333 0.3333333         1     1   10.815  p1       0.000 #> 2 0.007 0.3310000 0.3310000 0.3310000         1     1   10.815  p1       0.007 #> 3 0.014 0.3286667 0.3286667 0.3286667         1     1   10.815  p1       0.014 #> 4 0.021 0.3263333 0.3263333 0.3263333         1     1   10.815  p1       0.021 #> 5 0.028 0.3240000 0.3240000 0.3240000         1     1   10.815  p1       0.028 #> 6 0.035 0.3216667 0.3216667 0.3216667         1     1   10.815  p1       0.035 #>   .Group    .Pred   .Lower   .Upper .Marginal .Threshold .MarEffect  .Effect #> 1      1 9.331096 8.884095 9.778097  1.559416      0.287   Negative decrease #> 2      1 9.342012 8.900575 9.783450  1.559416      0.287   Negative decrease #> 3      1 9.352928 8.916964 9.788892  1.559416      0.287   Negative decrease #> 4      1 9.363844 8.933260 9.794427  1.559416      0.287   Negative decrease #> 5      1 9.374760 8.949459 9.800060  1.559416      0.287   Negative decrease #> 6      1 9.385676 8.965558 9.805793  1.559416      0.287   Negative decrease  ## Create data for visualising the effect of increasing and decreasing the ## proportion variable p3 in data using `effect = \"both\"` head(visualise_effects_data(data = sim1, prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                             var_interest = \"p3\", effect = \"decrease\",                             model = mod)) #> ✔ Finished data preparation. #>          p1        p2    p3        p4 community block response .Sp .Proportion #> 1 0.7777778 0.1111111 0.000 0.1111111         1     1   10.815  p3       0.000 #> 2 0.7770000 0.1110000 0.001 0.1110000         1     1   10.815  p3       0.001 #> 3 0.7762222 0.1108889 0.002 0.1108889         1     1   10.815  p3       0.002 #> 4 0.7754444 0.1107778 0.003 0.1107778         1     1   10.815  p3       0.003 #> 5 0.7746667 0.1106667 0.004 0.1106667         1     1   10.815  p3       0.004 #> 6 0.7738889 0.1105556 0.005 0.1105556         1     1   10.815  p3       0.005 #>   .Group    .Pred   .Lower   .Upper  .Marginal .Threshold .MarEffect  .Effect #> 1      1 10.51542 9.795624 11.23522 -0.9273268      0.066   Negative decrease #> 2      1 10.51449 9.795636 11.23335 -0.9273268      0.066   Negative decrease #> 3      1 10.51357 9.795646 11.23148 -0.9273268      0.066   Negative decrease #> 4      1 10.51264 9.795656 11.22962 -0.9273268      0.066   Negative decrease #> 5      1 10.51171 9.795664 11.22776 -0.9273268      0.066   Negative decrease #> 6      1 10.51078 9.795671 11.22590 -0.9273268      0.066   Negative decrease  ## Getting prediction intervals at a 99% confidence level head(visualise_effects_data(data = sim1, prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                             var_interest = \"p1\", effect = \"decrease\",                             model = mod, conf.level = 0.99,                             interval = \"prediction\")) #> ✔ Finished data preparation. #>      p1        p2        p3        p4 community block response .Sp .Proportion #> 1 0.000 0.3333333 0.3333333 0.3333333         1     1   10.815  p1       0.000 #> 2 0.007 0.3310000 0.3310000 0.3310000         1     1   10.815  p1       0.007 #> 3 0.014 0.3286667 0.3286667 0.3286667         1     1   10.815  p1       0.014 #> 4 0.021 0.3263333 0.3263333 0.3263333         1     1   10.815  p1       0.021 #> 5 0.028 0.3240000 0.3240000 0.3240000         1     1   10.815  p1       0.028 #> 6 0.035 0.3216667 0.3216667 0.3216667         1     1   10.815  p1       0.035 #>   .Group    .Pred   .Lower   .Upper .Marginal .Threshold .MarEffect  .Effect #> 1      1 9.331096 5.855633 12.80656  1.559416      0.287   Negative decrease #> 2      1 9.342012 5.867809 12.81621  1.559416      0.287   Negative decrease #> 3      1 9.352928 5.879950 12.82591  1.559416      0.287   Negative decrease #> 4      1 9.363844 5.892055 12.83563  1.559416      0.287   Negative decrease #> 5      1 9.374760 5.904125 12.84539  1.559416      0.287   Negative decrease #> 6      1 9.385676 5.916160 12.85519  1.559416      0.287   Negative decrease  ## Adding additional variables to the data using `add_var` ## Notice the new .add_str_ID column in the output sim1$block <- as.numeric(sim1$block) new_mod <- update(mod, ~ . + block, data = sim1) head(visualise_effects_data(data = sim1[, 3:6], prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                             var_interest = \"p1\", effect = \"both\",                             model = new_mod,                             add_var = list(\"block\" = c(1, 2)))) #> ✔ Finished data preparation. #>      p1        p2        p3        p4 block .add_str_ID .Sp .Proportion .Group #> 1 0.000 0.3333333 0.3333333 0.3333333     1    block: 1  p1       0.000      1 #> 2 0.014 0.3286667 0.3286667 0.3286667     1    block: 1  p1       0.014      1 #> 3 0.028 0.3240000 0.3240000 0.3240000     1    block: 1  p1       0.028      1 #> 4 0.042 0.3193333 0.3193333 0.3193333     1    block: 1  p1       0.042      1 #> 5 0.056 0.3146667 0.3146667 0.3146667     1    block: 1  p1       0.056      1 #> 6 0.070 0.3100000 0.3100000 0.3100000     1    block: 1  p1       0.070      1 #>      .Pred   .Lower   .Upper .Marginal .Threshold .MarEffect .Effect #> 1 9.847626 9.241980 10.45327  1.559416      0.946   Negative    both #> 2 9.869458 9.271266 10.46765  1.559416      0.946   Negative    both #> 3 9.891290 9.300209 10.48237  1.559416      0.946   Negative    both #> 4 9.913122 9.328796 10.49745  1.559416      0.946   Negative    both #> 5 9.934953 9.357015 10.51289  1.559416      0.946   Negative    both #> 6 9.956785 9.384853 10.52872  1.559416      0.946   Negative    both  ## Create data for visualising effect of decreasing variable p2 from ## the original communities in the data but using model coefficients ## When specifying coefficients the data should have a one-to-one ## positional mapping with specified coefficients. init_comms <- sim1[, c(\"p1\", \"p2\", \"p3\", \"p4\")] head(visualise_effects_data(data = init_comms, prop = 1:4,                             var_interest = \"p2\",                             effect = \"decrease\",                             interval = \"none\",                             coefficients = mod$coefficients)) #> ✔ Finished data preparation. #>          p1    p2        p3        p4 .Sp .Proportion .Group    .Pred .Marginal #> 1 0.7777778 0.000 0.1111111 0.1111111  p2       0.000      1 10.41016 0.1252706 #> 2 0.7770000 0.001 0.1110000 0.1110000  p2       0.001      1 10.41029 0.1252706 #> 3 0.7762222 0.002 0.1108889 0.1108889  p2       0.002      1 10.41041 0.1252706 #> 4 0.7754444 0.003 0.1107778 0.1107778  p2       0.003      1 10.41054 0.1252706 #> 5 0.7746667 0.004 0.1106667 0.1106667  p2       0.004      1 10.41066 0.1252706 #> 6 0.7738889 0.005 0.1105556 0.1105556  p2       0.005      1 10.41079 0.1252706 #>   .Threshold .MarEffect  .Effect #> 1      0.067   Negative decrease #> 2      0.067   Negative decrease #> 3      0.067   Negative decrease #> 4      0.067   Negative decrease #> 5      0.067   Negative decrease #> 6      0.067   Negative decrease  ## Note that to get confidence interval when specifying ## model coefficients we'd also need to provide a variance covariance ## matrix using the `vcov` argument head(visualise_effects_data(data = init_comms, prop = 1:4,                             var_interest = \"p2\",                             effect = \"decrease\",                             interval = \"confidence\",                             coefficients = mod$coefficients,                             vcov = vcov(mod))) #> ✔ Finished data preparation. #>          p1    p2        p3        p4 .Sp .Proportion .Group    .Pred   .Lower #> 1 0.7777778 0.000 0.1111111 0.1111111  p2       0.000      1 10.41016 9.705914 #> 2 0.7770000 0.001 0.1110000 0.1110000  p2       0.001      1 10.41029 9.706958 #> 3 0.7762222 0.002 0.1108889 0.1108889  p2       0.002      1 10.41041 9.708001 #> 4 0.7754444 0.003 0.1107778 0.1107778  p2       0.003      1 10.41054 9.709043 #> 5 0.7746667 0.004 0.1106667 0.1106667  p2       0.004      1 10.41066 9.710084 #> 6 0.7738889 0.005 0.1105556 0.1105556  p2       0.005      1 10.41079 9.711123 #>     .Upper .Marginal .Threshold .MarEffect  .Effect #> 1 11.11441 0.1252706      0.067   Negative decrease #> 2 11.11361 0.1252706      0.067   Negative decrease #> 3 11.11282 0.1252706      0.067   Negative decrease #> 4 11.11203 0.1252706      0.067   Negative decrease #> 5 11.11124 0.1252706      0.067   Negative decrease #> 6 11.11045 0.1252706      0.067   Negative decrease  ## Can also create only the intermediary communities without predictions ## by specifying prediction = FALSE. ## Any additional columns can then be added and the `add_prediction` function ## can be manually called. ## Note: If calling the `add_prediction` function manually, the data would ## not contain information about the marginal effect of changing the species ## interest effects_data <- visualise_effects_data(data = init_comms, prop = 1:4,                                        var_interest = \"p2\",                                        effect = \"decrease\",                                        prediction = FALSE) #> ✔ Finished data preparation. head(effects_data) #>          p1    p2        p3        p4 .Sp .Proportion .Group  .Effect #> 1 0.7777778 0.000 0.1111111 0.1111111  p2       0.000      1 decrease #> 2 0.7770000 0.001 0.1110000 0.1110000  p2       0.001      1 decrease #> 3 0.7762222 0.002 0.1108889 0.1108889  p2       0.002      1 decrease #> 4 0.7754444 0.003 0.1107778 0.1107778  p2       0.003      1 decrease #> 5 0.7746667 0.004 0.1106667 0.1106667  p2       0.004      1 decrease #> 6 0.7738889 0.005 0.1105556 0.1105556  p2       0.005      1 decrease ## Prediction using model object head(add_prediction(data = effects_data, model = mod, interval = \"prediction\")) #>          p1    p2        p3        p4 .Sp .Proportion .Group  .Effect    .Pred #> 1 0.7777778 0.000 0.1111111 0.1111111  p2       0.000      1 decrease 10.41016 #> 2 0.7770000 0.001 0.1110000 0.1110000  p2       0.001      1 decrease 10.41029 #> 3 0.7762222 0.002 0.1108889 0.1108889  p2       0.002      1 decrease 10.41041 #> 4 0.7754444 0.003 0.1107778 0.1107778  p2       0.003      1 decrease 10.41054 #> 5 0.7746667 0.004 0.1106667 0.1106667  p2       0.004      1 decrease 10.41066 #> 6 0.7738889 0.005 0.1105556 0.1105556  p2       0.005      1 decrease 10.41079 #>     .Lower   .Upper #> 1 7.738930 13.08139 #> 2 7.739308 13.08126 #> 3 7.739686 13.08114 #> 4 7.740062 13.08101 #> 5 7.740439 13.08088 #> 6 7.740814 13.08076 ## Prediction using regression coefficients head(add_prediction(data = effects_data, coefficients = mod$coefficients)) #>          p1    p2        p3        p4 .Sp .Proportion .Group  .Effect    .Pred #> 1 0.7777778 0.000 0.1111111 0.1111111  p2       0.000      1 decrease 10.41016 #> 2 0.7770000 0.001 0.1110000 0.1110000  p2       0.001      1 decrease 10.41029 #> 3 0.7762222 0.002 0.1108889 0.1108889  p2       0.002      1 decrease 10.41041 #> 4 0.7754444 0.003 0.1107778 0.1107778  p2       0.003      1 decrease 10.41054 #> 5 0.7746667 0.004 0.1106667 0.1106667  p2       0.004      1 decrease 10.41066 #> 6 0.7738889 0.005 0.1105556 0.1105556  p2       0.005      1 decrease 10.41079"},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Effects plot for compositional data — visualise_effects_plot","title":"Effects plot for compositional data — visualise_effects_plot","text":"plotting function create plots showing effect increasing decreasing proportion variable set compositional variables. output `visualise_effects_data` function (desired modifications) passed . generated plot show curve observation (whenever possible) data. `Pie-glyphs` used highlight compositions specified communities ending community variable interest either completes dominates community (looking effect increase) completely vanishes community (looking effect decrease) .","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effects plot for compositional data — visualise_effects_plot","text":"","code":"visualise_effects_plot(   data,   prop,   pie_colours = NULL,   pie_radius = 0.3,   se = FALSE,   average = TRUE,   nrow = 0,   ncol = 0 )"},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Effects plot for compositional data — visualise_effects_plot","text":"data data frame created using visualise_effects_data function. prop vector column names indices identifying columns containing compositional variables data. inferred data created using `visualise_effects_data` function, user also flexibility manually specifying values. pie_colours character vector indicating colours slices pie-glyphs.  left NULL, colour blind friendly colours pie-glyph slices. pie_radius numeric value specifying radius (cm) pie-glyphs. Default 0.3 cm. se boolean variable indicating whether plot confidence intervals associated effect species increase decrease average boolean value indicating whether add line describing \"average\" effect variable increase decrease. average calculated median value variables specified. nrow Number rows arrange final plot (`add_var` specified). ncol Number columns arrange final plot (`add_var` specified).","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Effects plot for compositional data — visualise_effects_plot","text":"ggmultiplot (ggplot single plot returned) class object data-frame (`plot = FALSE`)","code":""},{"path":"https://rishvish.github.io/DImodelsVis/reference/visualise_effects_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Effects plot for compositional data — visualise_effects_plot","text":"","code":"library(DImodels)  ## Load data data(sim1)  ## Fit model mod <- glm(response ~ p1 + p2 + p3 + p4 + 0, data = sim1)  ## Create data for visualising effect of adding species 1 to ## the original communities in the data plot_data <- visualise_effects_data(data = sim1[sim1$block == 1, ],                                     prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                                     var_interest = \"p1\",                                     effect = \"increase\", model = mod) #> ✔ Finished data preparation.  ## Create plot visualise_effects_plot(data = plot_data) #> ✔ Created plot.   ## Show specific curves with prediction intervals subset <- custom_filter(plot_data, .Group %in% c(7, 15)) visualise_effects_plot(data = subset, prop = 1:4, se = TRUE) #> ✔ Created plot.   ## Do not show average effect line visualise_effects_plot(data = subset,                        se = TRUE, average = FALSE) #> ✔ Created plot.   ## Change colours of the pie-glyph slices visualise_effects_plot(data = subset,                        pie_colours = c(\"darkolivegreen\", \"darkolivegreen1\",                                    \"steelblue4\", \"steelblue1\")) #> ✔ Created plot.   #' ## Simultaneously create multiple plots for additional variables sim1$block <- as.numeric(sim1$block) new_mod <- update(mod, ~ . + block, data = sim1) plot_data <- visualise_effects_data(data = sim1[c(1, 5, 9, 13), 3:6],                                     prop = c(\"p1\", \"p2\", \"p3\", \"p4\"),                                     var_interest = \"p3\",                                     model = new_mod, conf.level = 0.95,                                     add_var = list(\"block\" = c(1, 2))) #> ✔ Finished data preparation.  visualise_effects_plot(data = plot_data,                        average = FALSE,                        pie_colours = c(\"darkolivegreen\", \"darkolivegreen1\",                                        \"steelblue4\", \"steelblue1\")) #> ✔ Created all plots."},{"path":"https://rishvish.github.io/DImodelsVis/news/index.html","id":"dimodelsvis-102","dir":"Changelog","previous_headings":"","what":"DImodelsVis 1.0.2","title":"DImodelsVis 1.0.2","text":"Added functionality allowing package work seamlessly model objects fit using DImodelsMulti. Units tests added functions. Additional bug fixes.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/news/index.html","id":"dimodelsvis-101","dir":"Changelog","previous_headings":"","what":"DImodelsVis 1.0.1","title":"DImodelsVis 1.0.1","text":"CRAN release: 2024-02-26 Fixed bug caused vignette building fail Fedora systems. Additional bug fixes streamline code.","code":""},{"path":"https://rishvish.github.io/DImodelsVis/news/index.html","id":"dimodelsvis-100","dir":"Changelog","previous_headings":"","what":"DImodelsVis 1.0.0","title":"DImodelsVis 1.0.0","text":"CRAN release: 2024-02-19 Initial CRAN submission.","code":""}]
